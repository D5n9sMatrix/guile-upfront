
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Constructor and Other Special Functions</title>
    <style type="text/css" media="screen">
      html, body, div, span, object, iframe, h1, h2, h3, h4, h5, h6, p,
      blockquote, pre, a, abbr, address, cite, code, del, dfn, em, figure,
      img, ins, kbd, q, s, samp, small, strong, sub, sup, var, b, u, i, dl,
      dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption,
      tbody, tfoot, thead, tr, th, td {
        background: transparent none repeat scroll 0 0;
        border: 0 none;
        font-size: 100%;
        margin: 0;
        outline: 0 none;
        padding: 0;
        vertical-align: baseline;
      }

      h1 { font-size: 200%; }
      h2 { font-size: 160%; }
      h3 { font-size: 120%; }
      h4 { font-size: 100%; }
      h5 { font-size: 80%; }
      h6 { font-size: 80%; font-weight: normal; }

      ul, ol {
        margin: 1.4em 0;
      }
      ul ul, ol ol, ul ol, ol ul {
        margin-top: 0;
        margin-bottom: 0;
      }
      ul, ol {
        margin-left: 2.8em;
      }

      ol {
        list-style: decimal;
      }
      ol ol {
        list-style: lower-alpha;
      }
      ol ol ol {
        list-style: lower-roman;
      }
      ol ol ol ol {
        list-style: decimal;
      }

      blockquote {
        margin: 0.1em;
        margin-left: 1em;
        border-left: 2px solid #cccccc;
        padding-left: 0.7em;
      }

      .color_red { color: #dc322f; }
      .color_blue { color: #268bd2; }
      .color_green { color: #859901; }
      .color_yellow { color: #b58901; }
      .color_black { color: black; }
      .color_white { color: white; }

      .font_big {
        font-size: 1.2em;
      }

      .ddoc_section_h {
        font-weight: bold;
        font-size: 13px;
        line-height: 19.5px;
        margin-top: 11px;
        display: block;
      }

      body.dlang .dlang {
        display: inline-block;
      }

      body.dlang .declaration .dlang {
          display: block;
      }

      body.dlang .ddoc_header_anchor a.dlang {
        display: block;
        color: rgba(0, 136, 204, 1);
        text-decoration: none;
      }

      body.dlang .ddoc_header_anchor .code {
        color: rgba(0, 136, 204, 1);
      }

      #ddoc_main .module {
          border-color: currentColor rgba(233, 233, 233, 1) rgba(233, 233, 233, 1);
          border-style: none solid solid;
          border-width: 0 1px 1px;
          overflow-x: hidden;
          padding: 15px;
      }

      #ddoc_main .section .section {
        margin-top: 0;
      }

      #ddoc_main .ddoc_module_members_section {
          padding: 1px 0 0;
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .ddoc_member, #ddoc_main .ddoc_module_members section.intro {
          background: #fff none repeat scroll 0 0;
          list-style-type: none;
          width: 100%;
      }

      #ddoc_main .ddoc_header_anchor {
          font-size: 1.4em;
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .ddoc_header_anchor > .code {
          display: inline-block;

      }

      #ddoc_main .ddoc_decl {
        background-color: transparent;
        height: 100%;
        left: 0;
        top: 0;
        padding: 0;
        padding-left: 15px;
      }

      #ddoc_main .ddoc_decl .section, #ddoc_main .section.ddoc_sections {
        background: white none repeat scroll 0 0;
        margin: 0;
        padding: 5px;
        position: relative;
        border-radius: 5px;
      }

      #ddoc_main .ddoc_decl .section h4:first-of-type, #ddoc_main .section.ddoc_sections h4:first-of-type {
        font-size: 13px;
        line-height: 1.5;
        margin-top: 21px;
      }

      #ddoc_main .section .declaration {
          margin-top: 21px;
      }

      #ddoc_main .section .declaration .code {
          color: rgba(0, 0, 0, 1);
          margin-bottom: 15px;
          padding-bottom: 6px;
      }

      #ddoc_main .declaration div .para {
          margin-bottom: 0;
      }

      #ddoc_main .ddoc_params .graybox tr td:first-of-type {
        padding: 7px;
        text-align: right;
        vertical-align: top;
        word-break: normal;
        white-space: nowrap;
      }

      #ddoc_main .ddoc_params .graybox {
        border: 0 none;
      }

      #ddoc_main .ddoc_params .graybox td {
        border-color: rgba(214, 214, 214, 1);
      }

      #ddoc_main .ddoc_params .graybox tr:first-child > td {
        border-top: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr:last-child > td {
        border-bottom: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr > td:first-child {
        border-left: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr > td:last-child {
        border-right: 0 none;
        width: 100%;
      }

      #ddoc_main em.term, #ddoc_main em.term .code {
        color: rgba(65, 65, 65, 1);
        font-size: 12px;
        font-style: italic;
        line-height: 1.5;
      }

      #ddoc_main .see-also {
        cursor: pointer;
        font-family: Menlo,monospace;
      }

      #ddoc_main .ddoc_decl .section > div:last-of-type {
        margin-bottom: 15px;
      }

      #ddoc_main .ddoc_member, #ddoc_main .ddoc_module_members {
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .code_sample {
        background: inherit;
      }

      #ddoc_main .declaration .code-line {
          display: block;
          font: 1em Menlo,monospace;
      }

      #ddoc_main a[name] {
        margin: -112px 0 0;
        padding-top: 112px;
      }

      #ddoc_main .ddoc_decl td {
        max-width: inherit;
      }

      #ddoc_main .declaration a {
        color: inherit;
      }

      #ddoc_main .declaration a:hover {
          color: rgba(0, 136, 204, 1);
          text-decoration: underline;
      }

      body.ddoc {
        background-color: transparent;
        color: rgba(0, 0, 0, 1);
        font-family: Helvetica,Arial,sans-serif;
        font-size: 62.5%;
        margin: 0;
        border: 0;
        left: 0;
        top: 0;
        padding: 0;
      }

      .ddoc a[name] {
        display: block;
        height: 0;
        margin: -85px 0 0;
        padding-top: 85px;
        width: 0;
      }

      .ddoc .module {
          border-color: transparent;
          background-color: rgba(255, 255, 255, 1);
          border-color: currentColor rgba(233, 233, 233, 1) rgba(233, 233, 233, 1);
          border-image: none;
          border-style: none solid solid;
          border-width: 0 1px 1px;
          box-shadow: 0 0 1px rgba(0, 0, 0, 0.07);
          display: block;
          margin-left: 0;
          min-height: calc(100% - 173px);
          overflow: auto;
          padding-bottom: 100px;
      }

      .ddoc .content_wrapper {
          background-color: rgba(242, 242, 242, 1);
          margin: 0 auto;
          max-width: 980px;
      }

      .ddoc .section {
        padding: 15px 25px 30px;
      }

      .ddoc .section .section {
        margin: 30px 0 0;
        padding: 0;
      }

      .ddoc .para {
        color: rgba(65, 65, 65, 1);
        font-size: 1.4em;
        line-height: 145%;
        margin-bottom: 15px;
      }

      .ddoc .ddoc_examples .para {
        margin-bottom: 0;
      }

      .ddoc .module_name {
          color: rgba(0, 0, 0, 1);
          display: block;
          font-family: Helvetica;
          font-size: 2.8em;
          font-weight: 100;
          margin-bottom: 0;
          padding: 15px 0;
      }

      .ddoc .module a {
          color: rgba(0, 136, 204, 1);
          text-decoration: none;
      }

      .ddoc .code {
        color: rgba(128, 128, 128, 1);
        font-family: Menlo,monospace;
        font-size: 0.85em;
        word-wrap: break-word;
      }

      .ddoc .code i {
        font-style: normal;
      }

      .ddoc .code .code {
        font-size: 1em;
      }

      .ddoc .code_sample {
        background-clip: padding-box;
        margin: 1px 0;
        text-align: left;
      }

      .ddoc .code_sample {
        display: block;
        font-size: 1.4em;
        margin-left: 21px;
      }

      .ddoc ol .code_sample {
        font-size: 1em;
      }

      .ddoc .code_lines {
        counter-reset: li;
        line-height: 1.6em;
        list-style: outside none none;
        margin: 0;
        padding: 0;
      }

      .ddoc .code_listing .code_sample div {
        margin-left: 13px;
        width: 93%;
      }

      .ddoc .code_listing .code_sample div .code_lines li {
        list-style-type: none;
        margin: 0;
        padding-right: 10px;
      }

      .ddoc .code_sample div .code_lines li::before {
        margin-left: -33px;
        margin-right: 25px;
      }

      .ddoc .code_sample div .code_lines li:nth-child(n+10)::before {
        margin-left: -39px;
        margin-right: 25px;
      }

      .ddoc .code_sample div .code_lines li:nth-child(n+100)::before {
        margin-left: -46px;
        margin-right: 25px;
      }

      .ddoc .code_sample .code_lines .code {
        color: #000;
      }

      .ddoc div.dlang {
        margin: 10px 0 21px;
        padding: 4px 0 2px 10px;
      }

      .ddoc div.dlang {
          margin: 10px 0 21px;
          padding: 4px 0 2px 10px;
      }

      .ddoc div.dlang {
        border-left: 5px solid rgba(0, 155, 51, 0.2);
      }

      .ddoc .code_lines li::before {
        color: rgba(128, 128, 128, 1);
        content: counter(li, decimal);
        counter-increment: li;
        font-family: Menlo,monospace;
        font-size: 0.9em;
        margin-right: 16px;
      }

      .ddoc .code_lines li {
        padding-left: 0;
        white-space: pre-wrap;
      }

      .ddoc .code_lines li:only-of-type::before {
        color: rgba(255, 255, 255, 1);
        content: " ";
      }

      .ddoc .code_lines li:only-of-type {
        color: rgba(255, 255, 255, 1);
        content: " ";
      }

      .ddoc .code_lines li:nth-child(n+10) {
        text-indent: -17px;
      }

      .ddoc .code_lines li:nth-child(n+10)::before {
        margin-right: 12px;
      }

      .ddoc .graybox {
        border: 1px solid rgba(233, 233, 233, 1);
        border-collapse: collapse;
        border-spacing: 0;
        empty-cells: hide;
        margin: 20px 0 36px;
        text-align: left;
      }

      .ddoc .graybox p {
        margin: 0;
        min-width: 50px;
      }

      .ddoc th {
        margin: 0;
        max-width: 260px;
        padding: 5px 10px 5px 10px;
        vertical-align: bottom;
      }

      .ddoc td {
        border: 1px solid rgba(233, 233, 233, 1);
        margin: 0;
        max-width: 260px;
        padding: 5px 10px 5px 10px;
        vertical-align: middle;
      }

      .punctuation {
        color: rgba(0, 0, 0, 1);
      }

      .comment {
        color: rgba(0, 131, 18, 1);
      }

      .operator {
        color: #000;
      }

      .keyword {
        color: rgba(170, 13, 145, 1);
      }

      .keyword_type {
        color: rgba(170, 51, 145, 1);
      }

      .string_literal {
        color: rgba(196, 26, 22, 1);
      }

      .ddoc_psuper_symbol {
        color: rgba(92, 38, 153, 1);
      }

      .param {
        color: rgba(0, 0, 0, 1);
      }

      .psymbol {
        color: rgba(0, 0, 0, 1);
      }

      .ddoc_member_header .ddoc_header_anchor .code {
        font-size: 1em;
      }
    </style>
  </head>
  <body id="ddoc_main" class="ddoc dlang">
    <div class="content_wrapper">
      <article class="module">
        <h1 class="module_name">Constructor and Other Special Functions</h1>
        <section id="module_content"><br><br>
<br><br>

<br><br>
<p>Although this chapter focuses only on structs, the topics that are covered here apply mostly to classes as well. The differences will be explained in later chapters.
</p>
<br><br>
<p>Four member functions of structs are special because they define the fundamental operations of that type:
</p>
<ul><li>Constructor: </li>
<li>Destructor: </li>
<li>Postblit: </li>
<li>Assignment operator: </li>
</ul>
<br><br>
<p>Although these fundamental operations are handled automatically for structs, hence need not be defined by the programmer, they can be overridden to make the  behave in special ways.
</p>
<br><br>
<h5>  Constructor</h5>
<br><br>
<p>The responsibility of the constructor is to prepare an object for use by assigning appropriate values to its members.
</p>
<br><br>
<p>We have already used constructors in previous chapters. When the name of a type is used like a function, it is actually the constructor that gets called. We can see this on the right-hand side of the following line:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">auto</span> busArrival = (8, 30);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Similarly, a <i>class</i> object is being constructed on the right hand side of the following line:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">auto</span> variable = <span class="keyword">new</span> ;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The arguments that are specified within parentheses correspond to the constructor parameters. For example, the values 8 and 30 above are passed to the  constructor as its parameters.
</p>
<br><br>
<p>In addition to different object construction syntaxes that we have seen so far; , , and  objects can be constructed with the <i>type constructor</i> syntax as well (e.g. as ). (We will see the  keyword in <a href="concurrency_shared.html">a later chapter</a>.)
</p>
<br><br>
<p>For example, although all three variables below are , the construction of variable  is semantically different from the constructions of variables  and :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="comment">/* More familiar syntax; immutable variable of a mutable
     * type: */</span>
     a = S(1);

    <span class="comment">/* Type constructor syntax; a variable of an immutable
     * type: */</span>
    <span class="keyword">auto</span> b = (2);

    <span class="comment">/* Same meaning as 'b' */</span>
    <span class="keyword">immutable</span> c = (3);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<h6>Constructor syntax</h6>
<br><br>
<p>Different from other functions, constructors do not have return values. The name of the constructor is always :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> SomeStruct {
    <span class="comment">// ...
</span>
    <span class="keyword">this</span>(<span class="comment">/* constructor parameters */</span>) {
        <span class="comment">// ... operations that prepare the object for use ...
</span>    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The constructor parameters include information that is needed to make a useful and consistent object.
</p>
<br><br>
<h6>  Compiler-generated automatic constructor</h6>
<br><br>
<p>All of the structs that we have seen so far have been taking advantage of a constructor that has been generated automatically by the compiler. The automatic constructor assigns the parameter values to the members in the order that they are specified.
</p>
<br><br>
<p>As you will remember from <a href="struct.html">the Structs chapter</a>, the initial values for the trailing members need not be specified. The members that are not specified get initialized by the  value of their respective types.  The  values of a member could be provided during the definition of that member after the  operator:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> Test {
    <span class="keyword">int</span> member ;
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Also considering the <i>default parameter values</i> feature from <a href="parameter_flexibility.html">the Variable Number of Parameters chapter</a>, we can imagine that the automatic constructor for the following  would be the equivalent of the following :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> Test {
    <span class="keyword">char</span>   c;
    <span class="keyword">int</span>    i;
    <span class="keyword">double</span> d;

    <span class="comment">/* The equivalent of the compiler-generated automatic
     * constructor (Note: This is only for demonstration; the
     * following constructor would not actually be called
     * when default-constructing the object as Test().) */</span>
    <span class="keyword">this</span>(<span class="keyword">char</span>   c_parameter = <span class="keyword">char</span>.init,
         <span class="keyword">int</span>    i_parameter = <span class="keyword">int</span>.init,
         <span class="keyword">double</span> d_parameter = <span class="keyword">double</span>.init) {
        c = c_parameter;
        i = i_parameter;
        d = d_parameter;
    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>For most structs, the compiler-generated constructor is sufficient: Usually, providing appropriate values for each member is all that is needed for objects to be constructed.
</p>
<br><br>
<h6> Accessing the members by </h6>
<br><br>
<p>To avoid mixing the parameters with the members, the parameter names above had  appended to their names. There would be compilation errors without doing that:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> Test {
    <span class="keyword">char</span>   c;
    <span class="keyword">int</span>    i;
    <span class="keyword">double</span> d;

    <span class="keyword">this</span>(<span class="keyword">char</span>   c = <span class="keyword">char</span>.init,
         <span class="keyword">int</span>    i = <span class="keyword">int</span>.init,
         <span class="keyword">double</span> d = <span class="keyword">double</span>.init) {
        <span class="comment">// An attempt to assign an 'in' parameter to itself!
</span>        c = c;    
        i = i;
        d = d;
    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The reason is;  alone would mean the parameter, not the member, and as the parameters above are defined as , they cannot be modified:
</p>
<br><br>

<br><br>
<p>A solution is to prepend the member names with . Inside member functions,  means "this object", making  mean "the c member of this object":
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">this</span>(<span class="keyword">char</span>   c = <span class="keyword">char</span>.init,
         <span class="keyword">int</span>    i = <span class="keyword">int</span>.init,
         <span class="keyword">double</span> d = <span class="keyword">double</span>.init) {
        c = c;
        i = i;
        d = d;
    }
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Now  alone means the parameter and  means the member, and the code compiles and works as expected: The member  gets initialized by the value of the parameter .
</p>
<br><br>
<h6> User-defined constructors</h6>
<br><br>
<p>I have described the behavior of the compiler-generated constructor. Since that constructor is suitable for most cases, there is no need to define a constructor by hand.
</p>
<br><br>
<p>Still, there are cases where constructing an object involves more complicated operations than assigning values to each member in order. As an example, let's consider  from the earlier chapters:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> Duration {
    <span class="keyword">int</span> minute;
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The compiler-generated constructor is sufficient for this single-member struct:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    time.decrement(Duration(12));
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Since that constructor takes the duration in minutes, the programmers would sometimes need to make calculations:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="comment">// 23 hours and 18 minutes earlier
</span>    time.decrement(Duration(23 * 60 + 18));

    <span class="comment">// 22 hours and 20 minutes later
</span>    time.increment(Duration(22 * 60 + 20));
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>To eliminate the need for these calculations, we can design a  constructor that takes two parameters and makes the calculation automatically:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> Duration {
    <span class="keyword">int</span> minute;

    <span class="keyword">this</span>(<span class="keyword">int</span> hour, <span class="keyword">int</span> minute) {
        <span class="keyword">this</span>.minute = hour * 60 + minute;
    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Since hour and minute are now separate parameters, the users simply provide their values without needing to make the calculation themselves:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="comment">// 23 hours and 18 minutes earlier
</span>    time.decrement(Duration());

    <span class="comment">// 22 hours and 20 minutes later
</span>    time.increment(Duration());
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<h6>First assignment to a member is construction</h6>
<br><br>
<p>When setting values of members in a constructor, the first assignment to each member is treated specially: Instead of assigning a new value over the  value of that member, the first assignment actually constructs that member. Further assignments to that member are treated regularly as assignment operations.
</p>
<br><br>
<p>This special behavior is necessary so that  and  members can in fact be constructed with values known only at run time. Otherwise, they could never be set to desired values as assignment is disallowed for  and  variables.
</p>
<br><br>
<p>The following program demonstrates how assigment operation is allowed only once for an  member:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> S {
    <span class="keyword">int</span> m;
    <span class="keyword">immutable</span> <span class="keyword">int</span> i;

    <span class="keyword">this</span>(<span class="keyword">int</span> m, <span class="keyword">int</span> i) {
        <span class="keyword">this</span>.m = m;     
        <span class="keyword">this</span>.m = 42;    

        <span class="keyword">this</span>.i = i;     
        <span class="keyword">this</span>.i = i;     
    }
}

<span class="keyword">void</span> main() {
    <span class="keyword">auto</span> s = S(1, 2);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<h6>User-defined constructor disables compiler-generated constructor</h6>
<br><br>
<p>A constructor that is defined by the programmer makes some uses of the compiler-generated constructor invalid: Objects cannot be constructed by <i>default parameter values</i> anymore. For example, trying to construct  by a single parameter is a compilation error:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    time.decrement(Duration(12));    
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Calling the constructor with a single parameter does not match the programmer's constructor and the compiler-generated constructor is disabled.
</p>
<br><br>
<p>One solution is to <i>overload</i> the constructor by providing another constructor that takes just one parameter:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> Duration {
    <span class="keyword">int</span> minute;

    <span class="keyword">this</span>(<span class="keyword">int</span> hour, <span class="keyword">int</span> minute) {
        <span class="keyword">this</span>.minute = hour * 60 + minute;
    }

    <span class="keyword">this</span>(<span class="keyword">int</span> minute) {
        <span class="keyword">this</span>.minute = minute;
    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>A user-defined constructor disables constructing objects by the  syntax as well:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    Duration duration = { 5 };    
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Initializing without providing any parameter is still valid:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">auto</span> d = Duration();    <span class="comment">// compiles
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The reason is, in D, the  value of every type must be known at compile time. The value of  above is equal to the initial value of :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">assert</span>(d == Duration.init);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<h6>   instead of the default constructor</h6>
<br><br>
<p>Because the initial value of every type must be known at compile time, it is impossible to define the default constructor explicitly.
</p>
<br><br>
<p>Let's consider the following constructor that tries to print some information every time an object of that type is constructed:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> Test {
    <span class="keyword">this</span>() {    
        writeln(<span class="string_literal">"A Test object is being constructed."</span>);
    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The compiler output:
</p>
<br><br>

<br><br>
<p><i><b>Note:</b> We will see in later chapters that it is possible to define the default constructor for classes.
</i></p>
<br><br>
<p>As a workaround, a no-parameter  can be used for constructing objects without providing any parameters. Note that this has no effect on the  value of the type.
</p>
<br><br>
<p>For this to work,  must construct and return an object of that struct type:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;

<span class="keyword">struct</span> Test {
     Test () {
        writeln(<span class="string_literal">"A Test object is being constructed."</span>);
        Test test;
        <span class="keyword">return</span> test;
    }
}

<span class="keyword">void</span> main() {
    <span class="keyword">auto</span> test = ;
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The  call in  executes :
</p>
<br><br>

<br><br>
<p>Note that it is not possible to type  inside . That syntax would execute  as well and cause an infinite recursion:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">static</span> Test opCall() {
        writeln(<span class="string_literal">"A Test object is being constructed."</span>);
        <span class="keyword">return</span> ;    <span class="comment">// ← Calls 'static opCall()' again
</span>    }
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The output:
</p>
<br><br>

<br><br>
<h6>Calling other constructors</h6>
<br><br>
<p>Constructors can call other constructors to avoid code duplication. Although  is too simple to demonstrate how useful this feature is, the following single-parameter constructor takes advantage of the two-parameter constructor:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">this</span>(<span class="keyword">int</span> hour, <span class="keyword">int</span> minute) {
        <span class="keyword">this</span>.minute = hour * 60 + minute;
    }

    <span class="keyword">this</span>(<span class="keyword">int</span> minute) {
        <span class="keyword">this</span>(0, minute);    <span class="comment">// calls the other constructor
</span>    }
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The constructor that only takes the minute value calls the other constructor by passing 0 as the value of hour.
</p>
<br><br>
<p><i><b>Warning:</b> There is a design flaw in the  constructors above because the intention is not clear when the objects are constructed by a single parameter</i>:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="comment">// 10 hours or 10 minutes?
</span>    <span class="keyword">auto</span> travelDuration = Duration(10);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Although it is possible to determine by reading the documentation or the code of the struct that the parameter actually means "10 minutes," it is an inconsistency as the first parameter of the two-parameter constructor is <i>hours</i>.
</p>
<br><br>
<p>Such design mistakes are causes of bugs and must be avoided.
</p>
<br><br>
<h6>  Constructor qualifiers</h6>
<br><br>
<p>Normally, the same constructor is used for <i>mutable</i>, , , and  objects:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;

<span class="keyword">struct</span> S {
    <span class="keyword">this</span>(<span class="keyword">int</span> i) {
        writeln(<span class="string_literal">"Constructing an object"</span>);
    }
}

<span class="keyword">void</span> main() {
    <span class="keyword">auto</span> m = S(1);
    <span class="keyword">const</span> c = S(2);
    <span class="keyword">immutable</span> i = S(3);
    <span class="keyword">shared</span> s = S(4);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Semantically, the objects that are constructed on the right-hand sides of those expressions are all mutable but the variables have different type qualifiers. The same constructor is used for all of them:
</p>
<br><br>

<br><br>
<p>Depending on the qualifier of the resulting object, sometimes some members may need to be initialized differently or need not be initialized at all. For example, since no member of an  object can be mutated throughout the lifetime of that object, leaving its mutable members uninitialized can improve program performance.
</p>
<br><br>
<p><i>Qualified constructors</i> can be defined differently for objects with different qualifiers:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;

<span class="keyword">struct</span> S {
    <span class="keyword">this</span>(<span class="keyword">int</span> i) {
        writeln(<span class="string_literal">"Constructing an object"</span>);
    }

    <span class="keyword">this</span>(<span class="keyword">int</span> i)  {
        writeln(<span class="string_literal">"Constructing a const object"</span>);
    }

    <span class="keyword">this</span>(<span class="keyword">int</span> i)  {
        writeln(<span class="string_literal">"Constructing an immutable object"</span>);
    }

    <span class="comment">// We will see the 'shared' keyword in a later chapter.
</span>    <span class="keyword">this</span>(<span class="keyword">int</span> i)  {
        writeln(<span class="string_literal">"Constructing a shared object"</span>);
    }
}

<span class="keyword">void</span> main() {
    <span class="keyword">auto</span> m = S(1);
    <span class="keyword">const</span> c = S(2);
    <span class="keyword">immutable</span> i = S(3);
    <span class="keyword">shared</span> s = S(4);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>However, as indicated above, as the right-hand side expressions are all semantically mutable, those objects are still constructed with the <i>mutable</i> object contructor:
</p>
<br><br>

<br><br>
<p> To take advantage of qualified constructors, one must use the <i>type constructor</i> syntax. (The term <i>type constructor</i> should not be confused with object constructors; type constructor is related to types, not objects.) This syntax <i>makes</i> a different type by combining a qualifier with an existing type. For example,  is a qualified type made from  and :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">auto</span> m = S(1);
    <span class="keyword">auto</span> c = (2);
    <span class="keyword">auto</span> i = (3);
    <span class="keyword">auto</span> s = (4);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>This time, the objects that are in the right-hand expressions are different: <i>mutable</i>, , , and , respectively. As a result, each object is constructed with its matching constructor:
</p>
<br><br>

<br><br>
<p>Note that, since all of the variables above are defined with the  keyword, they are correctly inferred to be <i>mutable</i>, , , and , respectively.
</p>
<br><br>
<h6>Immutability of constructor parameters</h6>
<br><br>
<p>In the <a href="const_and_immutable.html">Immutability chapter</a> we have seen that it is not easy to decide whether parameters of reference types should be defined as  or . Although the same considerations apply for constructor parameters as well,  is usually a better choice for constructor parameters.
</p>
<br><br>
<p>The reason is, it is common to assign the parameters to members to be used at a later time. When a parameter is not , there is no guarantee that the original variable will not change by the time the member gets used.
</p>
<br><br>
<p>Let's consider a constructor that takes a file name as a parameter. The file name will be used later on when writing student grades. According to the guidelines in the <a href="const_and_immutable.html">Immutability chapter</a>, to be more useful, let's assume that the constructor parameter is defined as :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;

<span class="keyword">struct</span> Student {
     fileName;
    <span class="keyword">int</span>[] grades;

    <span class="keyword">this</span>( fileName) {
        <span class="keyword">this</span>.fileName = fileName;
    }

    <span class="keyword">void</span> save() {
        <span class="keyword">auto</span> file = File(fileName.idup, <span class="string_literal">"w"</span>);
        file.writeln(<span class="string_literal">"The grades of the student:"</span>);
        file.writeln(grades);
    }

    <span class="comment">// ...
</span>}

<span class="keyword">void</span> main() {
    <span class="keyword">char</span>[] fileName;
    fileName ~= <span class="string_literal">"student_grades"</span>;

    <span class="keyword">auto</span> student = Student(fileName);

    <span class="comment">// ...
</span>
    <span class="comment">/* Assume the fileName variable is modified later on
     * perhaps unintentionally (all of its characters are
     * being set to 'A' here): */</span>
    ;

    <span class="comment">// ...
</span>
    <span class="comment">/* The grades would be written to the wrong file: */</span>
    student.save();
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The program above saves the grades of the student under a file name that consists of A characters, not to . For that reason, sometimes it is more suitable to define constructor parameters and members of reference types as . We know that this is easy for strings by using aliases like . The following code shows the parts of the struct that would need to be modified:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> Student {
     fileName;
    <span class="comment">// ...
</span>    <span class="keyword">this</span>( fileName) {
        <span class="comment">// ...
</span>    }
    <span class="comment">// ...
</span>}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Now the users of the struct must provide  strings and as a result the confusion about the name of the file would be prevented.
</p>
<br><br>
<h6> Type conversions through single-parameter constructors</h6>
<br><br>
<p>Single-parameter constructors can be thought of as providing a sort of type conversion: They produce an object of the particular struct type starting from a constructor parameter. For example, the following constructor produces a  object from a :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> Student {
    string name;

    <span class="keyword">this</span>(string name) {
        <span class="keyword">this</span>.name = name;
    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p> and  observe this behavior as a <i>conversion</i> as well. To see examples of this, let's consider the following  function. Sending a  parameter when it expects a  would naturally cause a compilation error:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">void</span> salute(Student student) {
    writeln(<span class="string_literal">"Hello "</span>, student.name);
}
<span class="comment">// ...
</span>    salute(<span class="string_literal">"Jane"</span>);    
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>On the other hand, all of the following lines ensure that a  object is constructed before calling the function:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.conv;
<span class="comment">// ...
</span>    salute(Student(<span class="string_literal">"Jane"</span>));
    salute(to!Student(<span class="string_literal">"Jean"</span>));
    salute(<span class="keyword">cast</span>(Student)<span class="string_literal">"Jim"</span>);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p> and  take advantage of the single-parameter constructor by constructing a temporary  object and calling  with that object.
</p>
<br><br>
<h6> Disabling the default constructor</h6>
<br><br>
<p>Functions that are declared as  cannot be called.
</p>
<br><br>
<p>Sometimes there are no sensible default values for the members of a type. For example, it may be illegal for the following type to have an empty file name:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> Archive {
    string fileName;
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Unfortunately, the compiler-generated default constructor would initialize  as empty:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">auto</span> archive = Archive();    <span class="comment">// ← fileName member is empty
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The default constructor can explicitly be disabled by declaring it as  so that objects must be constructed by one of the other constructors. There is no need to provide a body for a disabled function:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> Archive {
    string fileName;

                 

    <span class="keyword">this</span>(string fileName) {      
        <span class="comment">// ...
</span>    }
}

<span class="comment">// ...
</span>
    <span class="keyword">auto</span> archive = Archive();    
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>This time the compiler does not allow calling :
</p>
<br><br>

<br><br>
<p>Objects of  must be constructed either with one of the other constructors or explicitly with its  value:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">auto</span> a = Archive(<span class="string_literal">"records"</span>);    
    <span class="keyword">auto</span> b = Archive.init;          
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<h5>  Destructor</h5>
<br><br>
<p>The destructor includes the operations that must be executed when the lifetime of an object ends.
</p>
<br><br>
<p>The compiler-generated automatic destructor executes the destructors of all of the members in order. For that reason, as it is with the constructor, there is no need to define a destructor for most structs.
</p>
<br><br>
<p>However, sometimes some special operations may need to be executed when an object's lifetime ends. For example, an operating system resource that the object owns may need to be returned to the system; a member function of another object may need to be called; a server running somewhere on the network may need to be notified that a connection to it is about to be terminated; etc.
</p>
<br><br>
<p>The name of the destructor is  and just like constructors, it has no return type.
</p>
<br><br>
<h6>Destructor is executed automatically</h6>
<br><br>
<p>The destructor is executed as soon as the lifetime of the struct object ends. (This is not the case for objects that are constructed with the  keyword.)
</p>
<br><br>
<p>As we have seen in the <a href="lifetimes.html">Lifetimes and Fundamental Operations chapter,</a> the lifetime of an object ends when leaving the scope that it is defined in. The following are times when the lifetime of a struct ends:
</p>
<br><br>
<ul><li>When leaving the scope of the object either normally or due to a thrown exception:
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">if</span> (aCondition) {
        <span class="keyword">auto</span> duration = Duration(7);
        <span class="comment">// ...
</span>
    } <span class="comment">// ← The destructor is executed for 'duration'
</span>      <span class="comment">//   at this point
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
</li>
<br><br>
<li>Anonymous objects are destroyed at the end of the whole expression that they are constructed in:
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    time.increment(Duration(5)); <span class="comment">// ← The Duration(5) object
</span>                                 <span class="comment">//   gets destroyed at the end
</span>                                 <span class="comment">//   of the whole expression.
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
</li>
<br><br>
<li>All of the struct members of a struct object get destroyed when the outer object is destroyed.
<br><br>
</li>
<br><br>
</ul>
<br><br>
<h6>Destructor example</h6>
<br><br>
<p>Let's design a type for generating simple XML documents. XML elements are defined by angle brackets. They contain data and other XML elements. XML elements can have attributes as well; we will ignore them here.
</p>
<br><br>
<p>Our aim will be to ensure that an element that has been <i>opened</i> by a  tag will always be <i>closed</i> by a matching  tag:
</p>
<br><br>

<br><br>
<p>A struct that can produce the output above can be designed by two members that store the tag for the XML element and the indentation to use when printing it:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> XmlElement {
    string name;
    string indentation;
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>If the responsibilities of opening and closing the XML element are given to the constructor and the destructor, respectively, the desired output can be produced by managing the lifetimes of XmlElement objects. For example, the constructor can print  and the destructor can print .
</p>
<br><br>
<p>The following definition of the constructor produces the opening tag:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">this</span>(string name, <span class="keyword">int</span> level) {
        <span class="keyword">this</span>.name = name;
        <span class="keyword">this</span>.indentation = indentationString(level);

        writeln(indentation, '&lt;', name, '&gt;');
    }
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p> is the following function:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.array;
<span class="comment">// ...
</span>string indentationString(<span class="keyword">int</span> level) {
    <span class="keyword">return</span> replicate(<span class="string_literal">" "</span>, level * 2);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The function calls  from the  module, which makes and returns a new string made up of the specified value repeated the specified number of times.
</p>
<br><br>
<p>The destructor can be defined similar to the constructor to produce the closing tag:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    ~<span class="keyword">this</span>() {
        writeln(indentation, <span class="string_literal">"&lt;/"</span>, name, '&gt;');
    }
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Here is a test code to demonstrate the effects of the automatic constructor and destructor calls:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.conv;
<span class="keyword">import</span> std.random;
<span class="keyword">import</span> std.array;

string indentationString(<span class="keyword">int</span> level) {
    <span class="keyword">return</span> replicate(<span class="string_literal">" "</span>, level * 2);
}

<span class="keyword">struct</span> XmlElement {
    string name;
    string indentation;

    <span class="keyword">this</span>(string name, <span class="keyword">int</span> level) {
        <span class="keyword">this</span>.name = name;
        <span class="keyword">this</span>.indentation = indentationString(level);

        writeln(indentation, '&lt;', name, '&gt;');
    }

    ~<span class="keyword">this</span>() {
        writeln(indentation, <span class="string_literal">"&lt;/"</span>, name, '&gt;');
    }
}

<span class="keyword">void</span> main() {
    <span class="keyword">immutable</span> classes = XmlElement(<span class="string_literal">"classes"</span>, 0);

    <span class="keyword">foreach</span> (classId; 0 .. 2) {
        <span class="keyword">immutable</span> classTag = <span class="string_literal">"class"</span> ~ to!string(classId);
        <span class="keyword">immutable</span> classElement = XmlElement(classTag, 1);

        <span class="keyword">foreach</span> (i; 0 .. 3) {
            <span class="keyword">immutable</span> gradeElement = XmlElement(<span class="string_literal">"grade"</span>, 2);
            <span class="keyword">immutable</span> randomGrade = uniform(50, 101);

            writeln(indentationString(3), randomGrade);
        }
    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Note that the  objects are created in three separate scopes in the program above. The opening and closing tags of the XML elements in the output are produced solely by the constructor and the destructor of .
</p>
<br><br>

<br><br>
<p>The  element is produced by the  variable. Because that variable is constructed first in , the output contains the output of its construction first. Since it is also the variable that is destroyed last, upon leaving , the output contains the output of the destructor call for its destruction last.
</p>
<br><br>
<h5>  Postblit</h5>
<br><br>
<p><i>Copying</i> is constructing a new object from an existing one. Copying involves two steps:
</p>
<br><br>
<ol><br><br>
<li>Copying the members of the existing object to the new object bit-by-bit. This step is called <i>blit</i>, short for <i>block transfer</i>.
</li>
<br><br>
<li>Making further adjustments to the new object. This step is called <i>postblit</i>.
</li>
<br><br>
</ol>
<br><br>
<p>The first step is handled automatically by the compiler: It copies the members of the existing object to the members of the new object:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">auto</span> returnTripDuration = tripDuration;   <span class="comment">// copying
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Do not confuse copying with <i>assignment</i>. The  keyword above is an indication that a new object is being defined. (The actual type name could have been spelled out instead of .)
</p>
<br><br>
<p>For an operation to be assignment, the object on the left-hand side must be an existing object. For example, assuming that  has already been defined:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    returnTripDuration = tripDuration;  <span class="comment">// assignment (see below)
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Sometimes it is necessary to make adjustments to the members of the new object after the automatic blit. These operations are defined in the postblit function of the struct.
</p>
<br><br>
<p>Since it is about object construction, the name of the postblit is  as well. To separate it from the other constructors, its parameter list contains the keyword :
<br><br>
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">this</span>(<span class="keyword">this</span>) {
        <span class="comment">// ...
</span>    }
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>We have defined a  type in the <a href="struct.html">Structs chapter</a>, which had a problem about copying objects of that type:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> Student {
    <span class="keyword">int</span> number;
    <span class="keyword">int</span>[] grades;
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Being a slice, the  member of that  is a reference type. The consequence of copying a  object is that the  members of both the original and the copy provide access to the same actual array elements of type . As a result, the effect of modifying a grade through one of these objects is seen through the other object as well:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">auto</span> student1 = Student(1, [ 70, 90, 85 ]);

    <span class="keyword">auto</span> student2 = student1;    <span class="comment">// copying
</span>    student2.number = 2;

    student1.grades[0] += 5; <span class="comment">// this changes the grade of the
</span>                             <span class="comment">// second student as well:
</span>    <span class="keyword">assert</span>(.grades[0] == );
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>To avoid such a confusion, the elements of the  member of the second object must be separate and belong only to that object. Such <i>adjustments</i> are done in the postblit:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> Student {
    <span class="keyword">int</span> number;
    <span class="keyword">int</span>[] grades;

    <span class="keyword">this</span>(<span class="keyword">this</span>) {
        grades = grades.dup;
    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Remember that all of the members have already been copied automatically before  started executing. The single line in the postblit above makes a copy of the <i>elements</i> of the original array and assigns a slice of it back to . As a result, the new object gets its own copy of the grades.
</p>
<br><br>
<p>Making modifications through the first object does not affect the second object anymore:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    student1.grades[0] += 5;
    <span class="keyword">assert</span>(.grades[0] == );
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<h6> Disabling postblit</h6>
<br><br>
<p>The postblit function can be disabled by  as well. Objects of such a type cannot be copied:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> Archive {
<span class="comment">// ...
</span>
    
}

<span class="comment">// ...
</span>
    <span class="keyword">auto</span> a = Archive(<span class="string_literal">"records"</span>);
    <span class="keyword">auto</span> b = a;                     
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The compiler does not allow calling the disabled postblit function:
</p>
<br><br>

<br><br>
<h5>   Assignment operator</h5>
<br><br>
<p>Assigment is giving a new value to an existing object:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    returnTripDuration = tripDuration;  <span class="comment">// assignment
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Assignment is more complicated from the other special operations because it is actually a combination of two operations:
</p>
<br><br>
<ul><li>Destroying the left-hand side object</li>
<li>Copying the right-hand side object to the left-hand side object</li>
</ul>
<br><br>
<p>However, applying those two steps in that order is risky because the original object would be destroyed before knowing that copying will succeed. Otherwise, an exception that is thrown during the copy operation can leave the left-hand side object in an inconsistent state: fully destroyed but not completely copied.
</p>
<br><br>
<p>For that reason, the compiler-generated assignment operator acts safely by applying the following steps:
</p>
<br><br>
<ol><br><br>
<li>Copy the right-hand side object to a temporary object
<br><br>
<p>This is the actual copying half of the assignment operation. Since there is no change to the left-hand side object yet, it will remain intact if an exception is thrown during this copy operation.
</p>
<br><br>
</li>
<br><br>
<li>Destroy the left-hand side object
<br><br>
<p>This is the other half of the assignment operation.
</p>
<br><br>
</li>
<br><br>
<li>Transfer the temporary object to the left-hand side object
<br><br>
<p>No postblit nor a destructor is executed during or after this step. As a result, the left-hand side object becomes the equivalent of the temporary object.
</p>
<br><br>
</li>
<br><br>
</ol>
<br><br>
<p>After the steps above, the temporary object disappears and only the right-hand side object and its copy (i.e. the left-hand side object) remain.
</p>
<br><br>
<p>Although the compiler-generated assignment operator is suitable in most cases, it can be defined by the programmer. When you do that, consider potential exceptions and write the assignment operator in a way that works even at the presence of thrown exceptions.
</p>
<br><br>
<p>The syntax of the assignment operator is the following:
</p>
<br><br>
<ul><li>The name of the function is .</li>
<li>The type of the parameter is the same as the  type. This parameter is often named as , short for <i>right-hand side</i>.</li>
<li>The return type is the same as the  type.</li>
<li>The function is exited by .</li>
</ul>
<br><br>
<p>As an example, let's consider a simple  struct where the assignment operator prints a message:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> Duration {
    <span class="keyword">int</span> minute;

     opAssign( rhs) {
        writefln(<span class="string_literal">"minute is being changed from %s to %s"</span>,
                 <span class="keyword">this</span>.minute, rhs.minute);

        <span class="keyword">this</span>.minute = rhs.minute;

        
    }
}
<span class="comment">// ...
</span>    <span class="keyword">auto</span> duration = Duration(100);
    duration = Duration(200);          <span class="comment">// assignment
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The output:
</p>
<br><br>

<br><br>
<h6>Assigning from other types</h6>
<br><br>
<p>Sometimes it is convenient to assign values of types that are different from the type of the . For example, instead of requiring a  object on the right-hand side, it may be useful to assign from an integer:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    duration = 300;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>This is possible by defining another assignment operator that takes an  parameter:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> Duration {
    <span class="keyword">int</span> minute;

    Duration opAssign(Duration rhs) {
        writefln(<span class="string_literal">"minute is being changed from %s to %s"</span>,
                 <span class="keyword">this</span>.minute, rhs.minute);

        <span class="keyword">this</span>.minute = rhs.minute;

        <span class="keyword">return</span> <span class="keyword">this</span>;
    }

    Duration opAssign() {
        writefln(<span class="string_literal">"minute is being replaced by an int"</span>);

        <span class="keyword">this</span>.minute = minute;

        <span class="keyword">return</span> <span class="keyword">this</span>;
    }
}
<span class="comment">// ...
</span>    duration = Duration(200);
    duration = ;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The output:
</p>
<br><br>

<br><br>
<p><b>Note:</b> Although convenient, assigning different types to each other may cause confusions and errors.
</p>
<br><br>
<h5>Summary</h5>
<br><br>
<ul><br><br>
<li>Constructor () is for preparing objects for use. The compiler-generated default constructor is sufficient in most cases.</li>
<br><br>
<li>The behavior of the default constructor may not be changed in structs;  can be used instead.</li>
<br><br>
<li>Single-parameter constructors can be used during type conversions by  and .</li>
<br><br>
<li>Destructor () is for the operations that must be executed when the lifetimes of objects end.</li>
<br><br>
<li>Postblit () is for adjustments to the object after the automatic member copies.</li>
<br><br>
<li>Assigment operator () is for changing values of existing objects.</li>
<br><br>
</ul>

</section>
      </article>
    </div>
  </body>
</html>
