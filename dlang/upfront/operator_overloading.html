
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Operator Overloading</title>
    <style type="text/css" media="screen">
      html, body, div, span, object, iframe, h1, h2, h3, h4, h5, h6, p,
      blockquote, pre, a, abbr, address, cite, code, del, dfn, em, figure,
      img, ins, kbd, q, s, samp, small, strong, sub, sup, var, b, u, i, dl,
      dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption,
      tbody, tfoot, thead, tr, th, td {
        background: transparent none repeat scroll 0 0;
        border: 0 none;
        font-size: 100%;
        margin: 0;
        outline: 0 none;
        padding: 0;
        vertical-align: baseline;
      }

      h1 { font-size: 200%; }
      h2 { font-size: 160%; }
      h3 { font-size: 120%; }
      h4 { font-size: 100%; }
      h5 { font-size: 80%; }
      h6 { font-size: 80%; font-weight: normal; }

      ul, ol {
        margin: 1.4em 0;
      }
      ul ul, ol ol, ul ol, ol ul {
        margin-top: 0;
        margin-bottom: 0;
      }
      ul, ol {
        margin-left: 2.8em;
      }

      ol {
        list-style: decimal;
      }
      ol ol {
        list-style: lower-alpha;
      }
      ol ol ol {
        list-style: lower-roman;
      }
      ol ol ol ol {
        list-style: decimal;
      }

      blockquote {
        margin: 0.1em;
        margin-left: 1em;
        border-left: 2px solid #cccccc;
        padding-left: 0.7em;
      }

      .color_red { color: #dc322f; }
      .color_blue { color: #268bd2; }
      .color_green { color: #859901; }
      .color_yellow { color: #b58901; }
      .color_black { color: black; }
      .color_white { color: white; }

      .font_big {
        font-size: 1.2em;
      }

      .ddoc_section_h {
        font-weight: bold;
        font-size: 13px;
        line-height: 19.5px;
        margin-top: 11px;
        display: block;
      }

      body.dlang .dlang {
        display: inline-block;
      }

      body.dlang .declaration .dlang {
          display: block;
      }

      body.dlang .ddoc_header_anchor a.dlang {
        display: block;
        color: rgba(0, 136, 204, 1);
        text-decoration: none;
      }

      body.dlang .ddoc_header_anchor .code {
        color: rgba(0, 136, 204, 1);
      }

      #ddoc_main .module {
          border-color: currentColor rgba(233, 233, 233, 1) rgba(233, 233, 233, 1);
          border-style: none solid solid;
          border-width: 0 1px 1px;
          overflow-x: hidden;
          padding: 15px;
      }

      #ddoc_main .section .section {
        margin-top: 0;
      }

      #ddoc_main .ddoc_module_members_section {
          padding: 1px 0 0;
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .ddoc_member, #ddoc_main .ddoc_module_members section.intro {
          background: #fff none repeat scroll 0 0;
          list-style-type: none;
          width: 100%;
      }

      #ddoc_main .ddoc_header_anchor {
          font-size: 1.4em;
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .ddoc_header_anchor > .code {
          display: inline-block;

      }

      #ddoc_main .ddoc_decl {
        background-color: transparent;
        height: 100%;
        left: 0;
        top: 0;
        padding: 0;
        padding-left: 15px;
      }

      #ddoc_main .ddoc_decl .section, #ddoc_main .section.ddoc_sections {
        background: white none repeat scroll 0 0;
        margin: 0;
        padding: 5px;
        position: relative;
        border-radius: 5px;
      }

      #ddoc_main .ddoc_decl .section h4:first-of-type, #ddoc_main .section.ddoc_sections h4:first-of-type {
        font-size: 13px;
        line-height: 1.5;
        margin-top: 21px;
      }

      #ddoc_main .section .declaration {
          margin-top: 21px;
      }

      #ddoc_main .section .declaration .code {
          color: rgba(0, 0, 0, 1);
          margin-bottom: 15px;
          padding-bottom: 6px;
      }

      #ddoc_main .declaration div .para {
          margin-bottom: 0;
      }

      #ddoc_main .ddoc_params .graybox tr td:first-of-type {
        padding: 7px;
        text-align: right;
        vertical-align: top;
        word-break: normal;
        white-space: nowrap;
      }

      #ddoc_main .ddoc_params .graybox {
        border: 0 none;
      }

      #ddoc_main .ddoc_params .graybox td {
        border-color: rgba(214, 214, 214, 1);
      }

      #ddoc_main .ddoc_params .graybox tr:first-child > td {
        border-top: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr:last-child > td {
        border-bottom: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr > td:first-child {
        border-left: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr > td:last-child {
        border-right: 0 none;
        width: 100%;
      }

      #ddoc_main em.term, #ddoc_main em.term .code {
        color: rgba(65, 65, 65, 1);
        font-size: 12px;
        font-style: italic;
        line-height: 1.5;
      }

      #ddoc_main .see-also {
        cursor: pointer;
        font-family: Menlo,monospace;
      }

      #ddoc_main .ddoc_decl .section > div:last-of-type {
        margin-bottom: 15px;
      }

      #ddoc_main .ddoc_member, #ddoc_main .ddoc_module_members {
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .code_sample {
        background: inherit;
      }

      #ddoc_main .declaration .code-line {
          display: block;
          font: 1em Menlo,monospace;
      }

      #ddoc_main a[name] {
        margin: -112px 0 0;
        padding-top: 112px;
      }

      #ddoc_main .ddoc_decl td {
        max-width: inherit;
      }

      #ddoc_main .declaration a {
        color: inherit;
      }

      #ddoc_main .declaration a:hover {
          color: rgba(0, 136, 204, 1);
          text-decoration: underline;
      }

      body.ddoc {
        background-color: transparent;
        color: rgba(0, 0, 0, 1);
        font-family: Helvetica,Arial,sans-serif;
        font-size: 62.5%;
        margin: 0;
        border: 0;
        left: 0;
        top: 0;
        padding: 0;
      }

      .ddoc a[name] {
        display: block;
        height: 0;
        margin: -85px 0 0;
        padding-top: 85px;
        width: 0;
      }

      .ddoc .module {
          border-color: transparent;
          background-color: rgba(255, 255, 255, 1);
          border-color: currentColor rgba(233, 233, 233, 1) rgba(233, 233, 233, 1);
          border-image: none;
          border-style: none solid solid;
          border-width: 0 1px 1px;
          box-shadow: 0 0 1px rgba(0, 0, 0, 0.07);
          display: block;
          margin-left: 0;
          min-height: calc(100% - 173px);
          overflow: auto;
          padding-bottom: 100px;
      }

      .ddoc .content_wrapper {
          background-color: rgba(242, 242, 242, 1);
          margin: 0 auto;
          max-width: 980px;
      }

      .ddoc .section {
        padding: 15px 25px 30px;
      }

      .ddoc .section .section {
        margin: 30px 0 0;
        padding: 0;
      }

      .ddoc .para {
        color: rgba(65, 65, 65, 1);
        font-size: 1.4em;
        line-height: 145%;
        margin-bottom: 15px;
      }

      .ddoc .ddoc_examples .para {
        margin-bottom: 0;
      }

      .ddoc .module_name {
          color: rgba(0, 0, 0, 1);
          display: block;
          font-family: Helvetica;
          font-size: 2.8em;
          font-weight: 100;
          margin-bottom: 0;
          padding: 15px 0;
      }

      .ddoc .module a {
          color: rgba(0, 136, 204, 1);
          text-decoration: none;
      }

      .ddoc .code {
        color: rgba(128, 128, 128, 1);
        font-family: Menlo,monospace;
        font-size: 0.85em;
        word-wrap: break-word;
      }

      .ddoc .code i {
        font-style: normal;
      }

      .ddoc .code .code {
        font-size: 1em;
      }

      .ddoc .code_sample {
        background-clip: padding-box;
        margin: 1px 0;
        text-align: left;
      }

      .ddoc .code_sample {
        display: block;
        font-size: 1.4em;
        margin-left: 21px;
      }

      .ddoc ol .code_sample {
        font-size: 1em;
      }

      .ddoc .code_lines {
        counter-reset: li;
        line-height: 1.6em;
        list-style: outside none none;
        margin: 0;
        padding: 0;
      }

      .ddoc .code_listing .code_sample div {
        margin-left: 13px;
        width: 93%;
      }

      .ddoc .code_listing .code_sample div .code_lines li {
        list-style-type: none;
        margin: 0;
        padding-right: 10px;
      }

      .ddoc .code_sample div .code_lines li::before {
        margin-left: -33px;
        margin-right: 25px;
      }

      .ddoc .code_sample div .code_lines li:nth-child(n+10)::before {
        margin-left: -39px;
        margin-right: 25px;
      }

      .ddoc .code_sample div .code_lines li:nth-child(n+100)::before {
        margin-left: -46px;
        margin-right: 25px;
      }

      .ddoc .code_sample .code_lines .code {
        color: #000;
      }

      .ddoc div.dlang {
        margin: 10px 0 21px;
        padding: 4px 0 2px 10px;
      }

      .ddoc div.dlang {
          margin: 10px 0 21px;
          padding: 4px 0 2px 10px;
      }

      .ddoc div.dlang {
        border-left: 5px solid rgba(0, 155, 51, 0.2);
      }

      .ddoc .code_lines li::before {
        color: rgba(128, 128, 128, 1);
        content: counter(li, decimal);
        counter-increment: li;
        font-family: Menlo,monospace;
        font-size: 0.9em;
        margin-right: 16px;
      }

      .ddoc .code_lines li {
        padding-left: 0;
        white-space: pre-wrap;
      }

      .ddoc .code_lines li:only-of-type::before {
        color: rgba(255, 255, 255, 1);
        content: " ";
      }

      .ddoc .code_lines li:only-of-type {
        color: rgba(255, 255, 255, 1);
        content: " ";
      }

      .ddoc .code_lines li:nth-child(n+10) {
        text-indent: -17px;
      }

      .ddoc .code_lines li:nth-child(n+10)::before {
        margin-right: 12px;
      }

      .ddoc .graybox {
        border: 1px solid rgba(233, 233, 233, 1);
        border-collapse: collapse;
        border-spacing: 0;
        empty-cells: hide;
        margin: 20px 0 36px;
        text-align: left;
      }

      .ddoc .graybox p {
        margin: 0;
        min-width: 50px;
      }

      .ddoc th {
        margin: 0;
        max-width: 260px;
        padding: 5px 10px 5px 10px;
        vertical-align: bottom;
      }

      .ddoc td {
        border: 1px solid rgba(233, 233, 233, 1);
        margin: 0;
        max-width: 260px;
        padding: 5px 10px 5px 10px;
        vertical-align: middle;
      }

      .punctuation {
        color: rgba(0, 0, 0, 1);
      }

      .comment {
        color: rgba(0, 131, 18, 1);
      }

      .operator {
        color: #000;
      }

      .keyword {
        color: rgba(170, 13, 145, 1);
      }

      .keyword_type {
        color: rgba(170, 51, 145, 1);
      }

      .string_literal {
        color: rgba(196, 26, 22, 1);
      }

      .ddoc_psuper_symbol {
        color: rgba(92, 38, 153, 1);
      }

      .param {
        color: rgba(0, 0, 0, 1);
      }

      .psymbol {
        color: rgba(0, 0, 0, 1);
      }

      .ddoc_member_header .ddoc_header_anchor .code {
        font-size: 1em;
      }
    </style>
  </head>
  <body id="ddoc_main" class="ddoc dlang">
    <div class="content_wrapper">
      <article class="module">
        <h1 class="module_name">Operator Overloading</h1>
        <section id="module_content"><br><br>
<br><br>

<br><br>
<p>The topics covered in this chapter apply mostly for classes as well. The biggest difference is that the behavior of assignment operation  cannot be overloaded for classes.
</p>
<br><br>
<p>Operator overloading involves many concepts, some of which will be covered later in the book (templates, , etc.). For that reason, you may find this chapter to be harder to follow than the previous ones.
</p>
<br><br>
<p>Operator overloading enables defining how user-defined types behave when used with operators. In this context, the term <i>overload</i> means providing the definition of an operator for a specific type.
</p>
<br><br>
<p>We have seen how to define structs and their member functions in previous chapters. As an example, we have defined the  member function to be able to add  objects to  objects. Here are the two structs from previous chapters, with only the parts that are relevant to this chapter:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> Duration {
    <span class="keyword">int</span> minute;
}

<span class="keyword">struct</span> TimeOfDay {
    <span class="keyword">int</span> hour;
    <span class="keyword">int</span> minute;

    <span class="keyword">void</span> (Duration duration) {
        minute += duration.minute;

        hour += minute / 60;
        minute %= 60;
        hour %= 24;
    }
}

<span class="keyword">void</span> main() {
    <span class="keyword">auto</span> lunchTime = TimeOfDay(12, 0);
    lunchTime(Duration(10));
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>A benefit of member functions is being able to define operations of a type alongside the member variables of that type.
</p>
<br><br>
<p>Despite their advantages, member functions can be seen as being limited compared to operations on fundamental types. After all, fundamental types can readily be used with operators:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span> weight = 50;
    weight  10;                       <span class="comment">// by an operator
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>According to what we have seen so far, similar operations can only be achieved by member functions for user-defined types:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">auto</span> lunchTime = TimeOfDay(12, 0);
    lunchTime(Duration(10));  <span class="comment">// by a member function
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Operator overloading enables using structs and classes with operators as well. For example, assuming that the  operator is defined for , the operation above can be written in exactly the same way as with fundamental types:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    lunchTime  Duration(10);          <span class="comment">// by an operator
</span>                                        <span class="comment">// (even for a struct)
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Before getting to the details of operator overloading, let's first see how the line above would be enabled for . What is needed is to redefine the  member function under the special name  and also to specify that this definition is for the  character. As it will be explained below, this definition actually corresponds to the  operator.
</p>
<br><br>
<p>The definition of this member function does not look like the ones that we have seen so far. That is because  is actually a <i>function template</i>. Since we will see templates in much later chapters, I will have to ask you to accept the operator overloading syntax as is for now:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> TimeOfDay {
<span class="comment">// ...
</span>    <span class="keyword">ref</span> TimeOfDay opOpAssign(string op)(Duration duration) <span class="comment">// (1)
</span>            <span class="keyword">if</span> (op == <span class="string_literal">"+"</span>) {                               <span class="comment">// (2)
</span>
        minute += duration.minute;
        hour += minute / 60;
        minute %= 60;
        hour %= 24;

        <span class="keyword">return</span> <span class="keyword">this</span>;
    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The template definition consists of two parts:
</p>
<br><br>
<ol><br><br>
<li>: This part must be written as is and should be accepted as the <i>name</i> of the function. We will see below that there are other member functions in addition to .
</li>
<br><br>
<li>:  is used for more than one operator overload.  specifies that this is the operator overload that corresponds to the  character. This syntax is a <i>template constraint</i>, which will also be covered in later chapters.
</li>
<br><br>
</ol>
<br><br>
<p>Also note that this time the return type is different from the return type of the  member function: It is not  anymore. We will discuss the return types of operators later below.
</p>
<br><br>
<p>Behind the scenes, the compiler replaces the uses of the  operator with calls to the  member function:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    lunchTime += Duration(10);

    <span class="comment">// The following line is the equivalent of the previous one
</span>    lunchTime.opOpAssign!<span class="string_literal">"+"</span>(Duration(10));
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The  part that is after  specifies that this call is for the definition of the operator for the  character. We will cover this template syntax in later chapters as well.
</p>
<br><br>
<p>Note that the operator definition that corresponds to  is defined by , not by . The  in the name of  already implies that this name is for an assignment operator.
</p>
<br><br>
<p>Being able to define the behaviors of operators brings a responsibility: The programmer must observe expectations. As an extreme example, the previous operator could have been defined to decrement the time value instead of incrementing it. However, people who read the code would still expect the value to be incremented by the  operator.
</p>
<br><br>
<p>To some extent, the return types of operators can also be chosen freely. Still, general expectations must be observed for the return types as well.
</p>
<br><br>
<p>Keep in mind that operators that behave unnaturally would cause confusion and bugs.
</p>
<br><br>
<h5>Overloadable operators</h5>
<br><br>
<p>There are different kinds of operators that can be overloaded.
</p>
<br><br>
<h6>   Unary operators</h6>
<br><br>
<p>An operator that takes a single operand is called a unary operator:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    ++weight;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p> is a unary operator because it works on a single variable.
</p>
<br><br>
<p>Unary operators are defined by member functions named .  does not take any parameters because it uses only the object that the operator is being executed on.
</p>
<br><br>
<p>





The overloadable unary operators and the corresponding operator strings are the following:
</p>
<br><br>
<table>full,







</table>
<br><br>
<p>For example, the  operator for  can be defined like this:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> Duration {
    <span class="keyword">int</span> minute;

    <span class="keyword">ref</span> Duration opUnary(string op)()
            <span class="keyword">if</span> (op == <span class="string_literal">"++"</span>) {
        ++minute;
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Note that the return type of the operator is marked as  here as well. This will be explained later below.
</p>
<br><br>
<p> objects can now be incremented by :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">auto</span> duration = Duration(20);
    ++duration;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>  The post-increment and post-decrement operators cannot be overloaded. The  and  uses are handled by the compiler automatically by saving the previous value of the object. For example, the compiler applies the equivalent of the following code for post-increment:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="comment">/* The previous value is copied by the compiler
     * automatically: */</span>
    Duration __previousValue__ = duration;

    <span class="comment">/* The ++ operator is called: */</span>
    ++duration;

    <span class="comment">/* Then __previousValue__ is used as the value of the
     * post-increment operation. */</span>
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Unlike some other languages, the copy inside post-increment has no cost in D if the value of the post-increment expression is not actually used. This is because the compiler replaces such post-increment expressions with their pre-increment counterparts:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="comment">/* The value of the expression is not used below. The
     * only effect of the expression is incrementing 'i'. */</span>
    i++;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Because the <i>previous value</i> of  is not actually used above, the compiler replaces the expression with the following one:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="comment">/* The expression that is actually used by the compiler: */</span>
    ++i;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Additionally, if an  overload supports the  usage, then  need not be overloaded for  and . Instead, the compiler uses the  expression behind the scenes. Similarly, the  overload covers the uses of  and  as well.
</p>
<br><br>
<h6>  Binary operators</h6>
<br><br>
<p>An operator that takes two operands is called a binary operator:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    totalWeight  boxWeight  chocolateWeight;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The line above has two separate binary operators: the  operator, which adds the values of the two operands that are on its two sides, and the  operator that assigns the value of its right-hand operand to its left-hand operand.
</p>
<br><br>
<p>





































The rightmost column below describes the category of each operator. The ones marked as "=" assign to the left-hand side object.
</p>
<br><br>
<table>full,



































</table>
<br><br>
<p> is for when the object can appear on the right-hand side of the operator. Let's assume a binary operator that we shall call <i>op</i> appears in the program:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    x <i>op</i> y
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>In order to determine what member function to call, the compiler considers the following two options:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="comment">// the definition for x being on the left:
</span>    x.opBinary!<span class="string_literal">"op"</span>(y);

    <span class="comment">// the definition for y being on the right:
</span>    y.opBinaryRight!<span class="string_literal">"op"</span>(x);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The compiler picks the option that is a better match than the other.
</p>
<br><br>
<p> is useful when defining arithmetic types that would normally work on both sides of an operator like e.g.  does:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">auto</span> x = MyInt(42);
    x + 1;    <span class="comment">// calls opBinary!"+"
</span>    1 + x;    <span class="comment">// calls opBinaryRight!"+"
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Another common use of  is the  operator. It usually makes more sense to define  for the object that appears on the right-hand side of . We will see an example of this below.
</p>
<br><br>
<p>The parameter name  that appears in the following definitions is short for <i>right-hand side</i>. It denotes the operand that appears on the right-hand side of the operator:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    x <i>op</i> y
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>For the expression above, the  parameter would represent the variable .
</p>
<br><br>
<h5>Element indexing and slicing operators</h5>
<br><br>
<p>The following operators enable using a type as a collection of elements:
</p>
<br><br>
<table>full,








</table>
<br><br>
<p>We will cover those operators later below.
</p>
<br><br>
<p>The following operator functions are from the earlier versions of D. They are discouraged:
</p>
<br><br>
<table>full,







<br><br>
</table>
<br><br>
<h6>Other operators</h6>
<br><br>
<p>The following operators can be overloaded as well:
</p>
<br><br>
<table>full,




</table>
<br><br>
<p>These operators will be explained below under their own sections.
</p>
<br><br>
<h5>Defining more than one operator at the same time</h5>
<br><br>
<p>To keep the code samples short, we have used only the , , and  operators above. It is conceivable that when one operator is overloaded for a type, many others would also need to be overloaded. For example, the  and  operators are also defined for the following :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> Duration {
    <span class="keyword">int</span> minute;

    <span class="keyword">ref</span> Duration opUnary(string op)()
            <span class="keyword">if</span> (op == <span class="string_literal">"++"</span>) {
        minute;
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }

    <span class="keyword">ref</span> Duration opUnary(string op)()
            <span class="keyword">if</span> (op == <span class="string_literal">"--"</span>) {
        minute;
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }

    <span class="keyword">ref</span> Duration opOpAssign(string op)(<span class="keyword">int</span> amount)
            <span class="keyword">if</span> (op == <span class="string_literal">"+"</span>) {
        minute = amount;
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }

    <span class="keyword">ref</span> Duration opOpAssign(string op)(<span class="keyword">int</span> amount)
            <span class="keyword">if</span> (op == <span class="string_literal">"-"</span>) {
        minute = amount;
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }
}

<span class="keyword">unittest</span> {
    <span class="keyword">auto</span> duration = Duration(10);

    ++duration;
    <span class="keyword">assert</span>(duration.minute == 11);

    --duration;
    <span class="keyword">assert</span>(duration.minute == 10);

    duration += 5;
    <span class="keyword">assert</span>(duration.minute == 15);

    duration -= 3;
    <span class="keyword">assert</span>(duration.minute == 12);
}

<span class="keyword">void</span> main() {
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The operator overloads above have code duplications. The only differences between the similar functions are highlighted. Such code duplications can be reduced and sometimes avoided altogether by <i>string mixins</i>. We will see the  keyword in a later chapter as well. I would like to show briefly how this keyword helps with operator overloading.
</p>
<br><br>
<p> inserts the specified string as source code right where the  statement appears in code. The following struct is the equivalent of the one above:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> Duration {
    <span class="keyword">int</span> minute;

    <span class="keyword">ref</span> Duration opUnary(string op)()
            <span class="keyword">if</span> ((op == <span class="string_literal">"++"</span>) || (op == <span class="string_literal">"--"</span>)) {
         (op ~ <span class="string_literal">"minute;"</span>);
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }

    <span class="keyword">ref</span> Duration opOpAssign(string op)(<span class="keyword">int</span> amount)
            <span class="keyword">if</span> ((op == <span class="string_literal">"+"</span>) || (op == <span class="string_literal">"-"</span>)) {
         (<span class="string_literal">"minute "</span> ~ op ~ <span class="string_literal">"= amount;"</span>);
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>If the  objects also need to be multiplied and divided by an amount, all that is needed is to add two more conditions to the template constraint:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> Duration {
<span class="comment">// ...
</span>
    <span class="keyword">ref</span> Duration opOpAssign(string op)(<span class="keyword">int</span> amount)
        <span class="keyword">if</span> ((op == <span class="string_literal">"+"</span>) || (op == <span class="string_literal">"-"</span>) ||
            ) {
        <span class="keyword">mixin</span> (<span class="string_literal">"minute "</span> ~ op ~ <span class="string_literal">"= amount;"</span>);
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }
}

<span class="keyword">unittest</span> {
    <span class="keyword">auto</span> duration = Duration(12);

    duration  4;
    <span class="keyword">assert</span>(duration.minute == 48);

    duration  2;
    <span class="keyword">assert</span>(duration.minute == 24);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>In fact, the template constraints are optional:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">ref</span> Duration opOpAssign(string op)(<span class="keyword">int</span> amount)
            <span class="comment">/* no constraint */</span> {
        <span class="keyword">mixin</span> (<span class="string_literal">"minute "</span> ~ op ~ <span class="string_literal">"= amount;"</span>);
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<h5> Return types of operators</h5>
<br><br>
<p>When overloading an operator, it is advisable to observe the return type of the same operator on fundamental types. This would help with making sense of code and reducing confusions.
</p>
<br><br>
<p>None of the operators on fundamental types return . This fact should be obvious for some operators. For example, the result of adding two  values as  is :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span> a = 1;
    <span class="keyword">int</span> b = 2;
    <span class="keyword">int</span> c = a + b;  <span class="comment">// c gets initialized by the return value
</span>                    <span class="comment">// of the + operator
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The return values of some other operators may not be so obvious. For example, even operators like  have values:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span> i = 1;
    writeln(++i);    <span class="comment">// prints 2
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The  operator not only increments , it also produces the new value of . Further, the value that is produced by  is not just the new value of , rather <i>the variable  itself</i>. We can see this fact by printing the address of the result of that expression:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span> i = 1;
    writeln(<span class="string_literal">"The address of i                : "</span>, &amp;i);
    writeln(<span class="string_literal">"The address of the result of ++i: "</span>, &amp;(++i));
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The output contains identical addresses:
</p>
<br><br>

<br><br>
<p>I recommend that you observe the following guidelines when overloading operators for your own types:
</p>
<br><br>
<ul><br><br>
<li><b>Operators that modify the object</b>
<br><br>
<p>With the exception of , it is recommended that the operators that modify the object return the object itself. This guideline has been observed above with the  and .
</p>
<br><br>
<p>The following two steps achieve returning the object itself:
</p>
<br><br>
<ol><br><br>
<li>The return type is the type of the struct, marked by the  keyword to mean <i>reference</i>.
</li>
<br><br>
<li>The function is exited by  to mean <i>return this object</i>.
</li>
<br><br>
</ol>
<br><br>
<p>The operators that modify the object are , , and all of the  overloads.
</p>
<br><br>
</li>
<br><br>
<li><b>Logical operators</b>
<br><br>
<p> that represents both  and  must return . Although the  operator normally returns <i>the contained object</i>, it can simply return  as well.
</p>
<br><br>
</li>
<br><br>
<li><b>Sort operators</b>
<br><br>
<p> that represents , , , and  must return .
</p>
<br><br>
</li>
<br><br>
<li><b>Operators that make a new object</b>
<br><br>
<p>Some operators must make and return a new object:
</p>
<br><br>
<ul><br><br>
<li>Unary operators , , and ; and the binary operator .</li>
<br><br>
<li>Arithmetic operators , , , , , and .</li>
<br><br>
<li>Bitwise operators , , , , , and .</li>
<br><br>
<li>As has been seen in the previous chapter,  returns a copy of this object by .
<br><br>
<p><i><b>Note:</b> As an optimization, sometimes it makes more sense for  to return  for large structs. I will not apply this optimization in this book.</i></p>
<br><br>
</li>
<br><br>
</ul>
<br><br>
<p>As an example of an operator that makes a new object, let's define the  overload for . This operator should add two  objects to make and return a new one:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> Duration {
    <span class="keyword">int</span> minute;

    Duration opBinary(string op)(Duration rhs) <span class="keyword">const</span>
            <span class="keyword">if</span> (op == <span class="string_literal">"+"</span>) {
        <span class="keyword">return</span> Duration(minute + rhs.minute);  <span class="comment">// new object
</span>    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>That definition enables adding  objects by the  operator:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">auto</span> travelDuration = Duration(10);
    <span class="keyword">auto</span> returnDuration = Duration(11);
    Duration totalDuration;
    <span class="comment">// ...
</span>    totalDuration = travelDuration  returnDuration;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The compiler replaces that expression with the following member function call on the  object:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="comment">// the equivalent of the expression above:
</span>    totalDuration =
        travelDuration.opBinary!<span class="string_literal">"+"</span>(returnDuration);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
</li>
<br><br>
<li>
<br><br>
<p>Since it returns the number of elements of the container, the most suitable type for  is . However, the return type can be other types as well (e.g. ).
</p>
<br><br>
</li>
<br><br>
<li><b>Unconstrained operators</b>
<br><br>
<p>The return types of some of the operators depend entirely on the design of the user-defined type: The unary , , , , , and all  varieties.
</p>
<br><br>
</li>
<br><br>
</ul>
<br><br>
<h5>  for equality comparisons</h5>
<br><br>
<p>This member function defines the behaviors of the  and the  operators.
</p>
<br><br>
<p>The return type of  is .
</p>
<br><br>
<p>For structs, the parameter of  can be defined as . However, for speed efficiency  can be defined as a template that takes  (also note the empty template parentheses below):
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">bool</span> opEquals(<span class="keyword">auto</span> <span class="keyword">ref</span> <span class="keyword">const</span> TimeOfDay rhs) <span class="keyword">const</span> {
        <span class="comment">// ...
</span>    }
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>As we have seen in <a href="lvalue_rvalue.html">the Lvalues and Rvalues chapter</a>,  allows lvalues to be passed by reference and rvalues by copy. However, since rvalues are not copied, rather moved, the signature above is efficient for both lvalues and rvalues.
</p>
<br><br>
<p>To reduce confusion,  and  must work consistently. For two objects that  returns ,  must return zero.
</p>
<br><br>
<p>Once  is defined for equality, the compiler uses its opposite for inequality:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    x == y;
    <span class="comment">// the equivalent of the previous expression:
</span>    x.opEquals(y);

    x != y;
    <span class="comment">// the equivalent of the previous expression:
</span>    !(x.opEquals(y));
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Normally, it is not necessary to define  for structs. The compiler generates it for structs automatically. The automatically-generated  compares all of the members individually.
</p>
<br><br>
<p>Sometimes the equality of two objects must be defined differently from this automatic behavior. For example, some of the members may not be significant in this comparison, or the equality may depend on a more complex logic.
</p>
<br><br>
<p>Just as an example, let's define  in a way that disregards the minute information altogether:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> TimeOfDay {
    <span class="keyword">int</span> hour;
    <span class="keyword">int</span> minute;

    <span class="keyword">bool</span> opEquals(TimeOfDay rhs) <span class="keyword">const</span> {
        <span class="keyword">return</span> hour == rhs.hour;
    }
}
<span class="comment">// ...
</span>    <span class="keyword">assert</span>(TimeOfDay(20, 10)  TimeOfDay(20, 59));
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Since the equality comparison considers the values of only the  members, 20:10 and 20:59 end up being equal. (This is just an example; it should be clear that such an equality comparison would cause confusions.)
</p>
<br><br>
<h5>  for sorting</h5>
<br><br>
<p>Sort operators determine the sort orders of objects. All of the ordering operators , , , and  are covered by the  member function.
</p>
<br><br>
<p>For structs, the parameter of  can be defined as . However, as with , it is more efficient to define  as a template that takes :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span> opCmp(<span class="keyword">auto</span> <span class="keyword">ref</span> <span class="keyword">const</span> TimeOfDay rhs) <span class="keyword">const</span> {
        <span class="comment">// ...
</span>    }
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>To reduce confusion,  and  must work consistently. For two objects that  returns ,  must return zero.
</p>
<br><br>
<p>Let's assume that one of these four operators is used as in the following code:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">if</span> (x <i>op</i> y) {  
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The compiler converts that expression to the following logical expression and uses the result of the new logical expression:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">if</span> (x.opCmp(y) <i>op</i> 0) {
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Let's consider the  operator:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">if</span> (x  y) {
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The compiler generates the following code behind the scenes:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">if</span> (x.opCmp(y)  0) {
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>For the user-defined  to work correctly, this member function must return a result according to the following rules:
</p>
<br><br>
<ul><li><i>A negative value</i> if the left-hand object is considered to be before the right-hand object</li>
<li><i>A positive value</i> if the left-hand object is considered to be after the right-hand object</li>
<li><i>Zero</i> if the objects are considered to have the same sort order</li>
</ul>
<br><br>
<p>To be able to support those values, the return type of  must be , not .
</p>
<br><br>
<p>The following is a way of ordering  objects by first comparing the values of the  members, and then comparing the values of the  members (only if the  members are equal):
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span> opCmp(TimeOfDay rhs) <span class="keyword">const</span> {
        <span class="comment">/* Note: Subtraction is a bug here if the result can
         * overflow. (See the following warning in text.) */</span>

        <span class="keyword">return</span> (hour == rhs.hour
                ? minute - rhs.minute
                : hour - rhs.hour);
    }
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>That definition returns the difference between the  values when the  members are the same, and the difference between the  members otherwise. The return value would be a <i>negative value</i> when the <i>left-hand</i> object comes before in chronological order, a <i>positive value</i> if the <i>right-hand</i> object is before, and <i>zero</i> when they represent exactly the same time of day.
</p>
<br><br>
<p><b>Warning:</b> Using subtraction for the implementation of  is a bug if valid values of a member can cause overflow. For example, the two objects below would be sorted incorrectly as the object with value  is calculated to be <i>greater</i> than the one with value :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> S {
    <span class="keyword">int</span> i;

    <span class="keyword">int</span> opCmp(S rhs) <span class="keyword">const</span> {
        <span class="keyword">return</span> i - rhs.i;          
    }
}

<span class="keyword">void</span> main() {
    <span class="keyword">assert</span>(S(-2)  S(<span class="keyword">int</span>.max));    
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>On the other hand, subtraction is acceptable for  because none of the valid values of the members of that  can cause overflow in subtraction.
</p>
<br><br>
<p>  You can use  for comparing slices (including all string types and ranges).  compares slices lexicographically and produces a negative value, zero, or positive value depending on their  order. That result can directly be used as the return value of :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.algorithm;

<span class="keyword">struct</span> S {
    string name;

    <span class="keyword">int</span> opCmp(S rhs) <span class="keyword">const</span> {
        <span class="keyword">return</span> (name, rhs.name);
    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Once  is defined, this type can be used with sorting algorithms like  as well. As  works on the elements, it is the  operator that gets called behind the scenes to determine their order. The following program constructs 10 objects with random values and sorts them with :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.random;
<span class="keyword">import</span> std.stdio;
<span class="keyword">import</span> std.string;
<span class="keyword">import</span> std.algorithm;

<span class="keyword">struct</span> TimeOfDay {
    <span class="keyword">int</span> hour;
    <span class="keyword">int</span> minute;

    <span class="keyword">int</span> opCmp(TimeOfDay rhs) <span class="keyword">const</span> {
        <span class="keyword">return</span> (hour == rhs.hour
                ? minute - rhs.minute
                : hour - rhs.hour);
    }

    string toString() <span class="keyword">const</span> {
        <span class="keyword">return</span> format(<span class="string_literal">"%02s:%02s"</span>, hour, minute);
    }
}

<span class="keyword">void</span> main() {
    TimeOfDay[] times;

    <span class="keyword">foreach</span> (i; 0 .. 10) {
        times ~= TimeOfDay(uniform(0, 24), uniform(0, 60));
    }

    sort(times);

    writeln(times);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>As expected, the elements are sorted from the earliest time to the latest time:
</p>
<br><br>

<br><br>
<h5>   to call objects as functions</h5>
<br><br>
<p>The parentheses around the parameter list when calling functions are operators as well. We have already seen how  makes it possible to use the name of the <i>type</i> as a function.  allows creating objects with default values at run time.
</p>
<br><br>
<p>Non-static  on the other hand allows using the <i>objects</i> of user-defined types as functions:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    Foo foo;
    foo;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The object  above is being called like a function.
</p>
<br><br>
<p>As an example, let's consider a  that represents a linear equation. This  will be used for calculating the <i>y</i> values of the following linear equation for specific <i>x</i> values:
</p>
<br><br>

<br><br>
<p>The following  simply calculates and returns the value of <i>y</i> according to that equation:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> LinearEquation {
    <span class="keyword">double</span> a;
    <span class="keyword">double</span> b;

    <span class="keyword">double</span> opCall(<span class="keyword">double</span> x) <span class="keyword">const</span> {
        <span class="keyword">return</span> a * x + b;
    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>With that definition, each object of  represents a linear equation for specific <i>a</i> and <i>b</i> values. Such an object can be used as a function that calculates the <i>y</i> values:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    LinearEquation equation = { 1.2, 3.4 };
    <span class="comment">// the object is being used like a function:
</span>    <span class="keyword">double</span> y = equation(5.6);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p><i><b>Note:</b> Defining  for a  disables the compiler-generated automatic constructor. That is why the  syntax is used above instead of the recommended . When the latter syntax is desired, a  that takes two  parameters must also be defined.</i>
</p>
<br><br>
<p> above represents the <i>y&nbsp;=&nbsp;1.2x&nbsp;+&nbsp;3.4</i> linear equation. Using that object as a function executes the  member function.
</p>
<br><br>
<p>This feature can be useful to define and store the <i>a</i> and <i>b</i> values in an object once and to use that object multiple times later on. The following code uses such an object in a loop:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    LinearEquation equation = { 0.01, 0.4 };

    <span class="keyword">for</span> (<span class="keyword">double</span> x = 0.0; x &lt;= 1.0; x += 0.125) {
        writefln(<span class="string_literal">"%f: %f"</span>, x, equation(x));
    }
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>That object represents the <i>y&nbsp;=&nbsp;0.01x&nbsp;+&nbsp;0.4</i> equation. It is being used for calculating the results for <i>x</i> values in the range from 0.0 to 1.0.
</p>
<br><br>
<h5>     Indexing operators</h5>
<br><br>
<p>, , , , and  make it possible to use indexing operators on user-defined types similar to arrays as in .
</p>
<br><br>
<p>Unlike arrays, these operators support multi-dimensional indexing as well. Multiple index values are specified as a comma-separated list inside the square brackets (e.g. ). In the following examples we will use these operators only with a single dimension and cover their multi-dimensional uses in <a href="templates_more.html">the More Templates chapter</a>.
</p>
<br><br>
<p>The  variable in the following examples is an object of , which we will define below; and  is a variable of type .
</p>
<br><br>
<p> is for element access. The index that is specified inside the brackets becomes the parameter of the operator function:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    e = deque[3];                    <span class="comment">// the element at index 3
</span>    e = deque.opIndex(3);            <span class="comment">// the equivalent of the above
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p> is for assigning to an element. The first parameter is the value that is being assigned and the second parameter is the index of the element:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    deque[5] = 55;                   <span class="comment">// assign 55 to the element at index 5
</span>    deque.opIndexAssign(55, 5);      <span class="comment">// the equivalent of the above
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p> is similar to . The difference is that the operation is applied to the element at the specified index:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    ++deque[4];                      <span class="comment">// increment the element at index 4
</span>    deque.opIndexUnary!<span class="string_literal">"++"</span>(4);      <span class="comment">// the equivalent of the above
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p> is similar to . The difference is that the operation is applied to an element:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    deque[6] += 66;                  <span class="comment">// add 66 to the element at index 6
</span>    deque.opIndexOpAssign!<span class="string_literal">"+"</span>(66, 6);<span class="comment">// the equivalent of the above
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p> defines the  character that is used during indexing and slicing. It is for returning the number of elements in the container:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    e = deque[$ - 1];                <span class="comment">// the last element
</span>    e = deque[deque.opDollar() - 1]; <span class="comment">// the equivalent of the above
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<h6>Indexing operators example</h6>
<br><br>
<p><i>Double-ended queue</i> is a data structure that is similar to arrays but it provides efficient insertion at the head of the collection as well. (In contrast, inserting at the head of an array is a relatively slow operation as it requires moving the existing elements to a newly created array.)
</p>
<br><br>
<p>One way of implementing a double-ended queue is to use two arrays in the background but to use the first one in reverse. The element that is conceptually inserted at the head of the queue is actually appended to the <i>head</i> array. As a result, this operation is as efficient as appending to the end.
</p>
<br><br>
<p>The following  implements a double-ended queue that overloads the operators that we have seen in this section:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;
<span class="keyword">import</span> std.string;
<span class="keyword">import</span> std.conv;

<span class="keyword">struct</span> DoubleEndedQueue <span class="comment">// Also known as Deque
</span>{
<span class="keyword">private</span>:

    <span class="comment">/* The elements are represented as the chaining of the two
     * member slices. However, 'head' is indexed in reverse so
     * that the first element of the entire collection is
     * head[$-1], the second one is head[$-2], etc.:
     *
     * head[$-1], head[$-2], ... head[0], tail[0], ... tail[$-1]
     */</span>
    <span class="keyword">int</span>[] head;    <span class="comment">// the first group of elements
</span>    <span class="keyword">int</span>[] tail;    <span class="comment">// the second group of elements
</span>
    <span class="comment">/* Determines the actual slice that the specified element
     * resides in and returns it as a reference. */</span>
    <span class="keyword">ref</span> <span class="keyword">inout</span>(<span class="keyword">int</span>) elementAt(size_t index) <span class="keyword">inout</span> {
        <span class="keyword">return</span> (index &lt; head.length
                ? head[$ - 1 - index]
                : tail[index - head.length]);
    }

<span class="keyword">public</span>:

    string toString() <span class="keyword">const</span> {
        string result;

        <span class="keyword">foreach_reverse</span> (element; head) {
            result ~= format(<span class="string_literal">"%s "</span>, to!string(element));
        }

        <span class="keyword">foreach</span> (element; tail) {
            result ~= format(<span class="string_literal">"%s "</span>, to!string(element));
        }

        <span class="keyword">return</span> result;
    }

    <span class="comment">/* Note: As we will see in the next chapter, the following
     * is a simpler and more efficient implementation of
     * toString(): */</span>
    <span class="keyword">version</span> (none) {
        <span class="keyword">void</span> toString(<span class="keyword">void</span> <span class="keyword">delegate</span>(<span class="keyword">const</span>(<span class="keyword">char</span>)[]) sink) <span class="keyword">const</span> {
            <span class="keyword">import</span> std.format;
            <span class="keyword">import</span> std.range;

            formattedWrite(
                sink, <span class="string_literal">"%(%s %)"</span>, chain(head.retro, tail));
        }
    }

    <span class="comment">/* Adds a new element to the head of the collection. */</span>
    <span class="keyword">void</span> insertAtHead(<span class="keyword">int</span> value) {
        head ~= value;
    }

    <span class="comment">/* Adds a new element to the tail of the collection.
     *
     * Sample: deque ~= value
     */</span>
    <span class="keyword">ref</span> DoubleEndedQueue opOpAssign(string op)(<span class="keyword">int</span> value)
            <span class="keyword">if</span> (op == <span class="string_literal">"~"</span>) {
        tail ~= value;
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }

    <span class="comment">/* Returns the specified element.
     *
     * Sample: deque[index]
     */</span>
    <span class="keyword">inout</span>(<span class="keyword">int</span>) opIndex(size_t index) <span class="keyword">inout</span> {
        <span class="keyword">return</span> elementAt(index);
    }

    <span class="comment">/* Applies a unary operation to the specified element.
     *
     * Sample: ++deque[index]
     */</span>
    <span class="keyword">int</span> opIndexUnary(string op)(size_t index) {
        <span class="keyword">mixin</span> (<span class="string_literal">"return "</span> ~ op ~ <span class="string_literal">"elementAt(index);"</span>);
    }

    <span class="comment">/* Assigns a value to the specified element.
     *
     * Sample: deque[index] = value
     */</span>
    <span class="keyword">int</span> opIndexAssign(<span class="keyword">int</span> value, size_t index) {
        <span class="keyword">return</span> elementAt(index) = value;
    }

    <span class="comment">/* Uses the specified element and a value in a binary
     * operation and assigns the result back to the same
     * element.
     *
     * Sample: deque[index] += value
     */</span>
    <span class="keyword">int</span> opIndexOpAssign(string op)(<span class="keyword">int</span> value, size_t index) {
        <span class="keyword">mixin</span> (<span class="string_literal">"return elementAt(index) "</span> ~ op ~ <span class="string_literal">"= value;"</span>);
    }

    <span class="comment">/* Defines the $ character, which is the length of the
     * collection.
     *
     * Sample: deque[$ - 1]
     */</span>
    size_t opDollar() <span class="keyword">const</span> {
        <span class="keyword">return</span> head.length + tail.length;
    }
}

<span class="keyword">void</span> main() {
    <span class="keyword">auto</span> deque = DoubleEndedQueue();

    <span class="keyword">foreach</span> (i; 0 .. 10) {
        <span class="keyword">if</span> (i % 2) {
            deque.insertAtHead(i);

        } <span class="keyword">else</span> {
            deque ~= i;
        }
    }

    writefln(<span class="string_literal">"Element at index 3: %s"</span>,
             deque[3]);    <span class="comment">// accessing an element
</span>    ++deque[4];            <span class="comment">// incrementing an element
</span>    deque[5] = 55;         <span class="comment">// assigning to an element
</span>    deque[6] += 66;        <span class="comment">// adding to an element
</span>
    (deque ~= 100) ~= 200;

    writeln(deque);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>According to the guidelines above, the return type of  is  so that the  operator can be chained on the same collection:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    (deque ~= 100) ~= 200;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>As a result, both 100 and 200 get appended to the same collection:
</p>
<br><br>

<br><br>
<h5> Slicing operators</h5>
<br><br>
<p> allows slicing the objects of user-defined types with the  operator.
</p>
<br><br>
<p>   In addition to this operator, there are also , , and  but they are discouraged.
</p>
<br><br>
<p>D supports multi-dimensional slicing. We will see a multi-dimensional example later in <a href="templates_more.html">the More Templates chapter</a>. Although the methods described in that chapter can be used for a single dimension as well, they do not match the indexing operators that are defined above and they involve templates which we have not covered yet. For that reason, we will see the non-templated use of  in this chapter, which works only with a single dimension. (This use of  is discouraged as well.)
</p>
<br><br>
<p> has two distinct forms:
</p>
<br><br>
<ul><br><br>
<li>The square brackets can be empty as in  to mean <i>all elements</i>.</li>
<br><br>
<li>The square brackets can contain a number range as in  to mean <i>the elements in the specified range</i>.</li>
<br><br>
</ul>
<br><br>
<p>The slicing operators are relatively more complex than other operators because they involve two distinct concepts: <i>container</i> and <i>range</i>. We will see these concepts in more detail in later chapters.
</p>
<br><br>
<p>In single-dimensional slicing which does not use templates,  returns an object that represents a specific range of elements of the container. The object that  returns is responsible for defining the operations that are applied on that range elements. For example, behind the scenes the following expression is executed by first calling  to obtain a range object and then applying  on that object:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    deque[] *= 10;    <span class="comment">// multiply all elements by 10
</span>
    <span class="comment">// The equivalent of the above:
</span>    {
        <span class="keyword">auto</span> range = deque.opSlice();
        range.opOpAssign!<span class="string_literal">"*"</span>(10);
    }
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Accordingly, the  operators of  return a special  object so that the operations are applied to it:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.exception;

<span class="keyword">struct</span> DoubleEndedQueue {
<span class="comment">// ...
</span>
    <span class="comment">/* Returns a range that represents all of the elements.
     * ('Range' struct is defined below.)
     *
     * Sample: deque[]
     */</span>
    <span class="keyword">inout</span>(Range) () <span class="keyword">inout</span> {
        <span class="keyword">return</span> <span class="keyword">inout</span>(Range)(head[], tail[]);
    }

    <span class="comment">/* Returns a range that represents some of the elements.
     *
     * Sample: deque[begin .. end]
     */</span>
    <span class="keyword">inout</span>(Range) (size_t begin, size_t end) <span class="keyword">inout</span> {
        enforce(end &lt;= opDollar());
        enforce(begin &lt;= end);

        <span class="comment">/* Determine what parts of 'head' and 'tail'
         * correspond to the specified range: */</span>

        <span class="keyword">if</span> (begin &lt; head.length) {
            <span class="keyword">if</span> (end &lt; head.length) {
                <span class="comment">/* The range is completely inside 'head'. */</span>
                <span class="keyword">return</span> <span class="keyword">inout</span>(Range)(
                    head[$ - end .. $ - begin],
                    []);

            } <span class="keyword">else</span> {
                <span class="comment">/* Some part of the range is inside 'head' and
                 * the rest is inside 'tail'. */</span>
                <span class="keyword">return</span> <span class="keyword">inout</span>(Range)(
                    head[0 .. $ - begin],
                    tail[0 .. end - head.length]);
            }

        } <span class="keyword">else</span> {
            <span class="comment">/* The range is completely inside 'tail'. */</span>
            <span class="keyword">return</span> <span class="keyword">inout</span>(Range)(
                [],
                tail[begin - head.length .. end - head.length]);
        }
    }

    <span class="comment">/* Represents a range of elements of the collection. This
     * struct is responsible for defining the opUnary,
     * opAssign, and opOpAssign operators. */</span>
    <span class="keyword">struct</span>  {
        <span class="keyword">int</span>[] headRange;    <span class="comment">// elements that are in 'head'
</span>        <span class="keyword">int</span>[] tailRange;    <span class="comment">// elements that are in 'tail'
</span>
        <span class="comment">/* Applies the unary operation to the elements of the
         * range. */</span>
        Range opUnary(string op)() {
            <span class="keyword">mixin</span> (op ~ <span class="string_literal">"headRange[];"</span>);
            <span class="keyword">mixin</span> (op ~ <span class="string_literal">"tailRange[];"</span>);
            <span class="keyword">return</span> <span class="keyword">this</span>;
        }

        <span class="comment">/* Assigns the specified value to each element of the
         * range. */</span>
        Range opAssign(<span class="keyword">int</span> value) {
            headRange[] = value;
            tailRange[] = value;
            <span class="keyword">return</span> <span class="keyword">this</span>;
        }

        <span class="comment">/* Uses each element and a value in a binary operation
         * and assigns the result back to that element. */</span>
        Range opOpAssign(string op)(<span class="keyword">int</span> value) {
            <span class="keyword">mixin</span> (<span class="string_literal">"headRange[] "</span> ~ op ~ <span class="string_literal">"= value;"</span>);
            <span class="keyword">mixin</span> (<span class="string_literal">"tailRange[] "</span> ~ op ~ <span class="string_literal">"= value;"</span>);
            <span class="keyword">return</span> <span class="keyword">this</span>;
        }
    }
}

<span class="keyword">void</span> main() {
    <span class="keyword">auto</span> deque = DoubleEndedQueue();

    <span class="keyword">foreach</span> (i; 0 .. 10) {
        <span class="keyword">if</span> (i % 2) {
            deque.insertAtHead(i);

        } <span class="keyword">else</span> {
            deque ~= i;
        }
    }

    writeln(deque);
    deque *= 10;
    deque = -1;
    writeln(deque);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The output:
</p>
<br><br>

<br><br>
<h5>   for type conversions</h5>
<br><br>
<p> defines explicit type conversions. It can be overloaded separately for each target type. As you would remember from the earlier chapters, explicit type conversions are performed by the  function and the  operator.
</p>
<br><br>
<p> is a template as well, but it has a different format: The target type is specified by the  syntax:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <i>target_type</i> opCast(T : <i>target_type</i>)() {
        <span class="comment">// ...
</span>    }
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>This syntax will become clear later after the templates chapter as well.
</p>
<br><br>
<p>Let's change the definition of  so that it now has two members: hours and minutes. The operator that converts objects of this type to  can be defined as in the following code:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;
<span class="keyword">import</span> std.conv;

<span class="keyword">struct</span> Duration {
    <span class="keyword">int</span> hour;
    <span class="keyword">int</span> minute;

    <span class="keyword">double</span> opCast(T : <span class="keyword">double</span>)() <span class="keyword">const</span> {
        <span class="keyword">return</span> hour + (to!<span class="keyword">double</span>(minute) / 60);
    }
}

<span class="keyword">void</span> main() {
    <span class="keyword">auto</span> duration = Duration(2, 30);
    <span class="keyword">double</span> d = to!<span class="keyword">double</span>(duration);
    <span class="comment">// (could be 'cast(double)duration' as well)
</span>
    writeln(d);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The compiler replaces the type conversion call above with the following one:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">double</span> d = duration.opCast!<span class="keyword">double</span>();
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The  conversion function above produces 2.5 for two hours and thirty minutes:
</p>
<br><br>

<br><br>
<p>  Although  is for explicit type conversions, its  specialization is called automatically when the variable is used in a logical expression:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> Duration {
<span class="comment">// ...
</span>
    <span class="keyword">bool</span> opCast()() <span class="keyword">const</span> {
        <span class="keyword">return</span> (hour != 0) || (minute != 0);
    }
}

<span class="comment">// ...
</span>
    <span class="keyword">if</span> (duration) {               <span class="comment">// compiles
</span>        <span class="comment">// ...
</span>    }

    <span class="keyword">while</span> (duration) {            <span class="comment">// compiles
</span>        <span class="comment">// ...
</span>    }

    <span class="keyword">auto</span> r = duration ? 1 : 2;    <span class="comment">// compiles
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Still, the  specialization of  is not for all implicit  conversions:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">void</span> foo(<span class="keyword">bool</span> b) {
    <span class="comment">// ...
</span>}

<span class="comment">// ...
</span>
    foo(duration);                
    <span class="keyword">bool</span> b = duration;            
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>

<br><br>
<h5> Catch-all operator </h5>
<br><br>
<p> gets called whenever a <i>missing</i> member of an object is accessed. All attempts to access non-existent members are dispatched to this function.
</p>
<br><br>
<p>The name of the missing member becomes the template parameter value of .
</p>
<br><br>
<p>The following code demonstrates a simple definition:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;

<span class="keyword">struct</span> Foo {
    <span class="keyword">void</span> opDispatch(string name, T)(T parameter) {
        writefln(<span class="string_literal">"Foo.opDispatch - name: %s, value: %s"</span>,
                 name, parameter);
    }
}

<span class="keyword">void</span> main() {
    Foo foo;
    foo.aNonExistentFunction(42);
    foo.anotherNonExistentFunction(100);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>There are no compiler errors for the calls to non-existent members. Instead, all of those calls are dispatched to . The first template parameter is the name of the member. The parameter values that are used when calling the function appear as the parameters of :
</p>
<br><br>

<br><br>
<p>The  template parameter can be used inside the function to make decisions on how the call to that specific non-existent function should be handled:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">   <span class="keyword">switch</span> (name) {
       <span class="comment">// ...
</span>   }
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<h5>  Inclusion query by </h5>
<br><br>
<p>This operator allows defining the behavior of the  operator for user-defined types.  is commonly used with associative arrays to determine whether a value for a specific key exists in the array.
</p>
<br><br>
<p>Different from other operators, this operator is normally overloaded for the case where the object appears on the right-hand side:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">        <span class="keyword">if</span> (time <span class="keyword">in</span> lunchBreak) {
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The compiler would use  behind the scenes:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">        <span class="comment">// the equivalent of the above:
</span>        <span class="keyword">if</span> (lunchBreak.opBinaryRight!<span class="string_literal">"in"</span>(time)) {
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>There is also  to determine whether a value for a specific key <i>does not</i> exist in the array:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">        <span class="keyword">if</span> (a !<span class="keyword">in</span> b) {
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p> cannot be overloaded because the compiler uses the negative of the result of the  operator instead:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">        <span class="keyword">if</span> (!(a <span class="keyword">in</span> b)) {    <span class="comment">// the equivalent of the above
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<h6>Example of the  operator</h6>
<br><br>
<p>The following program defines a  type in addition to  and . The  operator that is defined for  determines whether a moment in time is within that time span.
</p>
<br><br>
<p>To keep the code short, the following program defines only the necessary member functions.
</p>
<br><br>
<p>Note how the  object is used seamlessly in the  loop. That loop is a demonstration of how useful operator overloading can be.
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;
<span class="keyword">import</span> std.string;

<span class="keyword">struct</span> Duration {
    <span class="keyword">int</span> minute;
}

<span class="keyword">struct</span> TimeOfDay {
    <span class="keyword">int</span> hour;
    <span class="keyword">int</span> minute;

    <span class="keyword">ref</span> TimeOfDay opOpAssign(string op)(Duration duration)
            <span class="keyword">if</span> (op == <span class="string_literal">"+"</span>) {
        minute += duration.minute;

        hour += minute / 60;
        minute %= 60;
        hour %= 24;

        <span class="keyword">return</span> <span class="keyword">this</span>;
    }

    <span class="keyword">int</span> opCmp(TimeOfDay rhs) <span class="keyword">const</span> {
        <span class="keyword">return</span> (hour == rhs.hour
                ? minute - rhs.minute
                : hour - rhs.hour);
    }

    string toString() <span class="keyword">const</span> {
        <span class="keyword">return</span> format(<span class="string_literal">"%02s:%02s"</span>, hour, minute);
    }
}

<span class="keyword">struct</span> TimeSpan {
    TimeOfDay begin;
    TimeOfDay end;    <span class="comment">// end is outside of the span
</span>
    <span class="keyword">bool</span> opBinaryRight(string op)(TimeOfDay time) <span class="keyword">const</span>
            <span class="keyword">if</span> (op == <span class="string_literal">"in"</span>) {
        <span class="keyword">return</span> (time &gt;= begin) &amp;&amp; (time &lt; end);
    }
}

<span class="keyword">void</span> main() {
    <span class="keyword">auto</span> lunchBreak = TimeSpan(TimeOfDay(12, 00),
                               TimeOfDay(13, 00));

    <span class="keyword">for</span> (<span class="keyword">auto</span> time = TimeOfDay(11, 30);
         time &lt; TimeOfDay(13, 30);
         time += Duration(15)) {

        <span class="keyword">if</span> (time <span class="keyword">in</span> lunchBreak) {
            writeln(time, <span class="string_literal">" is during the lunch break"</span>);

        } <span class="keyword">else</span> {
            writeln(time, <span class="string_literal">" is outside of the lunch break"</span>);
        }
    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The output:
</p>
<br><br>

<br><br>


</section>
      </article>
    </div>
  </body>
</html>
