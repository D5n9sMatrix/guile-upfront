
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Slices and Other Array Features</title>
    <style type="text/css" media="screen">
      html, body, div, span, object, iframe, h1, h2, h3, h4, h5, h6, p,
      blockquote, pre, a, abbr, address, cite, code, del, dfn, em, figure,
      img, ins, kbd, q, s, samp, small, strong, sub, sup, var, b, u, i, dl,
      dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption,
      tbody, tfoot, thead, tr, th, td {
        background: transparent none repeat scroll 0 0;
        border: 0 none;
        font-size: 100%;
        margin: 0;
        outline: 0 none;
        padding: 0;
        vertical-align: baseline;
      }

      h1 { font-size: 200%; }
      h2 { font-size: 160%; }
      h3 { font-size: 120%; }
      h4 { font-size: 100%; }
      h5 { font-size: 80%; }
      h6 { font-size: 80%; font-weight: normal; }

      ul, ol {
        margin: 1.4em 0;
      }
      ul ul, ol ol, ul ol, ol ul {
        margin-top: 0;
        margin-bottom: 0;
      }
      ul, ol {
        margin-left: 2.8em;
      }

      ol {
        list-style: decimal;
      }
      ol ol {
        list-style: lower-alpha;
      }
      ol ol ol {
        list-style: lower-roman;
      }
      ol ol ol ol {
        list-style: decimal;
      }

      blockquote {
        margin: 0.1em;
        margin-left: 1em;
        border-left: 2px solid #cccccc;
        padding-left: 0.7em;
      }

      .color_red { color: #dc322f; }
      .color_blue { color: #268bd2; }
      .color_green { color: #859901; }
      .color_yellow { color: #b58901; }
      .color_black { color: black; }
      .color_white { color: white; }

      .font_big {
        font-size: 1.2em;
      }

      .ddoc_section_h {
        font-weight: bold;
        font-size: 13px;
        line-height: 19.5px;
        margin-top: 11px;
        display: block;
      }

      body.dlang .dlang {
        display: inline-block;
      }

      body.dlang .declaration .dlang {
          display: block;
      }

      body.dlang .ddoc_header_anchor a.dlang {
        display: block;
        color: rgba(0, 136, 204, 1);
        text-decoration: none;
      }

      body.dlang .ddoc_header_anchor .code {
        color: rgba(0, 136, 204, 1);
      }

      #ddoc_main .module {
          border-color: currentColor rgba(233, 233, 233, 1) rgba(233, 233, 233, 1);
          border-style: none solid solid;
          border-width: 0 1px 1px;
          overflow-x: hidden;
          padding: 15px;
      }

      #ddoc_main .section .section {
        margin-top: 0;
      }

      #ddoc_main .ddoc_module_members_section {
          padding: 1px 0 0;
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .ddoc_member, #ddoc_main .ddoc_module_members section.intro {
          background: #fff none repeat scroll 0 0;
          list-style-type: none;
          width: 100%;
      }

      #ddoc_main .ddoc_header_anchor {
          font-size: 1.4em;
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .ddoc_header_anchor > .code {
          display: inline-block;

      }

      #ddoc_main .ddoc_decl {
        background-color: transparent;
        height: 100%;
        left: 0;
        top: 0;
        padding: 0;
        padding-left: 15px;
      }

      #ddoc_main .ddoc_decl .section, #ddoc_main .section.ddoc_sections {
        background: white none repeat scroll 0 0;
        margin: 0;
        padding: 5px;
        position: relative;
        border-radius: 5px;
      }

      #ddoc_main .ddoc_decl .section h4:first-of-type, #ddoc_main .section.ddoc_sections h4:first-of-type {
        font-size: 13px;
        line-height: 1.5;
        margin-top: 21px;
      }

      #ddoc_main .section .declaration {
          margin-top: 21px;
      }

      #ddoc_main .section .declaration .code {
          color: rgba(0, 0, 0, 1);
          margin-bottom: 15px;
          padding-bottom: 6px;
      }

      #ddoc_main .declaration div .para {
          margin-bottom: 0;
      }

      #ddoc_main .ddoc_params .graybox tr td:first-of-type {
        padding: 7px;
        text-align: right;
        vertical-align: top;
        word-break: normal;
        white-space: nowrap;
      }

      #ddoc_main .ddoc_params .graybox {
        border: 0 none;
      }

      #ddoc_main .ddoc_params .graybox td {
        border-color: rgba(214, 214, 214, 1);
      }

      #ddoc_main .ddoc_params .graybox tr:first-child > td {
        border-top: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr:last-child > td {
        border-bottom: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr > td:first-child {
        border-left: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr > td:last-child {
        border-right: 0 none;
        width: 100%;
      }

      #ddoc_main em.term, #ddoc_main em.term .code {
        color: rgba(65, 65, 65, 1);
        font-size: 12px;
        font-style: italic;
        line-height: 1.5;
      }

      #ddoc_main .see-also {
        cursor: pointer;
        font-family: Menlo,monospace;
      }

      #ddoc_main .ddoc_decl .section > div:last-of-type {
        margin-bottom: 15px;
      }

      #ddoc_main .ddoc_member, #ddoc_main .ddoc_module_members {
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .code_sample {
        background: inherit;
      }

      #ddoc_main .declaration .code-line {
          display: block;
          font: 1em Menlo,monospace;
      }

      #ddoc_main a[name] {
        margin: -112px 0 0;
        padding-top: 112px;
      }

      #ddoc_main .ddoc_decl td {
        max-width: inherit;
      }

      #ddoc_main .declaration a {
        color: inherit;
      }

      #ddoc_main .declaration a:hover {
          color: rgba(0, 136, 204, 1);
          text-decoration: underline;
      }

      body.ddoc {
        background-color: transparent;
        color: rgba(0, 0, 0, 1);
        font-family: Helvetica,Arial,sans-serif;
        font-size: 62.5%;
        margin: 0;
        border: 0;
        left: 0;
        top: 0;
        padding: 0;
      }

      .ddoc a[name] {
        display: block;
        height: 0;
        margin: -85px 0 0;
        padding-top: 85px;
        width: 0;
      }

      .ddoc .module {
          border-color: transparent;
          background-color: rgba(255, 255, 255, 1);
          border-color: currentColor rgba(233, 233, 233, 1) rgba(233, 233, 233, 1);
          border-image: none;
          border-style: none solid solid;
          border-width: 0 1px 1px;
          box-shadow: 0 0 1px rgba(0, 0, 0, 0.07);
          display: block;
          margin-left: 0;
          min-height: calc(100% - 173px);
          overflow: auto;
          padding-bottom: 100px;
      }

      .ddoc .content_wrapper {
          background-color: rgba(242, 242, 242, 1);
          margin: 0 auto;
          max-width: 980px;
      }

      .ddoc .section {
        padding: 15px 25px 30px;
      }

      .ddoc .section .section {
        margin: 30px 0 0;
        padding: 0;
      }

      .ddoc .para {
        color: rgba(65, 65, 65, 1);
        font-size: 1.4em;
        line-height: 145%;
        margin-bottom: 15px;
      }

      .ddoc .ddoc_examples .para {
        margin-bottom: 0;
      }

      .ddoc .module_name {
          color: rgba(0, 0, 0, 1);
          display: block;
          font-family: Helvetica;
          font-size: 2.8em;
          font-weight: 100;
          margin-bottom: 0;
          padding: 15px 0;
      }

      .ddoc .module a {
          color: rgba(0, 136, 204, 1);
          text-decoration: none;
      }

      .ddoc .code {
        color: rgba(128, 128, 128, 1);
        font-family: Menlo,monospace;
        font-size: 0.85em;
        word-wrap: break-word;
      }

      .ddoc .code i {
        font-style: normal;
      }

      .ddoc .code .code {
        font-size: 1em;
      }

      .ddoc .code_sample {
        background-clip: padding-box;
        margin: 1px 0;
        text-align: left;
      }

      .ddoc .code_sample {
        display: block;
        font-size: 1.4em;
        margin-left: 21px;
      }

      .ddoc ol .code_sample {
        font-size: 1em;
      }

      .ddoc .code_lines {
        counter-reset: li;
        line-height: 1.6em;
        list-style: outside none none;
        margin: 0;
        padding: 0;
      }

      .ddoc .code_listing .code_sample div {
        margin-left: 13px;
        width: 93%;
      }

      .ddoc .code_listing .code_sample div .code_lines li {
        list-style-type: none;
        margin: 0;
        padding-right: 10px;
      }

      .ddoc .code_sample div .code_lines li::before {
        margin-left: -33px;
        margin-right: 25px;
      }

      .ddoc .code_sample div .code_lines li:nth-child(n+10)::before {
        margin-left: -39px;
        margin-right: 25px;
      }

      .ddoc .code_sample div .code_lines li:nth-child(n+100)::before {
        margin-left: -46px;
        margin-right: 25px;
      }

      .ddoc .code_sample .code_lines .code {
        color: #000;
      }

      .ddoc div.dlang {
        margin: 10px 0 21px;
        padding: 4px 0 2px 10px;
      }

      .ddoc div.dlang {
          margin: 10px 0 21px;
          padding: 4px 0 2px 10px;
      }

      .ddoc div.dlang {
        border-left: 5px solid rgba(0, 155, 51, 0.2);
      }

      .ddoc .code_lines li::before {
        color: rgba(128, 128, 128, 1);
        content: counter(li, decimal);
        counter-increment: li;
        font-family: Menlo,monospace;
        font-size: 0.9em;
        margin-right: 16px;
      }

      .ddoc .code_lines li {
        padding-left: 0;
        white-space: pre-wrap;
      }

      .ddoc .code_lines li:only-of-type::before {
        color: rgba(255, 255, 255, 1);
        content: " ";
      }

      .ddoc .code_lines li:only-of-type {
        color: rgba(255, 255, 255, 1);
        content: " ";
      }

      .ddoc .code_lines li:nth-child(n+10) {
        text-indent: -17px;
      }

      .ddoc .code_lines li:nth-child(n+10)::before {
        margin-right: 12px;
      }

      .ddoc .graybox {
        border: 1px solid rgba(233, 233, 233, 1);
        border-collapse: collapse;
        border-spacing: 0;
        empty-cells: hide;
        margin: 20px 0 36px;
        text-align: left;
      }

      .ddoc .graybox p {
        margin: 0;
        min-width: 50px;
      }

      .ddoc th {
        margin: 0;
        max-width: 260px;
        padding: 5px 10px 5px 10px;
        vertical-align: bottom;
      }

      .ddoc td {
        border: 1px solid rgba(233, 233, 233, 1);
        margin: 0;
        max-width: 260px;
        padding: 5px 10px 5px 10px;
        vertical-align: middle;
      }

      .punctuation {
        color: rgba(0, 0, 0, 1);
      }

      .comment {
        color: rgba(0, 131, 18, 1);
      }

      .operator {
        color: #000;
      }

      .keyword {
        color: rgba(170, 13, 145, 1);
      }

      .keyword_type {
        color: rgba(170, 51, 145, 1);
      }

      .string_literal {
        color: rgba(196, 26, 22, 1);
      }

      .ddoc_psuper_symbol {
        color: rgba(92, 38, 153, 1);
      }

      .param {
        color: rgba(0, 0, 0, 1);
      }

      .psymbol {
        color: rgba(0, 0, 0, 1);
      }

      .ddoc_member_header .ddoc_header_anchor .code {
        font-size: 1em;
      }
    </style>
  </head>
  <body id="ddoc_main" class="ddoc dlang">
    <div class="content_wrapper">
      <article class="module">
        <h1 class="module_name">Slices and Other Array Features</h1>
        <section id="module_content"><br><br>
<br><br>

<br><br>
<p>We have seen in the <a href="arrays.html">Arrays chapter</a> how elements are grouped as a collection in an array. That chapter was intentionally brief, leaving most of the features of arrays to this chapter.
</p>
<br><br>
<p>Before going any further, here are a few brief definitions of some of the terms that happen to be close in meaning:
</p>
<br><br>
<ul><br><br>
<li><b>Array:</b> The general concept of a group of elements that are located side by side and are accessed by indexes.
</li>
<br><br>
<li><b>Fixed-length array (static array):</b> An array with a fixed number of elements. This type of array owns its elements.
</li>
<br><br>
<li><b>Dynamic array:</b> An array that can gain or lose elements. This type of array provides access to elements that are owned by the D runtime environment.
</li>
<br><br>
<li><b>Slice:</b> Another name for <i>dynamic array</i>.
</li>
<br><br>
</ul>
<br><br>
<p>When I write <i>slice</i> I will specifically mean a slice; and when I write <i>array</i>, I will mean either a slice or a fixed-length array, with no distinction.
</p>
<br><br>
<h5>Slices</h5>
<br><br>
<p>Slices are the same feature as dynamic arrays. They are called <i>dynamic arrays</i> for being used like arrays, and are called <i>slices</i> for providing access to portions of other arrays. They allow using those portions as if they are separate arrays.
</p>
<br><br>
<p> Slices are defined by the <i>number range</i> syntax that correspond to the indexes that specify the beginning and the end of the range:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">  <i>beginning_index</i> .. <i>one_beyond_the_end_index</i>
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>In the number range syntax, the beginning index is a part of the range but the end index is outside of the range:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="comment">/* ... */</span> = monthDays[0 .. 3];  <span class="comment">// 0, 1, and 2 are included; but not 3
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p><i><b>Note:</b> Number ranges are different from Phobos ranges. Phobos ranges are about struct and class interfaces. We will see these features in later chapters.
</i>
</p>
<br><br>
<p>As an example, we can <i>slice</i> the  array to be able to use its parts as four smaller arrays:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span>[12] monthDays =
        [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];

    <span class="keyword">int</span>[] firstQuarter  = monthDays[0 .. 3];
    <span class="keyword">int</span>[] secondQuarter = monthDays[3 .. 6];
    <span class="keyword">int</span>[] thirdQuarter  = monthDays[6 .. 9];
    <span class="keyword">int</span>[] fourthQuarter = monthDays[9 .. 12];
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The four variables in the code above are slices; they provide access to four parts of an already existing array. An important point worth stressing here is that those slices do not have their own elements. They merely provide access to the elements of the actual array. Modifying an element of a slice modifies the element of the actual array. To see this, let's modify the first elements of each slice and then print the actual array:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    firstQuarter[0]  = 1;
    secondQuarter[0] = 2;
    thirdQuarter[0]  = 3;
    fourthQuarter[0] = 4;

    writeln(monthDays);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The output:
</p>
<br><br>

<br><br>
<p>Each slice modifies its first element, and the corresponding element of the actual array is affected.
</p>
<br><br>
<p>We have seen earlier that valid array indexes are from 0 to one less than the length of the array. For example, the valid indexes of a 3-element array are 0, 1, and 2. Similarly, the end index in the slice syntax specifies one beyond the last element that the slice will be providing access to. For that reason, when the last element of an array needs to be included in a slice, the length of the array must be specified as the end index. For example, a slice of all elements of a 3-element array would be .
</p>
<br><br>
<p>An obvious limitation is that the beginning index cannot be greater than the end index:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span>[3] array = [ 0, 1, 2 ];
    <span class="keyword">int</span>[] slice = array[2 .. 1];  <span class="comment">// ← run-time ERROR
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>It is legal to have the beginning and the end indexes to be equal. In that case the slice is empty. Assuming that  is valid:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span>[] slice = anArray[index .. index];
    writeln(<span class="string_literal">"The length of the slice: "</span>, slice.length);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The output:
</p>
<br><br>

<br><br>
<h5> Using , instead of </h5>
<br><br>
<p>When indexing,  is a shorthand for the length of the array:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    writeln(array[array.length - 1]);  <span class="comment">// the last element
</span>    writeln(array[$ - 1]);             <span class="comment">// the same thing
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<h5>  Using  to copy</h5>
<br><br>
<p>Short for "duplicate", the  property makes a new array from the copies of the elements of an existing array:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">double</span>[] array = [ 1.25, 3.75 ];
    <span class="keyword">double</span>[] theCopy = array.dup;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>As an example, let's define an array that contains the number of days of the months of a leap year. A method is to take a copy of the non-leap-year array and then to increment the element that corresponds to February:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;

<span class="keyword">void</span> main() {
    <span class="keyword">int</span>[12] monthDays =
        [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];

    <span class="keyword">int</span>[] leapYear = monthDays;

    ++leapYear[1];   <span class="comment">// increments the days in February
</span>
    writeln(<span class="string_literal">"Non-leap year: "</span>, monthDays);
    writeln(<span class="string_literal">"Leap year    : "</span>, leapYear);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The output:
</p>
<br><br>

<br><br>
<h5> Assignment</h5>
<br><br>
<p>We have seen so far that the assignment operator <i>modifies</i> values of variables. It is the same with fixed-length arrays:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span>[3] a = [ 1, 1, 1 ];
    <span class="keyword">int</span>[3] b = [ 2, 2, 2 ];

    a = b;        <span class="comment">// the elements of 'a' become 2
</span>    writeln(a);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The output:
</p>
<br><br>

<br><br>
<p>The assignment operation has a completely different meaning for slices: It makes the slice start providing access to new elements:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span>[] odds = [ 1, 3, 5, 7, 9, 11 ];
    <span class="keyword">int</span>[] evens = [ 2, 4, 6, 8, 10 ];

    <span class="keyword">int</span>[] slice;   <span class="comment">// not providing access to any elements yet
</span>
     odds[2 .. $ - 2];
    writeln(slice);

     evens[1 .. $ - 1];
    writeln(slice);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Above,  does not provide access to any elements when it is defined. It is then used to provide access to some of the elements of , and later to some of the elements of :
</p>
<br><br>

<br><br>
<h5>Making a slice longer may terminate sharing</h5>
<br><br>
<p>Since the length of a fixed-length array cannot be changed, the concept of <i>termination of sharing</i> is only about slices.
</p>
<br><br>
<p>It is possible to access the same elements by more than one slice. For example, the first two of the eight elements below are being accessed through three slices:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;

<span class="keyword">void</span> main() {
    <span class="keyword">int</span>[] slice = [ 1, 3, 5, 7, 9, 11, 13, 15 ];
    <span class="keyword">int</span>[] half = slice[0 .. $ / 2];
    <span class="keyword">int</span>[] quarter = slice[0 .. $ / 4];

    quarter[1] = 0;     <span class="comment">// modify through one slice
</span>
    writeln(quarter);
    writeln(half);
    writeln(slice);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The effect of the modification to the second element of  is seen through all slices:
</p>
<br><br>

<br><br>
<p> When viewed this way, slices provide <i>shared</i> access to elements. This sharing opens the question of what happens when a new element is added to one of the slices. Since multiple slices can provide access to same elements, there may not be room to add elements to a slice without <i>stomping</i> on the elements of others.
</p>
<br><br>
<p>D disallows element stomping and answers this question by terminating the sharing relationship if there is no room for the new element: The slice that has no room to grow leaves the sharing. When this happens, all of the existing elements of that slice are copied to a new place automatically and the slice starts providing access to these new elements.
</p>
<br><br>
<p>To see this in action, let's add an element to  before modifying its second element:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    quarter ~= 42;    <span class="comment">// this slice leaves the sharing because
</span>                      <span class="comment">// there is no room for the new element
</span>
    quarter[1] = 0;   <span class="comment">// for that reason this modification
</span>                      <span class="comment">// does not affect the other slices
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The output of the program shows that the modification to the  slice does not affect the others:
</p>
<br><br>

<br><br>
<p>Explicitly increasing the length of a slice makes it leave the sharing as well:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    ++quarter.length;       <span class="comment">// leaves the sharing
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>or
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    quarter.length += 5;    <span class="comment">// leaves the sharing
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>On the other hand, shortening a slice does not affect sharing. Shortening the slice merely means that the slice now provides access to fewer elements:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span>[] a = [ 1, 11, 111 ];
    <span class="keyword">int</span>[] d = a;

    d = d[1 .. $];  <span class="comment">// shortening from the beginning
</span>    d[0] = 42;      <span class="comment">// modifying the element through the slice
</span>
    writeln(a);     <span class="comment">// printing the other slice
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>As can be seen from the output, the modification through  is seen through ; the sharing is still in effect:
</p>
<br><br>

<br><br>
<p>Reducing the length in different ways does not terminate the sharing either:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    d = d[0 .. $ - 1];         <span class="comment">// shortening from the end
</span>    --d.length;                <span class="comment">// same thing
</span>    d.length = d.length - 1;   <span class="comment">// same thing
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Sharing of elements is still in effect.
</p>
<br><br>
<h6> Using  to determine whether sharing will be terminated</h6>
<br><br>
<p>There are cases when slices continue sharing elements even after an element is added to one of them. This happens when the element is added to the longest slice and there is room at the end of it:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;

<span class="keyword">void</span> main() {
    <span class="keyword">int</span>[] slice = [ 1, 3, 5, 7, 9, 11, 13, 15 ];
    <span class="keyword">int</span>[] half = slice[0 .. $ / 2];
    <span class="keyword">int</span>[] quarter = slice[0 .. $ / 4];

    slice ~= 42;      <span class="comment">// adding to the longest slice ...
</span>    ;     <span class="comment">// ... and then modifying an element
</span>
    writeln(quarter);
    writeln(half);
    writeln(slice);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>As seen in the output, although the added element increases the length of a slice, the sharing has not been terminated, and the modification is seen through all slices:
</p>
<br><br>

<br><br>
<p>The  property of slices determines whether the sharing will be terminated if an element is added to a particular slice. ( is actually a function but this distinction does not have any significance in this discussion.)
</p>
<br><br>
<p>The value of  has the following meanings:
</p>
<br><br>
<ul><br><br>
<li>When its value is 0, it means that this is not the longest original slice. In this case, adding a new element would definitely relocate the elements of the slice and the sharing would terminate.
</li>
<br><br>
<li>When its value is nonzero, it means that this is the longest original slice. In this case  denotes the total number of elements that this slice can hold without needing to be copied. The number of <i>new elements</i> that can be added can be calculated by subtracting the actual length of the slice from the capacity value. If the length of the slice equals its capacity, then the slice will be copied to a new location if one more element is added.</li>
<br><br>
</ul>
<br><br>
<p>Accordingly, a program that needs to determine whether the sharing will terminate should use a logic similar to the following:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">if</span> (slice.capacity == 0) {
        <span class="comment">/* Its elements would be relocated if one more element
         * is added to this slice. */</span>

        <span class="comment">// ...
</span>
    } <span class="keyword">else</span> {
        <span class="comment">/* This slice may have room for new elements before
         * needing to be relocated. Let's calculate how
         * many: */</span>
        <span class="keyword">auto</span> howManyNewElements = slice.capacity - slice.length;

        <span class="comment">// ...
</span>    }
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>An interesting corner case is when there are more than one slice to <i>all elements</i>. In such a case all slices report to have capacity:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;

<span class="keyword">void</span> main() {
    <span class="comment">// Three slices to all elements
</span>    <span class="keyword">int</span>[] s0 = [ 1, 2, 3, 4 ];
    <span class="keyword">int</span>[] s1 = s0;
    <span class="keyword">int</span>[] s2 = s0;

    writeln(s0.capacity);
    writeln(s1.capacity);
    writeln(s2.capacity);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>All three have capacity:
</p>
<br><br>

<br><br>
<p>However, as soon as an element is added to one of the slices, the capacity of the others drop to 0:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    ;    

    writeln(s0.capacity);
    writeln(s1.capacity);
    writeln(s2.capacity);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Since the slice with the added element is now the longest, it is the only one with capacity:
</p>
<br><br>

<br><br>
<h6> Reserving room for elements</h6>
<br><br>
<p>Both copying elements and allocating new memory to increase capacity have some cost. For that reason, appending an element can be an expensive operation. When the number of elements to append is known beforehand, it is possible to reserve capacity for the elements:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;

<span class="keyword">void</span> main() {
    <span class="keyword">int</span>[] slice;

    slice;
    writeln(slice.capacity);

    <span class="keyword">foreach</span> (element; 0 .. ) {
        slice ~= element;  
    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>

<br><br>
<p>The elements of  would be moved only after there are more than 31 elements.
</p>
<br><br>
<h5>  Operations on all elements</h5>
<br><br>
<p>This feature is for both fixed-length arrays and slices.
</p>
<br><br>
<p>The  characters written after the name of an array means <i>all elements</i>. This feature simplifies the program when certain operations need to be applied to all of the elements of an array.
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;

<span class="keyword">void</span> main() {
    <span class="keyword">double</span>[3] a = [ 10, 20, 30 ];
    <span class="keyword">double</span>[3] b = [  2,  3,  4 ];

    <span class="keyword">double</span>[3] result = ;

    writeln(result);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The output:
</p>
<br><br>

<br><br>
<p>The addition operation in that program is applied to the corresponding elements of both of the arrays in order: First the first elements are added, then the second elements are added, etc. A natural requirement is that the lengths of the two arrays must be equal.
</p>
<br><br>
<p>The operator can be one of the arithmetic operators , , , , , and ; one of the binary operators , , and ; as well as the unary operators  and  that are typed in front of an array. We will see some of these operators in later chapters.
</p>
<br><br>
<p>The assignment versions of these operators can also be used: , , , , , , , , , and .
</p>
<br><br>
<p>This feature works not only using two arrays; it can also be used with an array and a compatible expression. For example, the following operation divides all elements of an array by four:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">double</span>[3] a = [ 10, 20, 30 ];
     /= 4;

    writeln(a);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The output:
</p>
<br><br>

<br><br>
<p>To assign a specific value to all elements:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">     = 42;
    writeln(a);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The output:
</p>
<br><br>

<br><br>
<p>This feature requires great attention when used with slices. Although there is no apparent difference in element values, the following two expressions have very different meanings:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    slice2 = slice1;      <span class="comment">// ← slice2 starts providing access
</span>                          <span class="comment">//   to the same elements that
</span>                          <span class="comment">//   slice1 provides access to
</span>
    slice3[] = slice1;    <span class="comment">// ← the values of the elements of
</span>                          <span class="comment">//   slice3 change
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The assignment of  makes it share the same elements as . On the other hand, since  means <i>all elements of </i>, the values of its elements become the same as the values of the elements of . The effect of the presence or absence of the  characters cannot be ignored.
</p>
<br><br>
<p>We can see an example of this difference in the following program:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;

<span class="keyword">void</span> main() {
    <span class="keyword">double</span>[] slice1 = [ 1, 1, 1 ];
    <span class="keyword">double</span>[] slice2 = [ 2, 2, 2 ];
    <span class="keyword">double</span>[] slice3 = [ 3, 3, 3 ];

    slice2 = slice1;      <span class="comment">// ← slice2 starts providing access
</span>                          <span class="comment">//   to the same elements that
</span>                          <span class="comment">//   slice1 provides access to
</span>
    slice3[] = slice1;    <span class="comment">// ← the values of the elements of
</span>                          <span class="comment">//   slice3 change
</span>
    writeln(<span class="string_literal">"slice1 before: "</span>, slice1);
    writeln(<span class="string_literal">"slice2 before: "</span>, slice2);
    writeln(<span class="string_literal">"slice3 before: "</span>, slice3);

    ;       <span class="comment">// ← the value of an element that
</span>                          <span class="comment">//   it shares with slice1 changes
</span>
    slice3[0] = 43;       <span class="comment">// ← the value of an element that
</span>                          <span class="comment">//   only it provides access to
</span>                          <span class="comment">//   changes
</span>
    writeln(<span class="string_literal">"slice1 after : "</span>, slice1);
    writeln(<span class="string_literal">"slice2 after : "</span>, slice2);
    writeln(<span class="string_literal">"slice3 after : "</span>, slice3);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The modification through  affects  too:
</p>
<br><br>

<br><br>
<p>The danger here is that the potential bug may not be noticed until after the value of a shared element is changed.
</p>
<br><br>
<h5> Multi-dimensional arrays</h5>
<br><br>
<p>So far we have used arrays with only fundamental types like  and . The element type can actually be any other type, including other arrays. This enables the programmer to define complex containers like <i>array of arrays</i>. Arrays of arrays are called <i>multi-dimensional arrays</i>.
</p>
<br><br>
<p>The elements of all of the arrays that we have defined so far have been written in the source code from left to right. To help us understand the concept of a two-dimensional array, let's define an array from top to bottom this time:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span>[] array = [
                    10,
                    20,
                    30,
                    40
                  ];
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>As you remember, most spaces in the source code are used to help with readability and do not change the meaning of the code. The array above could have been defined on a single line and would have the same meaning.
</p>
<br><br>
<p>Let's now replace every element of that array with another array:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">  <span class="comment">/* ... */</span> array = [
                      [ 10, 11, 12 ],
                      [ 20, 21, 22 ],
                      [ 30, 31, 32 ],
                      [ 40, 41, 42 ]
                    ];
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>We have replaced elements of type  with elements of type . To make the code conform to the array definition syntax, we must now specify the type of the elements as  instead of :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    [] array = [
                      [ 10, 11, 12 ],
                      [ 20, 21, 22 ],
                      [ 30, 31, 32 ],
                      [ 40, 41, 42 ]
                    ];
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Such arrays are called <i>two-dimensional arrays</i> because they can be seen as having rows and columns.
</p>
<br><br>
<p>Two-dimensional arrays are used the same way as any other array as long as we remember that each element is an array itself and is used in array operations:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    array ~= [ 50, 51 ]; <span class="comment">// adds a new element (i.e. a slice)
</span>    array[0] ~= 13;      <span class="comment">// adds to the first element
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The new state of the array:
</p>
<br><br>

<br><br>
<p>Arrays and elements can be fixed-length as well. The following is a three-dimensional array where all dimensions are fixed-length:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span>[2][3][4] array;  <span class="comment">// 2 columns, 3 rows, 4 pages
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The definition above can be seen as <i>four pages of three rows of two columns of integers</i>. As an example, such an array can be used to represent a 4-story building in an adventure game, each story consisting of 2x3=6 rooms.
</p>
<br><br>
<p>For example, the number of items in the first room of the second floor can be incremented as follows:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="comment">// The index of the second floor is 1, and the first room
</span>    <span class="comment">// of that floor is accessed by [0][0]
</span>    ++itemCounts[1][0][0];
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>In addition to the syntax above, the  expression can also be used to create a <i>slice of slices</i>. The following example uses only two dimensions:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;

<span class="keyword">void</span> main() {
    <span class="keyword">int</span>[][] s = <span class="keyword">new</span> <span class="keyword">int</span>[][](2, 3);
    writeln(s);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The  expression above creates 2 slices containing 3 elements each and returns a slice that provides access to those slices and elements. The output:
</p>
<br><br>

<br><br>
<h5>Summary</h5>
<br><br>
<ul><br><br>
<li>Fixed-length arrays own their elements; slices provide access to elements that don't belong exclusively to them.
</li>
<br><br>
<li>Within the  operator,  is the equivalent of .
</li>
<br><br>
<li> makes a new array that consists of the copies of the elements of an existing array.
</li>
<br><br>
<li>With fixed-length arrays, the assignment operation changes the values of elements; with slices, it makes the slices start providing access to other elements.
</li>
<br><br>
<li>Slices that get longer <i>may</i> stop sharing elements and start providing access to newly copied elements.  determines whether this will be the case.
</li>
<br><br>
<li>The syntax  means <i>all elements of the array</i>; the operation that is applied to it is applied to each element individually.
</li>
<br><br>
<li>Arrays of arrays are called multi-dimensional arrays.
</li>
<br><br>
</ul>
<br><br>


</section>
      </article>
    </div>
  </body>
</html>
