
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Structs</title>
    <style type="text/css" media="screen">
      html, body, div, span, object, iframe, h1, h2, h3, h4, h5, h6, p,
      blockquote, pre, a, abbr, address, cite, code, del, dfn, em, figure,
      img, ins, kbd, q, s, samp, small, strong, sub, sup, var, b, u, i, dl,
      dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption,
      tbody, tfoot, thead, tr, th, td {
        background: transparent none repeat scroll 0 0;
        border: 0 none;
        font-size: 100%;
        margin: 0;
        outline: 0 none;
        padding: 0;
        vertical-align: baseline;
      }

      h1 { font-size: 200%; }
      h2 { font-size: 160%; }
      h3 { font-size: 120%; }
      h4 { font-size: 100%; }
      h5 { font-size: 80%; }
      h6 { font-size: 80%; font-weight: normal; }

      ul, ol {
        margin: 1.4em 0;
      }
      ul ul, ol ol, ul ol, ol ul {
        margin-top: 0;
        margin-bottom: 0;
      }
      ul, ol {
        margin-left: 2.8em;
      }

      ol {
        list-style: decimal;
      }
      ol ol {
        list-style: lower-alpha;
      }
      ol ol ol {
        list-style: lower-roman;
      }
      ol ol ol ol {
        list-style: decimal;
      }

      blockquote {
        margin: 0.1em;
        margin-left: 1em;
        border-left: 2px solid #cccccc;
        padding-left: 0.7em;
      }

      .color_red { color: #dc322f; }
      .color_blue { color: #268bd2; }
      .color_green { color: #859901; }
      .color_yellow { color: #b58901; }
      .color_black { color: black; }
      .color_white { color: white; }

      .font_big {
        font-size: 1.2em;
      }

      .ddoc_section_h {
        font-weight: bold;
        font-size: 13px;
        line-height: 19.5px;
        margin-top: 11px;
        display: block;
      }

      body.dlang .dlang {
        display: inline-block;
      }

      body.dlang .declaration .dlang {
          display: block;
      }

      body.dlang .ddoc_header_anchor a.dlang {
        display: block;
        color: rgba(0, 136, 204, 1);
        text-decoration: none;
      }

      body.dlang .ddoc_header_anchor .code {
        color: rgba(0, 136, 204, 1);
      }

      #ddoc_main .module {
          border-color: currentColor rgba(233, 233, 233, 1) rgba(233, 233, 233, 1);
          border-style: none solid solid;
          border-width: 0 1px 1px;
          overflow-x: hidden;
          padding: 15px;
      }

      #ddoc_main .section .section {
        margin-top: 0;
      }

      #ddoc_main .ddoc_module_members_section {
          padding: 1px 0 0;
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .ddoc_member, #ddoc_main .ddoc_module_members section.intro {
          background: #fff none repeat scroll 0 0;
          list-style-type: none;
          width: 100%;
      }

      #ddoc_main .ddoc_header_anchor {
          font-size: 1.4em;
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .ddoc_header_anchor > .code {
          display: inline-block;

      }

      #ddoc_main .ddoc_decl {
        background-color: transparent;
        height: 100%;
        left: 0;
        top: 0;
        padding: 0;
        padding-left: 15px;
      }

      #ddoc_main .ddoc_decl .section, #ddoc_main .section.ddoc_sections {
        background: white none repeat scroll 0 0;
        margin: 0;
        padding: 5px;
        position: relative;
        border-radius: 5px;
      }

      #ddoc_main .ddoc_decl .section h4:first-of-type, #ddoc_main .section.ddoc_sections h4:first-of-type {
        font-size: 13px;
        line-height: 1.5;
        margin-top: 21px;
      }

      #ddoc_main .section .declaration {
          margin-top: 21px;
      }

      #ddoc_main .section .declaration .code {
          color: rgba(0, 0, 0, 1);
          margin-bottom: 15px;
          padding-bottom: 6px;
      }

      #ddoc_main .declaration div .para {
          margin-bottom: 0;
      }

      #ddoc_main .ddoc_params .graybox tr td:first-of-type {
        padding: 7px;
        text-align: right;
        vertical-align: top;
        word-break: normal;
        white-space: nowrap;
      }

      #ddoc_main .ddoc_params .graybox {
        border: 0 none;
      }

      #ddoc_main .ddoc_params .graybox td {
        border-color: rgba(214, 214, 214, 1);
      }

      #ddoc_main .ddoc_params .graybox tr:first-child > td {
        border-top: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr:last-child > td {
        border-bottom: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr > td:first-child {
        border-left: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr > td:last-child {
        border-right: 0 none;
        width: 100%;
      }

      #ddoc_main em.term, #ddoc_main em.term .code {
        color: rgba(65, 65, 65, 1);
        font-size: 12px;
        font-style: italic;
        line-height: 1.5;
      }

      #ddoc_main .see-also {
        cursor: pointer;
        font-family: Menlo,monospace;
      }

      #ddoc_main .ddoc_decl .section > div:last-of-type {
        margin-bottom: 15px;
      }

      #ddoc_main .ddoc_member, #ddoc_main .ddoc_module_members {
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .code_sample {
        background: inherit;
      }

      #ddoc_main .declaration .code-line {
          display: block;
          font: 1em Menlo,monospace;
      }

      #ddoc_main a[name] {
        margin: -112px 0 0;
        padding-top: 112px;
      }

      #ddoc_main .ddoc_decl td {
        max-width: inherit;
      }

      #ddoc_main .declaration a {
        color: inherit;
      }

      #ddoc_main .declaration a:hover {
          color: rgba(0, 136, 204, 1);
          text-decoration: underline;
      }

      body.ddoc {
        background-color: transparent;
        color: rgba(0, 0, 0, 1);
        font-family: Helvetica,Arial,sans-serif;
        font-size: 62.5%;
        margin: 0;
        border: 0;
        left: 0;
        top: 0;
        padding: 0;
      }

      .ddoc a[name] {
        display: block;
        height: 0;
        margin: -85px 0 0;
        padding-top: 85px;
        width: 0;
      }

      .ddoc .module {
          border-color: transparent;
          background-color: rgba(255, 255, 255, 1);
          border-color: currentColor rgba(233, 233, 233, 1) rgba(233, 233, 233, 1);
          border-image: none;
          border-style: none solid solid;
          border-width: 0 1px 1px;
          box-shadow: 0 0 1px rgba(0, 0, 0, 0.07);
          display: block;
          margin-left: 0;
          min-height: calc(100% - 173px);
          overflow: auto;
          padding-bottom: 100px;
      }

      .ddoc .content_wrapper {
          background-color: rgba(242, 242, 242, 1);
          margin: 0 auto;
          max-width: 980px;
      }

      .ddoc .section {
        padding: 15px 25px 30px;
      }

      .ddoc .section .section {
        margin: 30px 0 0;
        padding: 0;
      }

      .ddoc .para {
        color: rgba(65, 65, 65, 1);
        font-size: 1.4em;
        line-height: 145%;
        margin-bottom: 15px;
      }

      .ddoc .ddoc_examples .para {
        margin-bottom: 0;
      }

      .ddoc .module_name {
          color: rgba(0, 0, 0, 1);
          display: block;
          font-family: Helvetica;
          font-size: 2.8em;
          font-weight: 100;
          margin-bottom: 0;
          padding: 15px 0;
      }

      .ddoc .module a {
          color: rgba(0, 136, 204, 1);
          text-decoration: none;
      }

      .ddoc .code {
        color: rgba(128, 128, 128, 1);
        font-family: Menlo,monospace;
        font-size: 0.85em;
        word-wrap: break-word;
      }

      .ddoc .code i {
        font-style: normal;
      }

      .ddoc .code .code {
        font-size: 1em;
      }

      .ddoc .code_sample {
        background-clip: padding-box;
        margin: 1px 0;
        text-align: left;
      }

      .ddoc .code_sample {
        display: block;
        font-size: 1.4em;
        margin-left: 21px;
      }

      .ddoc ol .code_sample {
        font-size: 1em;
      }

      .ddoc .code_lines {
        counter-reset: li;
        line-height: 1.6em;
        list-style: outside none none;
        margin: 0;
        padding: 0;
      }

      .ddoc .code_listing .code_sample div {
        margin-left: 13px;
        width: 93%;
      }

      .ddoc .code_listing .code_sample div .code_lines li {
        list-style-type: none;
        margin: 0;
        padding-right: 10px;
      }

      .ddoc .code_sample div .code_lines li::before {
        margin-left: -33px;
        margin-right: 25px;
      }

      .ddoc .code_sample div .code_lines li:nth-child(n+10)::before {
        margin-left: -39px;
        margin-right: 25px;
      }

      .ddoc .code_sample div .code_lines li:nth-child(n+100)::before {
        margin-left: -46px;
        margin-right: 25px;
      }

      .ddoc .code_sample .code_lines .code {
        color: #000;
      }

      .ddoc div.dlang {
        margin: 10px 0 21px;
        padding: 4px 0 2px 10px;
      }

      .ddoc div.dlang {
          margin: 10px 0 21px;
          padding: 4px 0 2px 10px;
      }

      .ddoc div.dlang {
        border-left: 5px solid rgba(0, 155, 51, 0.2);
      }

      .ddoc .code_lines li::before {
        color: rgba(128, 128, 128, 1);
        content: counter(li, decimal);
        counter-increment: li;
        font-family: Menlo,monospace;
        font-size: 0.9em;
        margin-right: 16px;
      }

      .ddoc .code_lines li {
        padding-left: 0;
        white-space: pre-wrap;
      }

      .ddoc .code_lines li:only-of-type::before {
        color: rgba(255, 255, 255, 1);
        content: " ";
      }

      .ddoc .code_lines li:only-of-type {
        color: rgba(255, 255, 255, 1);
        content: " ";
      }

      .ddoc .code_lines li:nth-child(n+10) {
        text-indent: -17px;
      }

      .ddoc .code_lines li:nth-child(n+10)::before {
        margin-right: 12px;
      }

      .ddoc .graybox {
        border: 1px solid rgba(233, 233, 233, 1);
        border-collapse: collapse;
        border-spacing: 0;
        empty-cells: hide;
        margin: 20px 0 36px;
        text-align: left;
      }

      .ddoc .graybox p {
        margin: 0;
        min-width: 50px;
      }

      .ddoc th {
        margin: 0;
        max-width: 260px;
        padding: 5px 10px 5px 10px;
        vertical-align: bottom;
      }

      .ddoc td {
        border: 1px solid rgba(233, 233, 233, 1);
        margin: 0;
        max-width: 260px;
        padding: 5px 10px 5px 10px;
        vertical-align: middle;
      }

      .punctuation {
        color: rgba(0, 0, 0, 1);
      }

      .comment {
        color: rgba(0, 131, 18, 1);
      }

      .operator {
        color: #000;
      }

      .keyword {
        color: rgba(170, 13, 145, 1);
      }

      .keyword_type {
        color: rgba(170, 51, 145, 1);
      }

      .string_literal {
        color: rgba(196, 26, 22, 1);
      }

      .ddoc_psuper_symbol {
        color: rgba(92, 38, 153, 1);
      }

      .param {
        color: rgba(0, 0, 0, 1);
      }

      .psymbol {
        color: rgba(0, 0, 0, 1);
      }

      .ddoc_member_header .ddoc_header_anchor .code {
        font-size: 1em;
      }
    </style>
  </head>
  <body id="ddoc_main" class="ddoc dlang">
    <div class="content_wrapper">
      <article class="module">
        <h1 class="module_name">Structs</h1>
        <section id="module_content"><br><br>
<br><br>

<br><br>
<p>As has been mentioned several times earlier in the book, fundamental types are not suitable to represent higher-level concepts. For example, although a value of type  is suitable to represent the hour of day, two  variables would be more suitable together to represent a point in time: one for the hour and the other for the minute.
</p>
<br><br>
<p> Structs are the feature that allow defining new types by combining already existing other types. The new type is defined by the  keyword. By this definition, structs are <i>user defined types</i>. Most of the content of this chapter is directly applicable to classes as well. Especially the concept of <i>combining existing types to define a new type</i> is exactly the same for them.
</p>
<br><br>
<p>This chapter covers only the basic features of structs. We will see more of structs in the following chapters:
</p>
<br><br>
<ul><li><a href="member_functions.html">Member Functions</a></li>
<li><a href="const_member_functions.html">const ref Parameters and const Member Functions</a></li>
<li><a href="special_functions.html">Constructor and Other Special Functions</a></li>
<li><a href="operator_overloading.html">Operator Overloading</a></li>
<li><a href="encapsulation.html">Encapsulation and Protection Attributes</a></li>
<li><a href="property.html">Properties</a></li>
<li><a href="invariant.html">Contract Programming for Structs and Classes</a></li>
<li><a href="foreach_opapply.html">foreach with Structs and Classes</a></li>
</ul>
<br><br>
<p>To understand how useful structs are, let's take a look at the  function that we had defined earlier in the <a href="assert.html"> and  chapter</a>. The following definition is from the exercise solution of that chapter:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">void</span> addDuration(<span class="keyword">int</span> startHour, <span class="keyword">int</span> startMinute,
                 <span class="keyword">int</span> durationHour, <span class="keyword">int</span> durationMinute,
                 <span class="keyword">out</span> <span class="keyword">int</span> resultHour, <span class="keyword">out</span> <span class="keyword">int</span> resultMinute) {
    resultHour = startHour + durationHour;
    resultMinute = startMinute + durationMinute;
    resultHour += resultMinute / 60;

    resultMinute %= 60;
    resultHour %= 24;
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p><i><b>Note:</b> I will ignore the , , and  blocks in this chapter to keep the code samples short.</i>
</p>
<br><br>
<p>Although the function above clearly takes six parameters, when the three pairs of parameters are considered, it is conceptually taking only three bits of information for the starting time, the duration, and the result.
</p>
<br><br>
<h5>Definition</h5>
<br><br>
<p>The  keyword defines a new type by combining variables that are related in some way:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> TimeOfDay {
    <span class="keyword">int</span> hour;
    <span class="keyword">int</span> minute;
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The code above defines a new type named , which consists of two variables named  and . That definition allows the new  type to be used in the program just like any other type. The following code demonstrates how similar its use is to an 's:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span> number;            <span class="comment">// a variable
</span>    number = otherNumber;  <span class="comment">// taking the value of otherNumber
</span>
    TimeOfDay time;        <span class="comment">// an object
</span>    time = otherTime;      <span class="comment">// taking the value of otherTime
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The syntax of  definition is the following:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> <i>TypeName</i> {
    <span class="comment">// ... member variables and functions ...
</span>}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>We will see member functions in later chapters.
</p>
<br><br>
<p>The variables that a struct combines are called its <i>members</i>. According to this definition,  has two members:  and .
</p>
<br><br>
<h6> defines a type, not a variable</h6>
<br><br>
<p>There is an important distinction here: Especially after the <a href="name_space.html">Name Scope</a> and <a href="lifetimes.html">Lifetimes and Fundamental Operations</a> chapters, the curly brackets of  definitions may give the wrong impression that the struct members start and end their lives inside that scope. This is not true.
</p>
<br><br>
<p>Member definitions are not variable definitions:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> TimeOfDay {
    <span class="keyword">int</span> hour;      <span class="comment">// ← Not a variable; will become a part of
</span>                   <span class="comment">//   a struct variable used in the program.
</span>
    <span class="keyword">int</span> minute;    <span class="comment">// ← Not a variable; will become a part of
</span>                   <span class="comment">//   a struct variable used in the program.
</span>}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The definition of a  determines the types and the names of the members that the objects of that  will have. Those member variables will be constructed as parts of  objects that take part in the program:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    TimeOfDay bedTime;    <span class="comment">// This object contains its own hour
</span>                          <span class="comment">// and minute member variables.
</span>
    TimeOfDay wakeUpTime; <span class="comment">// This object contains its own hour
</span>                          <span class="comment">// and minute member variables as
</span>                          <span class="comment">// well. The member variables of
</span>                          <span class="comment">// this object are not related to
</span>                          <span class="comment">// the member variables of the
</span>                          <span class="comment">// previous object.
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p> Variables of  and  types are called <i>objects</i>.
</p>
<br><br>
<h6>Coding convenience</h6>
<br><br>
<p>Being able to combine the concepts of hour and minute together as a new type is a great convenience. For example, the function above can be rewritten in a more meaningful way by taking three  parameters instead of the existing six  parameters:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">void</span> addDuration(TimeOfDay start,
                 TimeOfDay duration,
                 <span class="keyword">out</span> TimeOfDay result) {
    <span class="comment">// ...
</span>}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p><i><b>Note:</b> It is not normal to add two variables that represent two points in time. For example, it is meaningless to add the lunch time 12:00 to the breakfast time 7:30. It would make more sense to define another type, appropriately called , and to add objects of that type to  objects. Despite this design flaw, I will continue using only  objects in this chapter and introduce  in a later chapter.</i>
</p>
<br><br>
<p>As you remember, functions return up-to a single value. That has precisely been the reason why the earlier definition of  was taking two  parameters: It could not return the hour and minute information as a single value.
</p>
<br><br>
<p>Structs remove this limitation as well: Since multiple values can be combined as a single  type, functions can return an object of such a , effectively returning multiple values at once.  can now be defined as returning its result:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">TimeOfDay addDuration(TimeOfDay start,
                      TimeOfDay duration) {
    <span class="comment">// ...
</span>}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>As a consequence,  now becomes a function that produces a value, as opposed to being a function that has side effects. As you would remember from the <a href="functions.html">Functions chapter</a>, producing results is preferred over having side effects.
</p>
<br><br>
<p>Structs can be members of other structs. For example, the following  has two  members:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> Meeting {
    string    topic;
    size_t    attendanceCount;
    TimeOfDay start;
    TimeOfDay end;
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p> can in turn be a member of another . Assuming that there is also the  struct:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> DailyPlan {
    Meeting projectMeeting;
    Meal    lunch;
    Meeting budgetMeeting;
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<h5> Accessing the members</h5>
<br><br>
<p>Struct members are used like any other variable. The only difference is that the actual struct variable and a <i>dot</i> must be specified before the name of the member:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    start.hour = 10;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The line above assigns the value 10 to the  member of the  object.
</p>
<br><br>
<p>Let's rewrite the  function with what we have seen so far:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">TimeOfDay addDuration(TimeOfDay start,
                      TimeOfDay duration) {
    TimeOfDay result;

    result.minute = start.minute + duration.minute;
    result.hour = start.hour + duration.hour;
    result.hour += result.minute / 60;

    result.minute %= 60;
    result.hour %= 24;

    <span class="keyword">return</span> result;
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Notice that the names of the variables are now much shorter in this version of the function: , , and . Additionally, instead of using complex names like , it is possible to access struct members through their respective struct variables as in .
</p>
<br><br>
<p>Here is a code that uses the new  function. Given the start time and the duration, the following code calculates when a class period at a school would end:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">void</span> main() {
    TimeOfDay periodStart;
    periodStart.hour = 8;
    periodStart.minute = 30;

    TimeOfDay periodDuration;
    periodDuration.hour = 1;
    periodDuration.minute = 15;

    <span class="keyword">immutable</span> periodEnd = addDuration(periodStart,
                                      periodDuration);

    writefln(<span class="string_literal">"Period end: %s:%s"</span>,
              periodEnd.hour, periodEnd.minute);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The output:
</p>
<br><br>

<br><br>
<p>The  above has been written only by what we have seen so far. We will make this code even shorter and cleaner soon.
</p>
<br><br>
<h5> Construction</h5>
<br><br>
<p>The first three lines of  are about constructing the  object and the next three lines are about constructing the  object. In each three lines of code first an object is being defined and then its hour and minute values are being set.
</p>
<br><br>
<p>In order for a variable to be used in a safe way, that variable must first be constructed in a consistent state. Because construction is so common, there is a special construction syntax for struct objects:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    TimeOfDay periodStart = TimeOfDay(8, 30);
    TimeOfDay periodDuration = TimeOfDay(1, 15);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The values are automatically assigned to the members in the order that they are specified: Because  is defined first in the , the value 8 is assigned to  and 30 is assigned to .
</p>
<br><br>
<p>As we have seen in <a href="cast.html">the Type Conversions chapter</a>, the construction syntax can be used for other types as well:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">auto</span> u = <span class="keyword">ubyte</span>(42);    <span class="comment">// u is a ubyte
</span>    <span class="keyword">auto</span> i = <span class="keyword">int</span>(u);       <span class="comment">// i is an int
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<h6>Constructing objects as </h6>
<br><br>
<p>Being able to construct the object by specifying the values of its members at once makes it possible to define objects as :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">immutable</span> periodStart = TimeOfDay(8, 30);
    <span class="keyword">immutable</span> periodDuration = TimeOfDay(1, 15);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Otherwise it would not be possible to mark an object first as  and then modify its members:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">     TimeOfDay periodStart;
    periodStart.hour = 8;      
    periodStart.minute = 30;   
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<h6>Trailing members need not be specified</h6>
<br><br>
<p>There may be fewer values specified than the number of members. In that case, the remaining members are initialized by the  values of their respective types.
</p>
<br><br>
<p>The following program constructs  objects each time with one less constructor parameter. The  checks indicate that the unspecified members are initialized automatically by their  values. (The reason for needing to call  is explained after the program):
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.math;

<span class="keyword">struct</span> Test {
    <span class="keyword">char</span>   c;
    <span class="keyword">int</span>    i;
    <span class="keyword">double</span> d;
}

<span class="keyword">void</span> main() {
    <span class="comment">// The initial values of all of the members are specified
</span>    <span class="keyword">auto</span> t1 = Test('a', 1, 2.3);
    <span class="keyword">assert</span>(t1.c == 'a');
    <span class="keyword">assert</span>(t1.i == 1);
    <span class="keyword">assert</span>(t1.d == 2.3);

    <span class="comment">// Last one is missing
</span>    <span class="keyword">auto</span> t2 = Test('a', 1);
    <span class="keyword">assert</span>(t2.c == 'a');
    <span class="keyword">assert</span>(t2.i == 1);
    <span class="keyword">assert</span>();

    <span class="comment">// Last two are missing
</span>    <span class="keyword">auto</span> t3 = Test('a');
    <span class="keyword">assert</span>(t3.c == 'a');
    <span class="keyword">assert</span>();
    <span class="keyword">assert</span>();

    <span class="comment">// No initial value specified
</span>    <span class="keyword">auto</span> t4 = Test();
    <span class="keyword">assert</span>();
    <span class="keyword">assert</span>();
    <span class="keyword">assert</span>();

    <span class="comment">// The same as above
</span>    Test t5;
    <span class="keyword">assert</span>(t5.c == <span class="keyword">char</span>.init);
    <span class="keyword">assert</span>(t5.i == <span class="keyword">int</span>.init);
    <span class="keyword">assert</span>(isNaN(t5.d));
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>As you would remember from the <a href="floating_point.html">Floating Point Types chapter</a>, the initial value of  is . Since the  value is <i>unordered</i>, it is meaningless to use it in equality comparisons. That is why calling  is the correct way of determining whether a value equals to .
</p>
<br><br>
<h6> Specifying default values for members</h6>
<br><br>
<p>It is important that member variables are automatically initialized with known initial values. This prevents the program from continuing with indeterminate values. However, the  value of their respective types may not be suitable for every type. For example,  is not even a valid value.
</p>
<br><br>
<p>The initial values of the members of a struct can be specified when the struct is defined. This is useful for example to initialize floating point members by , instead of the mostly-unusable .
</p>
<br><br>
<p>The default values are specified by the assignment syntax as the members are defined:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> Test {
    <span class="keyword">char</span>   c ;
    <span class="keyword">int</span>    i ;
    <span class="keyword">double</span> d ;
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Please note that the syntax above is not really assignment. The code above merely determines the default values that will be used when objects of that struct are actually constructed later in the program.
</p>
<br><br>
<p>For example, the following  object is being constructed without any specific values:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    Test t;  <span class="comment">// no value is specified for the members
</span>    writefln(<span class="string_literal">"%s,%s,%s"</span>, t.c, t.i, t.d);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>All of the members are initialized by their default values:
</p>
<br><br>

<br><br>
<h6>  Constructing by the  syntax</h6>
<br><br>
<p>Struct objects can also be constructed by the following syntax:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    TimeOfDay periodStart = { 8, 30 };
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Similar to the earlier syntax, the specified values are assigned to the members in the order that they are specified. The trailing members get their default values.
</p>
<br><br>
<p>This syntax is inherited from the C programming language:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">auto</span> periodStart = TimeOfDay(8, 30);    <span class="comment">// ← regular
</span>    TimeOfDay periodEnd = { 9, 30 };        <span class="comment">// ← C-style
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p> This syntax allows <i>designated initializers</i>. Designated initializers are for specifying the member that an initialization value is associated with. It is even possible to initialize members in a different order than they are defined in the :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    TimeOfDay t = {  42,  7 };
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<h5>  Copying and assignment</h5>
<br><br>
<p>Structs are value types. As has been described in the <a href="value_vs_reference.html">Value Types and Reference Types chapter</a>, this means that every  object has its own value. Objects get their own values when constructed, and their values change when they are assigned new values.
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">auto</span> yourLunchTime = TimeOfDay(12, 0);
    <span class="keyword">auto</span> myLunchTime = yourLunchTime;

    <span class="comment">// Only my lunch time becomes 12:05:
</span>    myLunchTime.minute += 5;

    <span class="comment">// ... your lunch time is still the same:
</span>    <span class="keyword">assert</span>(yourLunchTime.minute == 0);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>During a copy, all of the members of the source object are automatically copied to the corresponding members of the destination object. Similarly, assignment involves assigning each member of the source to the corresponding member of the destination.
</p>
<br><br>
<p>Struct members that are of reference types need extra attention.
</p>
<br><br>
<h6> Careful with members that are of reference types!</h6>
<br><br>
<p>As you remember, copying or assigning variables of reference types does not change any value, it changes what object is being referenced. As a result, copying or assigning generates one more reference to the right-hand side object. The relevance of this for struct members is that, the members of two separate struct objects would start providing access to the same value.
</p>
<br><br>
<p>To see an example of this, let's have a look at a struct where one of the members is a reference type. This struct is used for keeping the student number and the grades of a student:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> Student {
    <span class="keyword">int</span> number;
    <span class="keyword">int</span>[] grades;
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The following code constructs a second  object by copying an existing one:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="comment">// Constructing the first object:
</span>    <span class="keyword">auto</span> student1 = Student(1, [ 70, 90, 85 ]);

    <span class="comment">// Constructing the second student as a copy of the first
</span>    <span class="comment">// one and then changing its number:
</span>    <span class="keyword">auto</span> student2 = student1;
    student2.number = 2;

    <span class="comment">// WARNING: The grades are now being shared by the two objects!
</span>
    <span class="comment">// Changing the grades of the first student ...
</span>    student1.grades[0] += 5;

    <span class="comment">// ... affects the second student as well:
</span>    writeln(student2.grades[0]);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>When  is constructed, its members get the values of the members of . Since  is a value type, the second object gets its own  value.
</p>
<br><br>
<p>The two  objects also have individual  members as well. However, since slices are reference types, the actual elements that the two slices share are the same. Consequently, a change made through one of the slices is seen through the other slice.
</p>
<br><br>
<p>The output of the code indicates that the grade of the second student has been increased as well:
</p>
<br><br>

<br><br>
<p>For that reason, a better approach might be to construct the second object by the copies of the grades of the first one:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="comment">// The second Student is being constructed by the copies
</span>    <span class="comment">// of the grades of the first one:
</span>    <span class="keyword">auto</span> student2 = Student(2, student1.grades);

    <span class="comment">// Changing the grades of the first student ...
</span>    student1.grades[0] += 5;

    <span class="comment">// ... does not affect the grades of the second student:
</span>    writeln(student2.grades[0]);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Since the grades have been copied by , this time the grades of the second student are not affected:
</p>
<br><br>

<br><br>
<p><i>Note: It is possible to have even the reference members copied automatically. We will see how this is done later when covering struct member functions.</i>
</p>
<br><br>
<h5> Struct literals</h5>
<br><br>
<p>Similar to being able to use integer literal values like 10 in expressions without needing to define a variable, struct objects can be used as literals as well.
</p>
<br><br>
<p>Struct literals are constructed by the object construction syntax.
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    TimeOfDay(8, 30) <span class="comment">// ← struct literal value
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Let's first rewrite the  function above with what we have learned since its last version. The variables are constructed by the construction syntax and are  this time:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">void</span> main() {
    <span class="keyword">immutable</span> periodStart = TimeOfDay(8, 30);
    <span class="keyword">immutable</span> periodDuration = TimeOfDay(1, 15);

    <span class="keyword">immutable</span> periodEnd = addDuration(periodStart,
                                      periodDuration);

    writefln(<span class="string_literal">"Period end: %s:%s"</span>,
              periodEnd.hour, periodEnd.minute);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Note that  and  need not be defined as named variables in the code above. Those are in fact temporary variables in this simple program, which are used only for calculating the  variable. They could be passed to  as literal values instead:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">void</span> main() {
    <span class="keyword">immutable</span> periodEnd = addDuration(TimeOfDay(8, 30),
                                      TimeOfDay(1, 15));

    writefln(<span class="string_literal">"Period end: %s:%s"</span>,
              periodEnd.hour, periodEnd.minute);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<h5>  members</h5>
<br><br>
<p>Although objects mostly need individual copies of the struct's members, sometimes it makes sense for the objects of a particular struct type to share some variables. This may be necessary to maintain e.g. a general information about that struct type.
</p>
<br><br>
<p>As an example, let's imagine a type that assigns a separate identifier for every object that is constructed of that type:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> Point {
    <span class="comment">// The identifier of each object
</span>    size_t id;

    <span class="keyword">int</span> line;
    <span class="keyword">int</span> column;
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>In order to be able to assign different ids to each object, a separate variable is needed to keep the next available id. It would be incremented every time a new object is created. Assume that  is to be defined elsewhere and to be available in the following function:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">Point makePoint(<span class="keyword">int</span> line, <span class="keyword">int</span> column) {
    size_t id = nextId;
    ++nextId;

    <span class="keyword">return</span> Point(id, line, column);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>A decision must be made regarding where the common  variable is to be defined.  members are useful in such cases.
</p>
<br><br>
<p>Such common information is defined as a  member of the struct. Contrary to the regular members, there is a single variable of each  member for each thread. (Note that most programs consist of a single thread that starts executing the  function.) That single variable is shared by all of the objects of that struct in that thread:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;

<span class="keyword">struct</span> Point {
    <span class="comment">// The identifier of each object
</span>    size_t id;

    <span class="keyword">int</span> line;
    <span class="keyword">int</span> column;

    <span class="comment">// The id of the next object to construct
</span>    
}

Point makePoint(<span class="keyword">int</span> line, <span class="keyword">int</span> column) {
    size_t id = nextId;
    ++nextId;

    <span class="keyword">return</span> Point(id, line, column);
}

<span class="keyword">void</span> main() {
    <span class="keyword">auto</span> top = makePoint(7, 0);
    <span class="keyword">auto</span> middle = makePoint(8, 0);
    <span class="keyword">auto</span> bottom =  makePoint(9, 0);

    writeln(top.id);
    writeln(middle.id);
    writeln(bottom.id);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>As  is incremented at each object construction, each object gets a unique id:
</p>
<br><br>

<br><br>
<p>Since  members are owned by the entire type, there need not be an object to access them. As we have seen above, such objects can be accessed by the name of the type, as well as by the name of any object of that struct:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    ++Point.nextId;
    ++.nextId;    <span class="comment">// would be the same as above
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>When a variable is needed not <i>one per thread</i> but <i>one per program</i>, then those variables must be defined as . We will see the  keyword in a later chapter.
</p>
<br><br>
<h6>     for initialization and  for finalization</h6>
<br><br>
<p>Instead of explicitly assigning an initial value to  above, we relied on its default initial value, zero. We could have used any other value:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">static</span> size_t nextId ;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>However, such initialization is possible only when the initial value is known at compile time. Further, some special code may have to be executed before a struct can be used in a thread. Such code is written in  scopes.
</p>
<br><br>
<p>For example, the following code reads the initial value from a file if that file exists:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.file;

<span class="keyword">struct</span> Point {
<span class="comment">// ...
</span>
    <span class="keyword">enum</span> nextIdFile = <span class="string_literal">"Point_next_id_file"</span>;

     {
        <span class="keyword">if</span> (exists(nextIdFile)) {
            <span class="keyword">auto</span> file = File(nextIdFile, <span class="string_literal">"r"</span>);
            file.readf(<span class="string_literal">" %s"</span>, &amp;nextId);
        }
    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The contents of  blocks are automatically executed once per thread before the  type is ever used in that thread. Code that should be executed only once for the entire program (e.g. initializing  and  variables) must be defined in  and  blocks, which will be covered in <a href="concurrency_shared.html">the Data Sharing Concurrency chapter</a>.
</p>
<br><br>
<p>Similarly,  is for the final operations of a thread and  is for the final operations of the entire program.
</p>
<br><br>
<p>The following example complements the previous  by writing the value of  to the same file, effectively persisting the object ids over consecutive executions of the program:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> Point {
<span class="comment">// ...
</span>
     {
        <span class="keyword">auto</span> file = File(nextIdFile, <span class="string_literal">"w"</span>);
        file.writeln(nextId);
    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The program would now initialize  from where it was left off. For example, the following would be the output of the program's second execution:
</p>
<br><br>

<br><br>


</section>
      </article>
    </div>
  </body>
</html>
