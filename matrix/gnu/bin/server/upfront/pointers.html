
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Pointers</title>
    <style type="text/css" media="screen">
      html, body, div, span, object, iframe, h1, h2, h3, h4, h5, h6, p,
      blockquote, pre, a, abbr, address, cite, code, del, dfn, em, figure,
      img, ins, kbd, q, s, samp, small, strong, sub, sup, var, b, u, i, dl,
      dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption,
      tbody, tfoot, thead, tr, th, td {
        background: transparent none repeat scroll 0 0;
        border: 0 none;
        font-size: 100%;
        margin: 0;
        outline: 0 none;
        padding: 0;
        vertical-align: baseline;
      }

      h1 { font-size: 200%; }
      h2 { font-size: 160%; }
      h3 { font-size: 120%; }
      h4 { font-size: 100%; }
      h5 { font-size: 80%; }
      h6 { font-size: 80%; font-weight: normal; }

      ul, ol {
        margin: 1.4em 0;
      }
      ul ul, ol ol, ul ol, ol ul {
        margin-top: 0;
        margin-bottom: 0;
      }
      ul, ol {
        margin-left: 2.8em;
      }

      ol {
        list-style: decimal;
      }
      ol ol {
        list-style: lower-alpha;
      }
      ol ol ol {
        list-style: lower-roman;
      }
      ol ol ol ol {
        list-style: decimal;
      }

      blockquote {
        margin: 0.1em;
        margin-left: 1em;
        border-left: 2px solid #cccccc;
        padding-left: 0.7em;
      }

      .color_red { color: #dc322f; }
      .color_blue { color: #268bd2; }
      .color_green { color: #859901; }
      .color_yellow { color: #b58901; }
      .color_black { color: black; }
      .color_white { color: white; }

      .font_big {
        font-size: 1.2em;
      }

      .ddoc_section_h {
        font-weight: bold;
        font-size: 13px;
        line-height: 19.5px;
        margin-top: 11px;
        display: block;
      }

      body.dlang .dlang {
        display: inline-block;
      }

      body.dlang .declaration .dlang {
          display: block;
      }

      body.dlang .ddoc_header_anchor a.dlang {
        display: block;
        color: rgba(0, 136, 204, 1);
        text-decoration: none;
      }

      body.dlang .ddoc_header_anchor .code {
        color: rgba(0, 136, 204, 1);
      }

      #ddoc_main .module {
          border-color: currentColor rgba(233, 233, 233, 1) rgba(233, 233, 233, 1);
          border-style: none solid solid;
          border-width: 0 1px 1px;
          overflow-x: hidden;
          padding: 15px;
      }

      #ddoc_main .section .section {
        margin-top: 0;
      }

      #ddoc_main .ddoc_module_members_section {
          padding: 1px 0 0;
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .ddoc_member, #ddoc_main .ddoc_module_members section.intro {
          background: #fff none repeat scroll 0 0;
          list-style-type: none;
          width: 100%;
      }

      #ddoc_main .ddoc_header_anchor {
          font-size: 1.4em;
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .ddoc_header_anchor > .code {
          display: inline-block;

      }

      #ddoc_main .ddoc_decl {
        background-color: transparent;
        height: 100%;
        left: 0;
        top: 0;
        padding: 0;
        padding-left: 15px;
      }

      #ddoc_main .ddoc_decl .section, #ddoc_main .section.ddoc_sections {
        background: white none repeat scroll 0 0;
        margin: 0;
        padding: 5px;
        position: relative;
        border-radius: 5px;
      }

      #ddoc_main .ddoc_decl .section h4:first-of-type, #ddoc_main .section.ddoc_sections h4:first-of-type {
        font-size: 13px;
        line-height: 1.5;
        margin-top: 21px;
      }

      #ddoc_main .section .declaration {
          margin-top: 21px;
      }

      #ddoc_main .section .declaration .code {
          color: rgba(0, 0, 0, 1);
          margin-bottom: 15px;
          padding-bottom: 6px;
      }

      #ddoc_main .declaration div .para {
          margin-bottom: 0;
      }

      #ddoc_main .ddoc_params .graybox tr td:first-of-type {
        padding: 7px;
        text-align: right;
        vertical-align: top;
        word-break: normal;
        white-space: nowrap;
      }

      #ddoc_main .ddoc_params .graybox {
        border: 0 none;
      }

      #ddoc_main .ddoc_params .graybox td {
        border-color: rgba(214, 214, 214, 1);
      }

      #ddoc_main .ddoc_params .graybox tr:first-child > td {
        border-top: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr:last-child > td {
        border-bottom: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr > td:first-child {
        border-left: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr > td:last-child {
        border-right: 0 none;
        width: 100%;
      }

      #ddoc_main em.term, #ddoc_main em.term .code {
        color: rgba(65, 65, 65, 1);
        font-size: 12px;
        font-style: italic;
        line-height: 1.5;
      }

      #ddoc_main .see-also {
        cursor: pointer;
        font-family: Menlo,monospace;
      }

      #ddoc_main .ddoc_decl .section > div:last-of-type {
        margin-bottom: 15px;
      }

      #ddoc_main .ddoc_member, #ddoc_main .ddoc_module_members {
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .code_sample {
        background: inherit;
      }

      #ddoc_main .declaration .code-line {
          display: block;
          font: 1em Menlo,monospace;
      }

      #ddoc_main a[name] {
        margin: -112px 0 0;
        padding-top: 112px;
      }

      #ddoc_main .ddoc_decl td {
        max-width: inherit;
      }

      #ddoc_main .declaration a {
        color: inherit;
      }

      #ddoc_main .declaration a:hover {
          color: rgba(0, 136, 204, 1);
          text-decoration: underline;
      }

      body.ddoc {
        background-color: transparent;
        color: rgba(0, 0, 0, 1);
        font-family: Helvetica,Arial,sans-serif;
        font-size: 62.5%;
        margin: 0;
        border: 0;
        left: 0;
        top: 0;
        padding: 0;
      }

      .ddoc a[name] {
        display: block;
        height: 0;
        margin: -85px 0 0;
        padding-top: 85px;
        width: 0;
      }

      .ddoc .module {
          border-color: transparent;
          background-color: rgba(255, 255, 255, 1);
          border-color: currentColor rgba(233, 233, 233, 1) rgba(233, 233, 233, 1);
          border-image: none;
          border-style: none solid solid;
          border-width: 0 1px 1px;
          box-shadow: 0 0 1px rgba(0, 0, 0, 0.07);
          display: block;
          margin-left: 0;
          min-height: calc(100% - 173px);
          overflow: auto;
          padding-bottom: 100px;
      }

      .ddoc .content_wrapper {
          background-color: rgba(242, 242, 242, 1);
          margin: 0 auto;
          max-width: 980px;
      }

      .ddoc .section {
        padding: 15px 25px 30px;
      }

      .ddoc .section .section {
        margin: 30px 0 0;
        padding: 0;
      }

      .ddoc .para {
        color: rgba(65, 65, 65, 1);
        font-size: 1.4em;
        line-height: 145%;
        margin-bottom: 15px;
      }

      .ddoc .ddoc_examples .para {
        margin-bottom: 0;
      }

      .ddoc .module_name {
          color: rgba(0, 0, 0, 1);
          display: block;
          font-family: Helvetica;
          font-size: 2.8em;
          font-weight: 100;
          margin-bottom: 0;
          padding: 15px 0;
      }

      .ddoc .module a {
          color: rgba(0, 136, 204, 1);
          text-decoration: none;
      }

      .ddoc .code {
        color: rgba(128, 128, 128, 1);
        font-family: Menlo,monospace;
        font-size: 0.85em;
        word-wrap: break-word;
      }

      .ddoc .code i {
        font-style: normal;
      }

      .ddoc .code .code {
        font-size: 1em;
      }

      .ddoc .code_sample {
        background-clip: padding-box;
        margin: 1px 0;
        text-align: left;
      }

      .ddoc .code_sample {
        display: block;
        font-size: 1.4em;
        margin-left: 21px;
      }

      .ddoc ol .code_sample {
        font-size: 1em;
      }

      .ddoc .code_lines {
        counter-reset: li;
        line-height: 1.6em;
        list-style: outside none none;
        margin: 0;
        padding: 0;
      }

      .ddoc .code_listing .code_sample div {
        margin-left: 13px;
        width: 93%;
      }

      .ddoc .code_listing .code_sample div .code_lines li {
        list-style-type: none;
        margin: 0;
        padding-right: 10px;
      }

      .ddoc .code_sample div .code_lines li::before {
        margin-left: -33px;
        margin-right: 25px;
      }

      .ddoc .code_sample div .code_lines li:nth-child(n+10)::before {
        margin-left: -39px;
        margin-right: 25px;
      }

      .ddoc .code_sample div .code_lines li:nth-child(n+100)::before {
        margin-left: -46px;
        margin-right: 25px;
      }

      .ddoc .code_sample .code_lines .code {
        color: #000;
      }

      .ddoc div.dlang {
        margin: 10px 0 21px;
        padding: 4px 0 2px 10px;
      }

      .ddoc div.dlang {
          margin: 10px 0 21px;
          padding: 4px 0 2px 10px;
      }

      .ddoc div.dlang {
        border-left: 5px solid rgba(0, 155, 51, 0.2);
      }

      .ddoc .code_lines li::before {
        color: rgba(128, 128, 128, 1);
        content: counter(li, decimal);
        counter-increment: li;
        font-family: Menlo,monospace;
        font-size: 0.9em;
        margin-right: 16px;
      }

      .ddoc .code_lines li {
        padding-left: 0;
        white-space: pre-wrap;
      }

      .ddoc .code_lines li:only-of-type::before {
        color: rgba(255, 255, 255, 1);
        content: " ";
      }

      .ddoc .code_lines li:only-of-type {
        color: rgba(255, 255, 255, 1);
        content: " ";
      }

      .ddoc .code_lines li:nth-child(n+10) {
        text-indent: -17px;
      }

      .ddoc .code_lines li:nth-child(n+10)::before {
        margin-right: 12px;
      }

      .ddoc .graybox {
        border: 1px solid rgba(233, 233, 233, 1);
        border-collapse: collapse;
        border-spacing: 0;
        empty-cells: hide;
        margin: 20px 0 36px;
        text-align: left;
      }

      .ddoc .graybox p {
        margin: 0;
        min-width: 50px;
      }

      .ddoc th {
        margin: 0;
        max-width: 260px;
        padding: 5px 10px 5px 10px;
        vertical-align: bottom;
      }

      .ddoc td {
        border: 1px solid rgba(233, 233, 233, 1);
        margin: 0;
        max-width: 260px;
        padding: 5px 10px 5px 10px;
        vertical-align: middle;
      }

      .punctuation {
        color: rgba(0, 0, 0, 1);
      }

      .comment {
        color: rgba(0, 131, 18, 1);
      }

      .operator {
        color: #000;
      }

      .keyword {
        color: rgba(170, 13, 145, 1);
      }

      .keyword_type {
        color: rgba(170, 51, 145, 1);
      }

      .string_literal {
        color: rgba(196, 26, 22, 1);
      }

      .ddoc_psuper_symbol {
        color: rgba(92, 38, 153, 1);
      }

      .param {
        color: rgba(0, 0, 0, 1);
      }

      .psymbol {
        color: rgba(0, 0, 0, 1);
      }

      .ddoc_member_header .ddoc_header_anchor .code {
        font-size: 1em;
      }
    </style>
  </head>
  <body id="ddoc_main" class="ddoc dlang">
    <div class="content_wrapper">
      <article class="module">
        <h1 class="module_name">Pointers</h1>
        <section id="module_content"><br><br>
<br><br>

<br><br>
<p>Pointers are variables that provide access to other variables. The value of a pointer is the address of the variable that it provides access to.
</p>
<br><br>
<p>Pointers can point at any type of variable, object, and even other pointers. In this chapter, I will refer to all of these simply as <i>variables</i>.
</p>
<br><br>
<p>Pointers are low level features of microprocessors. They are an important part of system programming.
</p>
<br><br>
<p>The syntax and semantics of pointers in D are inherited directly from C. Although pointers are notoriously the most difficult feature of C to comprehend, they should not be as difficult in D. This is because other features of D that are semantically close to pointers are more useful in situations where pointers would have to be used in other languages. When the ideas behind pointers are already understood from those other features of D, pointers should be easier to grasp.
</p>
<br><br>
<p>The short examples throughout the most of this chapter are decidedly simple. The programs at the end of the chapter will be more realistic.
</p>
<br><br>
<p>The names like  (short for "pointer") that I have used in these examples should not be considered as useful names in general. As always, names must be chosen to be more meaningful and explanatory in actual programs.
</p>
<br><br>
<h5> The concept of a reference</h5>
<br><br>
<p>Although we have encountered references many times in the previous chapters, let's summarize this concept one more time.
</p>
<br><br>
<h6>The  variables in  loops</h6>
<br><br>
<p>As we have seen in <a href="foreach.html">the  Loop chapter</a>, normally the loop variables are <i>copies</i> of elements:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;

<span class="keyword">void</span> main() {
    <span class="keyword">int</span>[] numbers = [ 1, 11, 111 ];

    <span class="keyword">foreach</span> (number; numbers) {
        number = 0;     <span class="comment">// ← the copy changes, not the element
</span>    }

    writeln(<span class="string_literal">"After the loop: "</span>, numbers);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The  that gets assigned 0 each time is a copy of one of the elements of the array. Modifying that copy does not modify the element:
</p>
<br><br>

<br><br>
<p>When the actual elements need to be modified, the  variable must be defined as :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">foreach</span> ( number; numbers) {
        number = 0;     <span class="comment">// ← the actual element changes
</span>    }
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>This time  is a reference to an actual element in the array:
</p>
<br><br>

<br><br>
<h6> function parameters</h6>
<br><br>
<p>As we have seen in <a href="function_parameters.html">the Function Parameters chapter</a>, the parameters of <i>value types</i> are normally copies of the arguments:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;

<span class="keyword">void</span> addHalf(<span class="keyword">double</span> value) {
    value += 0.5;        <span class="comment">// ← Does not affect 'value' in main
</span>}

<span class="keyword">void</span> main() {
    <span class="keyword">double</span> value = 1.5;

    addHalf(value);

    writeln(<span class="string_literal">"The value after calling the function: "</span>, value);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Because the function parameter is not defined as , the assignment inside the function affects only the local variable there. The variable in  is not affected:
</p>
<br><br>

<br><br>
<p>The  keyword would make the function parameter a reference to the argument:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">void</span> addHalf( <span class="keyword">double</span> value) {
    value += 0.5;
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>This time the variable in  gets modified:
</p>
<br><br>

<br><br>
<h6>Reference types</h6>
<br><br>
<p>Some types are reference types. Variables of such types provide access to separate variables:
</p>
<br><br>
<ul><li>Class variables</li>
<li>Slices</li>
<li>Associative arrays</li>
</ul>
<br><br>
<p>We have seen this distinction in <a href="value_vs_reference.html">the Value Types and Reference Types chapter</a>. The following example demonstrates reference types by two  variables:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;

<span class="keyword">class</span> Pen {
    <span class="keyword">double</span> ink;

    <span class="keyword">this</span>() {
        ink = 15;
    }

    <span class="keyword">void</span> use(<span class="keyword">double</span> amount) {
        ink -= amount;
    }
}

<span class="keyword">void</span> main() {
    <span class="keyword">auto</span> pen = <span class="keyword">new</span> Pen;
    <span class="keyword">auto</span> otherPen = pen;  <span class="comment">// ← Now both variables provide
</span>                          <span class="comment">//   access to the same object
</span>
    writefln(<span class="string_literal">"Before: %s %s"</span>, pen.ink, otherPen.ink);

    pen.use(1);          <span class="comment">// ← the same object is used
</span>    otherPen.use(2);     <span class="comment">// ← the same object is used
</span>
    writefln(<span class="string_literal">"After : %s %s"</span>, pen.ink, otherPen.ink);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Because classes are reference types, the class variables  and  provide access to the same  object. As a result, using either of those class variables affects the same object:
</p>
<br><br>

<br><br>
<p>That single object and the two class variables would be laid out in memory similar to the following figure:
</p>
<br><br>

<br><br>
<p>References <i>point at</i> actual variables as  and  do above.
</p>
<br><br>
<p>Programming languages implement the reference and pointer concepts by special registers of the microprocessor, which are specifically for <i>pointing at</i> memory locations.
</p>
<br><br>
<p>Behind the scenes, D's higher-level concepts (class variables, slices, associative arrays, etc.) are all implemented by pointers. As these higher-level features are already efficient and convenient, pointers are rarely needed in D programming. Still, it is important for D programmers to understand pointers well.
</p>
<br><br>
<h5> Syntax</h5>
<br><br>
<p>The pointer syntax of D is mostly the same as in C. Although this can be seen as an advantage, the peculiarities of C's pointer syntax are necessarily inherited by D as well. For example, the different meanings of the  character may be confusing.
</p>
<br><br>
<p>With the exception of  pointers, every pointer is associated with a certain type and can point at only variables of that specific type. For example, an  pointer can only point at variables of type .
</p>
<br><br>
<p>The pointer definition syntax consists of the associated type and a  character:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <i><span class="keyword">type_to_point_at</span></i> * <i>name_of_the_pointer_variable</i>;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Accordingly, a pointer variable that would be pointing at  variables would be defined like this:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span> * myPointer;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The  character in that syntax may be pronounced as "pointer". So, the type of  above is an "int pointer". The spaces before and after the  character are optional. The following syntaxes are common as well:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span>* myPointer;
    <span class="keyword">int</span> *myPointer;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>When it is specifically a pointer type that is being mentioned as in "int pointer", it is common to write the type without any spaces as in .
</p>
<br><br>
<h5> Pointer value and the address-of operator&nbsp;</h5>
<br><br>
<p>Being variables themselves pointers have values as well. The default value of a pointer is the special value , which means that the pointer is not <i>pointing at</i> any variable yet (i.e. does not provide access to any variable).
</p>
<br><br>
<p>To make a pointer provide access to a variable, the value of the pointer must be set to the address of that variable. The pointer starts pointing at the variable that is at that specific address. From now on, I will call that variable <i>the pointee</i>.
</p>
<br><br>
<p>The  operator which we have used many times before with  has also been briefly mentioned in <a href="value_vs_reference.html">the Value Types and Reference Types chapter</a>. This operator produces the address of the variable that is written after it. Its value can be used when initializing a pointer:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span> myVariable = 180;
    <span class="keyword">int</span> * myPointer = myVariable;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Initializing  by the address of  makes  point at .
</p>
<br><br>
<p>The value of the pointer is the same as the address of :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    writeln(<span class="string_literal">"The address of myVariable: "</span>, &amp;myVariable);
    writeln(<span class="string_literal">"The value of myPointer   : "</span>, myPointer);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>

<br><br>
<p><i><b>Note:</b> The address value is likely to be different every time the program is started.</i>
</p>
<br><br>
<p>The following figure is a representation of these two variables in memory:
</p>
<br><br>

<br><br>
<p>The value of  is the address of , conceptually <i>pointing at</i> the variable that is at that location.
</p>
<br><br>
<p>Since pointers are variables as well, the  operator can produce the address of the  pointer as well:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    writeln(<span class="string_literal">"The address of myPointer : "</span>, &amp;myPointer);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>

<br><br>
<p>Since the difference between the two addresses above is 8, remembering that an  takes up 4 bytes, we can deduce that  and  are 4 bytes apart in memory.
</p>
<br><br>
<p>After removing the arrow that represented the concept of <i>pointing at</i>, we can picture the contents of memory around these addresses like this:
</p>
<br><br>

<br><br>
<p>The names of variables, functions, classes, etc. and keywords are not parts of programs of compiled languages like D. The variables that have been defined by the programmer in the source code are converted to bytes that occupy memory or registers of the microprocessor.
</p>
<br><br>
<p><i><b>Note:</b> The names (a.k.a. symbols) may actually be included in programs to help with debugging but those names do not affect the operation of the program.</i>
</p>
<br><br>
<h5> The access operator&nbsp;</h5>
<br><br>
<p>We have seen above that the  character which normally represents multiplication is also used when defining pointers. A difficulty with the syntax of pointers is that the same character has a third meaning: It is also used when accessing the pointee through the pointer.
</p>
<br><br>
<p>When it is written before the name of a pointer, it means <i>the variable that the pointer is pointing at</i> (i.e. the pointee):
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    writeln(<span class="string_literal">"The value that it is pointing at: "</span>, myPointer);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>

<br><br>
<h5> The  (dot) operator to access a member of the pointee</h5>
<br><br>
<p>If you know pointers from C, this operator is the same as the  operator in that language.
</p>
<br><br>
<p>We have seen above that the  operator is used for accessing the pointee. That is sufficiently useful for pointers of fundamental types like : The value of a fundamental type is accessed simply by writing .
</p>
<br><br>
<p>However, when the pointee is a struct or a class object, the same syntax becomes inconvenient. To see why, let's consider the following struct:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> Coordinate {
    <span class="keyword">int</span> x;
    <span class="keyword">int</span> y;

    string toString() <span class="keyword">const</span> {
        <span class="keyword">return</span> format(<span class="string_literal">"(%s,%s)"</span>, x, y);
    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The following code defines an object and a pointer of that type:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">auto</span> center = Coordinate(0, 0);
    Coordinate * ptr = center;    <span class="comment">// pointer definition
</span>    writeln(ptr);                 <span class="comment">// object access
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>That syntax is convenient when accessing the value of the entire  object:
</p>
<br><br>

<br><br>
<p>However, the code becomes complicated when accessing a member of an object through a pointer and the  operator:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="comment">// Adjust the x coordinate
</span>    (*ptr).x += 10;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>That expression modifies the value of the  member of the  object. The left-hand side of that expression can be explained by the following steps:
</p>
<br><br>
<ul><li>: The pointer that points at </li>
<br><br>
<li>: Accessing the object (i.e.  itself)</li>
<br><br>
<li>: Parentheses so that the  (dot) operator is applied to the object, not to the pointer</li>
<br><br>
<li>: The  member of the object that  is pointing at</li>
<br><br>
</ul>
<br><br>
<p>To reduce the complexity of pointer syntax in D, the  (dot) operator is transferred to the pointee and provides access to the member of the object. (The exceptions to this rule are at the end of this section.)
</p>
<br><br>
<p>So, the previous expression is normally written as:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">     += 10;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Since the pointer itself does not have a member named ,  is applied to the pointee and the  member of  gets modified:
</p>
<br><br>

<br><br>
<p>Note that this is the same as the use of the  (dot) operator with classes. When the  (dot) operator is applied to a class <i>variable</i>, it provides access to a member of the class <i>object</i>:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">class</span> ClassType {
    <span class="keyword">int</span> member;
}

<span class="comment">// ...
</span>
    <span class="comment">// Variable on the left, object on the right
</span>    ClassType variable = <span class="keyword">new</span> ClassType;

    <span class="comment">// Applied to the variable but accesses the member of
</span>    <span class="comment">// the object
</span>    variable.member = 42;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>As you remember from <a href="class.html">the Classes chapter</a>, the class object is constructed by the  keyword on the right-hand side.  is a class variable that provides access to it.
</p>
<br><br>
<p>Realizing that it is the same with pointers is an indication that class variables and pointers are implemented similarly by the compiler.
</p>
<br><br>
<p>There is an exception to this rule both for class variables and for pointers. Type properties like  are applied to the type of the pointer, not to the type of the pointee:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">char</span> c;
    <span class="keyword">char</span> * p = &amp;c;

    writeln(p.sizeof);  <span class="comment">// size of the pointer, not the pointee
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p> produces the size of , which is a , not the size of , which is a . On a 64-bit system pointers are 8-byte long:
</p>
<br><br>

<br><br>
<h5> Modifying the value of a pointer</h5>
<br><br>
<p>The values of pointers can be incremented or decremented and they can be used in addition and subtraction:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    ++ptr;
    --ptr;
    ptr += 2;
    ptr -= 2;
    writeln(ptr + 3);
    writeln(ptr - 3);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Different from their arithmetic counterparts, these operations do not modify the actual value by the specified amount. Rather, the value of the pointer gets modified so that it now points at the variable that is a certain number of variables beyond the current one. The amount of the increment or the decrement specifies <i>how many variables away</i> should the pointer now point at.
</p>
<br><br>
<p>For example, incrementing the value of a pointer makes it point at the next variable:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    ++ptr;  <span class="comment">// Starts pointing at a variable that is next in
</span>            <span class="comment">// memory from the old variable
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>For that to work correctly, the actual value of the pointer must be incremented by the size of the variable. For example, because the size of  is 4, incrementing a pointer of type  changes its value by 4. The programmer need not pay attention to this detail; the pointer value is modified by the correct amount automatically.
</p>
<br><br>
<p><b>Warning</b>: It is undefined behavior to point at a location that is not a valid byte that belongs to the program. Even if it is not actually used to access any variable there, it is invalid for a pointer to point at a nonexistent variable. (The only exception to this rule is that it is valid to point at the imaginary element one past the end of an array. This will be explained later below.)
</p>
<br><br>
<p>For example, it is invalid to increment a pointer that points at , because  is defined as a single :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    ++myPointer;       
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Undefined behavior means that it cannot be known what the behavior of the program will be after that operation. There may be systems where the program crashes after incrementing that pointer. However, on most modern systems the pointer is likely to point at the unused memory location that has been shown as being between  and  in the previous figure.
</p>
<br><br>
<p>For that reason, the value of a pointer must be incremented or decremented only if there is a valid object at the new location. (As we will see below, pointing at the element one past the end of an array is valid as well). Arrays (and slices) have that property: The elements of an array are side by side in memory.
</p>
<br><br>
<p>A pointer that is pointing at an element of a slice can be incremented safely as long as it is not used to access an element beyond the end of the slice. Incrementing such a pointer by the  operator makes it point at the next element:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;
<span class="keyword">import</span> std.string;
<span class="keyword">import</span> std.conv;

<span class="keyword">enum</span> Color { red, yellow, blue }

<span class="keyword">struct</span> Crayon {
    Color color;
    <span class="keyword">double</span> length;

    string toString() <span class="keyword">const</span> {
        <span class="keyword">return</span> format(<span class="string_literal">"%scm %s crayon"</span>, length, color);
    }
}

<span class="keyword">void</span> main() {
    writefln(<span class="string_literal">"Crayon objects are %s bytes each."</span>, Crayon.sizeof);

    Crayon[] crayons = [ Crayon(Color.red, 11),
                         Crayon(Color.yellow, 12),
                         Crayon(Color.blue, 13) ];

     = crayons[0];                   <span class="comment">// (1)
</span>
    <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i != crayons.length; ++i) {
        writeln(<span class="string_literal">"Pointer value: "</span>, );          <span class="comment">// (2)
</span>
        writeln(<span class="string_literal">"Crayon: "</span>, );                <span class="comment">// (3)
</span>        ;                                    <span class="comment">// (4)
</span>    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<ol><li>Definition: The pointer is initialized by the address of the first element.</li>
<li>Using its value: The value of the pointer is the address of the element that it is pointing at.</li>
<li>Accessing the element that is being pointed at.</li>
<li>Pointing at the next element.</li>
</ol>
<br><br>
<p>The output:
</p>
<br><br>

<br><br>
<p>Note that the loop above is iterated a total of  times so that the pointer is always used for accessing a valid element.
</p>
<br><br>
<h5>Pointers are risky</h5>
<br><br>
<p>The compiler and the D runtime environment cannot guarantee that the pointers are always used correctly. It is the programmer's responsibility to ensure that a pointer is either  or points at a valid memory location (at a variable, at an element of an array, etc.).
</p>
<br><br>
<p>For that reason, it is always better to consider higher-level features of D before thinking about using pointers.
</p>
<br><br>
<h5> The element one past the end of an array</h5>
<br><br>
<p>It is valid to point at the imaginary element one past the end of an array.
</p>
<br><br>
<p>This is a useful idiom that is similar to number ranges. When defining a slice with a number range, the second index is one past the elements of the slice:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span>[] values = [ 0, 1, 2, 3 ];
    writeln(values[1 .. 3]);   <span class="comment">// 1 and 2 included, 3 excluded
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>This idiom can be used with pointers as well. It is a common function design in C and C++ where a function parameter points at the first element and another one points at the element after the last element:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;

<span class="keyword">void</span> tenTimes(<span class="keyword">int</span> * begin, <span class="keyword">int</span> * end) {
    <span class="keyword">while</span> (begin != end) {
        *begin *= 10;
        ++begin;
    }
}

<span class="keyword">void</span> main() {
    <span class="keyword">int</span>[] values = [ 0, 1, 2, 3 ];

    <span class="comment">// The address of the second element:
</span>    <span class="keyword">int</span> * begin = &amp;values[1];

    <span class="comment">// The address of two elements beyond that one
</span>    tenTimes(begin, begin + 2);

    writeln(values);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The value  means two elements after the one that  is pointing at (i.e. the element at index 3).
</p>
<br><br>
<p>The  function takes two pointer parameters. It uses the element that the first one is pointing at but it never accesses the element that the second one is pointing at. As a result, only the elements at indexes 1 and 2 get modified:
</p>
<br><br>

<br><br>
<p>Such functions can be implemented by a  loop as well:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">for</span> ( ; begin != end; ++begin) {
        *begin *= 10;
    }
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Two pointers that define a range can also be used with  loops:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">foreach</span> (ptr; begin .. end) {
        *ptr *= 10;
    }
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>For these methods to be applicable to <i>all of the elements</i> of a slice, the second pointer must necessarily point after the last element:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="comment">// The second pointer is pointing at the imaginary element
</span>    <span class="comment">// past the end of the array:
</span>    tenTimes(begin, begin + values.length);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>That is the reason why it is legal to point at the imaginary element one beyond the last element of an array.
</p>
<br><br>
<h5> Using pointers with the array indexing operator </h5>
<br><br>
<p>Although it is not absolutely necessary in D, pointers can directly be used for accessing the elements of an array by an index value:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">double</span>[] floats = [ 0.0, 1.1, 2.2, 3.3, 4.4 ];

    <span class="keyword">double</span> * ptr = &amp;floats[2];

    *ptr = -100;      <span class="comment">// direct access to what it points at
</span>    ptr = -200;    <span class="comment">// access by indexing
</span>
    writeln(floats);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The output:
</p>
<br><br>

<br><br>
<p>In that syntax, the element that the pointer is pointing at is thought of being the first element of an imaginary slice. The  operator provides access to the specified element of that slice. The  above initially points at the element at index 2 of the original  slice.  is a reference to the element 1 of the imaginary slice that starts at  (i.e. index 3 of the original slice).
</p>
<br><br>
<p>Although this behavior may seem complicated, there is a very simple conversion behind that syntax. Behind the scenes, the compiler converts the  syntax to the  expression:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    ptr[1] = -200;      <span class="comment">// slice syntax
</span>    *(ptr + 1) = -200;  <span class="comment">// the equivalent of the previous line
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>As I have mentioned earlier, the compiler may not guarantee that this expression refers to a valid element. D's slices provide a much safer alternative and should be considered instead:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">double</span>[] slice = floats[2 .. 4];
    slice[0] = -100;
    slice[1] = -200;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Normally, index values are checked for slices at run time:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    slice[2] = -300;  <span class="comment">// Runtime error: accessing outside of the slice
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Because the slice above does not have an element at index 2, an exception would be thrown at run time (unless the program has been compiled with the  compiler switch):
</p>
<br><br>

<br><br>
<h5> Producing a slice from a pointer</h5>
<br><br>
<p>Pointers are not as safe or as useful as slices because although they can be used with the slice indexing operator, they are not aware of the valid range of elements.
</p>
<br><br>
<p>However, when the number of valid elements is known, a pointer can be used to construct a slice.
</p>
<br><br>
<p>Let's assume that the  function below is inside a C library. Let's assume that  makes specified number of  objects and returns a pointer to the first one of those objects:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    Struct * ptr = makeObjects(10);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The syntax that produces a slice from a pointer is the following:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="comment">/* ... */</span> slice = pointer[0 .. count];
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Accordingly, a slice to the 10 objects that are returned by  can be constructed by the following code:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    Struct[] slice = ptr[0 .. 10];
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>After that definition,  is ready to be used safely in the program just like any other slice:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    writeln(slice[1]);    <span class="comment">// prints the second element
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<h5>  can point at any type</h5>
<br><br>
<p>Although it is almost never needed in D, C's special pointer type  is available in D as well.  can point at any type:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span> number = 42;
    <span class="keyword">double</span> otherNumber = 1.25;
    <span class="keyword">void</span> * canPointAtAnything;

    canPointAtAnything = &amp;number;
    canPointAtAnything = &amp;otherNumber;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The  above is able to point at variables of two different types:  and .
</p>
<br><br>
<p> pointers are limited in functionality. As a consequence of their flexibility, they cannot provide access to the pointee. When the actual type is unknown, its size is not known either:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    *canPointAtAnything = 43;     
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Instead, its value must first be converted to a pointer of the correct type:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span> number = 42;                                  <span class="comment">// (1)
</span>    <span class="keyword">void</span> * canPointAtAnything = &amp;number;              <span class="comment">// (2)
</span>
    <span class="comment">// ...
</span>
    <span class="keyword">int</span> * intPointer = <span class="keyword">cast</span>(<span class="keyword">int</span>*)canPointAtAnything;  <span class="comment">// (3)
</span>    *intPointer = 43;                                 <span class="comment">// (4)
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<ol><li>The actual variable</li>
<li>Storing the address of the variable in a </li>
<li>Assigning that address to a pointer of the correct type</li>
<li>Modifying the variable through the new pointer</li>
</ol>
<br><br>
<p>It is possible to increment or decrement values of  pointers, in which case their values are modified as if they are pointers of 1-byte types like :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    ++canPointAtAnything;    <span class="comment">// incremented by 1
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p> is sometimes needed when interacting with libraries that are written in C. Since C does not have higher level features like interfaces, classes, templates, etc. C libraries must rely on the  type.
</p>
<br><br>
<h5>Using pointers in logical expressions</h5>
<br><br>
<p>Pointers can automatically be converted to . Pointers that have the value  produce  and the others produce . In other words, pointers that do not point at any variable are .
</p>
<br><br>
<p>Let's consider a function that prints objects to the standard output. Let's design this function so that it also provides the number of bytes that it has just output. However, let's have it produce this information only when specifically requested.
</p>
<br><br>
<p>It is possible to make this behavior optional by checking whether the value of a pointer is  or not:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">void</span> print(Crayon crayon, size_t * numberOfBytes) {
    <span class="keyword">immutable</span> info = format(<span class="string_literal">"Crayon: %s"</span>, crayon);
    writeln(info);

     {
        *numberOfBytes = info.length;
    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>When the caller does not need this special information, they can pass  as the argument:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    print(Crayon(Color.yellow, 7), );
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>When the number of bytes is indeed important, then a non- pointer value must be passed:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    size_t numberOfBytes;
    print(Crayon(Color.blue, 8), );
    writefln(<span class="string_literal">"%s bytes written to the output"</span>, numberOfBytes);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Note that this is just an example. Otherwise, it would be better for a function like  to return the number of bytes unconditionally:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">size_t print(Crayon crayon) {
    <span class="keyword">immutable</span> info = format(<span class="string_literal">"Crayon: %s"</span>, crayon);
    writeln(info);

    <span class="keyword">return</span> info.length;
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<h5>  returns a pointer for some types</h5>
<br><br>
<p>, which we have been using only for constructing class objects can be used with other types as well: structs, arrays, and fundamental types. The variables that are constructed by  are called dynamic variables.
</p>
<br><br>
<p> first allocates space from the memory for the variable and then constructs the variable in that space. The variable itself does not have a symbolic name in the compiled program; it would be accessed through the reference that is returned by .
</p>
<br><br>
<p>The reference that  returns is a different kind depending on the type of the variable:
</p>
<br><br>
<ul><br><br>
<li>For class objects, it is a <i>class variable</i>:
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    Class classVariable = <span class="keyword">new</span> Class;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
</li>
<br><br>
<li>For struct objects and variables of fundamental types, it is a <i>pointer</i>:
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    Struct  structPointer = <span class="keyword">new</span> Struct;
    <span class="keyword">int</span>  intPointer = <span class="keyword">new</span> <span class="keyword">int</span>;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
</li>
<br><br>
<li>For arrays, it is a <i>slice</i>:
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span>[] slice = <span class="keyword">new</span> <span class="keyword">int</span>[100];
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
</li>
<br><br>
</ul>
<br><br>
<p>This distinction is usually not obvious when the type is not spelled-out on the left-hand side:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">auto</span> classVariable = <span class="keyword">new</span> Class;
    <span class="keyword">auto</span> structPointer = <span class="keyword">new</span> Struct;
    <span class="keyword">auto</span> intPointer = <span class="keyword">new</span> <span class="keyword">int</span>;
    <span class="keyword">auto</span> slice = <span class="keyword">new</span> <span class="keyword">int</span>[100];
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The following program prints the return type of  for different kinds of variables:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;

<span class="keyword">struct</span> Struct {
}

<span class="keyword">class</span> Class {
}

<span class="keyword">void</span> main() {
    writeln(<span class="keyword">typeof</span>(<span class="keyword">new</span> <span class="keyword">int</span>   ).stringof);
    writeln(<span class="keyword">typeof</span>(<span class="keyword">new</span> <span class="keyword">int</span>[5]).stringof);
    writeln(<span class="keyword">typeof</span>(<span class="keyword">new</span> Struct).stringof);
    writeln(<span class="keyword">typeof</span>(<span class="keyword">new</span> Class ).stringof);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p> returns pointers for structs and fundamental types:
</p>
<br><br>

<br><br>
<p>When  is used for constructing a dynamic variable of a <a href="value_vs_reference.html">value type</a>, then the lifetime of that variable is extended as long as there is still a reference (e.g. a pointer) to that object in the program. (This is the default situation for reference types.)
</p>
<br><br>
<h5>  The  property of arrays</h5>
<br><br>
<p>The  property of arrays and slices is the address of the first element. The type of this value is a pointer to the type of the elements:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span>[] numbers = [ 7, 12 ];

    <span class="keyword">int</span> * addressOfFirstElement = numbers;
    writeln(<span class="string_literal">"First element: "</span>, *addressOfFirstElement);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>This property is useful especially when interacting with C libraries. Some C functions take the address of the first of a number of consecutive elements in memory.
</p>
<br><br>
<p>Remembering that strings are also arrays, the  property can be used with strings as well. However, note that the first element of a string need not be the first <i>letter</i> of the string; rather, the first Unicode code unit of that letter. As an example, the letter é is stored as two code units in a  string.
</p>
<br><br>
<p>When accessed through the  property, the code units of strings can be accessed individually. We will see this in the examples section below.
</p>
<br><br>
<h5> The  operator of associative arrays</h5>
<br><br>
<p>Actually, we have used pointers earlier in <a href="aa.html">the Associative Arrays chapter</a>. In that chapter, I had intentionally not mentioned the exact type of the  operator and had used it only in logical expressions:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">if</span> (<span class="string_literal">"purple"</span> <span class="keyword">in</span> colorCodes) {
        <span class="comment">// there is an element for key "purple"
</span>
    } <span class="keyword">else</span> {
        <span class="comment">// no element for key "purple"
</span>    }
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>In fact, the  operator returns the address of the element if there is an element for the specified key; otherwise, it returns . The  statement above actually relies on the automatic conversion of the pointer value to .
</p>
<br><br>
<p>When the return value of  is stored in a pointer, the element can be accessed efficiently through that pointer:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;

<span class="keyword">void</span> main() {
    string[<span class="keyword">int</span>] numbers =
        [ 0 : <span class="string_literal">"zero"</span>, 1 : <span class="string_literal">"one"</span>, 2 : <span class="string_literal">"two"</span>, 3 : <span class="string_literal">"three"</span> ];

    <span class="keyword">int</span> number = 2;
    <span class="keyword">auto</span>  = number <span class="keyword">in</span> numbers;             <span class="comment">// (1)
</span>
    <span class="keyword">if</span> () {                                <span class="comment">// (2)
</span>        writefln(<span class="string_literal">"I know: %s."</span>, );        <span class="comment">// (3)
</span>
    } <span class="keyword">else</span> {
        writefln(<span class="string_literal">"I don't know the spelling of %s."</span>, number);
    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The pointer variable  is initialized by the value of the  operator (1) and its value is used in a logical expression (2). The value of the element is accessed through that pointer (3) only if the pointer is not .
</p>
<br><br>
<p>The actual type of  above is a pointer to the same type of the elements (i.e. values) of the associative array. Since the elements of  above are of type ,  returns a . Accordingly, the type could have been spelled out explicitly:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">     element = number <span class="keyword">in</span> numbers;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<h5>When to use pointers</h5>
<br><br>
<p>Pointers are rare in D. As we have seen in <a href="input.html">the Reading from the Standard Input chapter</a>,  can in fact be used without explicit pointers.
</p>
<br><br>
<h6>When required by libraries</h6>
<br><br>
<p>Pointers can appear on C and C++ library bindings. For example, the following function from the GtkD library takes a pointer:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    GdkGeometry geometry;
    <span class="comment">// ... set the members of 'geometry' ...
</span>
    window.setGeometryHints(<span class="comment">/* ... */</span>, geometry, <span class="comment">/* ... */</span>);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<h6>When referencing variables of value types</h6>
<br><br>
<p>Pointers can be used for referring to local variables. The following program counts the outcomes of flipping a coin. It takes advantage of a pointer when referring to one of two local variables:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;
<span class="keyword">import</span> std.random;

<span class="keyword">void</span> main() {
    size_t headsCount = 0;
    size_t tailsCount = 0;

    <span class="keyword">foreach</span> (i; 0 .. 100) {
        size_t * theCounter = (uniform(0, 2) == 1)
                               ? &amp;headsCount
                               : &amp;tailsCount;
        ++(*theCounter);
    }

    writefln(<span class="string_literal">"heads: %s  tails: %s"</span>, headsCount, tailsCount);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Obviously, there are other ways of achieving the same goal. For example, using the ternary operator in a different way:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">        uniform(0, 2) ? ++headsCount : ++tailsCount;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>By using an  statement:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">        <span class="keyword">if</span> (uniform(0, 2)) {
            ++headsCount;

        } <span class="keyword">else</span> {
            ++tailsCount;
        }
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<h6>As member variables of data structures</h6>
<br><br>
<p>Pointers are essential when implementing many data structures.
</p>
<br><br>
<p>Unlike the elements of an array being next to each other in memory, elements of many other data structures are apart. Such data structures are based on the concept of their elements <i>pointing at</i> other elements.
</p>
<br><br>
<p>For example, each node of a linked list <i>points at</i> the next node. Similarly, each node of a binary tree <i>points at</i> the left and right branches under that node. Pointers are encountered in most other data structures as well.
</p>
<br><br>
<p>Although it is possible to take advantage of D's reference types, pointers may be more natural and efficient in some cases.
</p>
<br><br>
<p>We will see examples of pointer members below.
</p>
<br><br>
<h6>When accessing memory directly</h6>
<br><br>
<p>Being low-level microprocessor features, pointers provide byte-level access to memory locations. Note that such locations must still belong to valid variables. It is undefined behavior to attempt to access a random memory location.
</p>
<br><br>
<h5>Examples</h5>
<br><br>
<h6>A simple linked list</h6>
<br><br>
<p>The elements of linked lists are stored in <i>nodes</i>. The concept of a linked list is based on each node pointing at the node that comes after it. The last node has no other node to point at, so it is set to :
</p>
<br><br>

<br><br>
<p>The figure above may be misleading: In reality, the nodes are not side-by-side in memory. Each node does point to the next node but the next node may be at a completely different location.
</p>
<br><br>
<p>The following  can be used for representing the nodes of such a linked list of s:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> Node {
    <span class="keyword">int</span> element;
    Node * next;

    <span class="comment">// ...
</span>}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p><i><b>Note:</b> Because it contains a reference to the same type as itself,  is a  recursive type.</i>
</p>
<br><br>
<p>The entire list can be represented by a single pointer that points at the first node, which is commonly called <i>the head</i>:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> List {
    Node * head;

    <span class="comment">// ...
</span>}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>To keep the example short, let's define just one function that adds an element to the head of the list:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> List {
    Node * head;

    <span class="keyword">void</span> insertAtHead(<span class="keyword">int</span> element) {
        head = <span class="keyword">new</span> Node(element, head);
    }

    <span class="comment">// ...
</span>}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The line inside  keeps the nodes <i>linked</i> by adding a new node to the head of the list. (A function that adds to the end of the list would be more natural and more useful. We will see that function later in one of the problems.)
</p>
<br><br>
<p>The right-hand side expression of that line constructs a  object. When this new object is constructed, its  member is initialized by the current head of the list. When the  member of the list is assigned to this newly linked node, the new element ends up being the first element.
</p>
<br><br>
<p>The following program tests these two structs:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;
<span class="keyword">import</span> std.conv;
<span class="keyword">import</span> std.string;

<span class="keyword">struct</span> Node {
    <span class="keyword">int</span> element;
    Node * next;

    string toString() <span class="keyword">const</span> {
        string result = to!string(element);

        <span class="keyword">if</span> (next) {
            result ~= <span class="string_literal">" -&gt; "</span> ~ to!string(*next);
        }

        <span class="keyword">return</span> result;
    }
}

<span class="keyword">struct</span> List {
    Node * head;

    <span class="keyword">void</span> insertAtHead(<span class="keyword">int</span> element) {
        head = <span class="keyword">new</span> Node(element, head);
    }

    string toString() <span class="keyword">const</span> {
        <span class="keyword">return</span> format(<span class="string_literal">"(%s)"</span>, head ? to!string(*head) : <span class="string_literal">""</span>);
    }
}

<span class="keyword">void</span> main() {
    List numbers;

    writeln(<span class="string_literal">"before: "</span>, numbers);

    <span class="keyword">foreach</span> (number; 0 .. 10) {
        numbers.insertAtHead(number);
    }

    writeln(<span class="string_literal">"after : "</span>, numbers);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The output:
</p>
<br><br>

<br><br>
<h6> Observing the contents of memory by </h6>
<br><br>
<p>The data stored at each memory address is a byte. Every variable is constructed on a piece of memory that consists of as many bytes as the size of the type of that variable.
</p>
<br><br>
<p>A suitable pointer type to observe the content of a memory location is . Once the address of a variable is assigned to a  pointer, then all of the bytes of that variable can be observed by incrementing the pointer.
</p>
<br><br>
<p>Let's consider the following integer that is initialized by the hexadecimal notation so that it will be easy to understand how its bytes are placed in memory:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span> variable = 0x01_02_03_04;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>A pointer that points at that variable can be defined like this:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span> * address = &amp;variable;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The value of that pointer can be assigned to a  pointer by the  operator:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">ubyte</span> * bytePointer = <span class="keyword">cast</span>(<span class="keyword">ubyte</span>*)address;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Such a pointer allows accessing the four bytes of the  variable individually:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    writeln(bytePointer[0]);
    writeln(bytePointer[1]);
    writeln(bytePointer[2]);
    writeln(bytePointer[3]);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>If your microprocessor is <i>little-endian</i> like mine, you should see the bytes of the value  in reverse:
</p>
<br><br>

<br><br>
<p>Let's use that idea in a function that will be useful when observing the bytes of all types of variables:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;

<span class="keyword">void</span> printBytes(T)(<span class="keyword">ref</span> T variable) {
    <span class="keyword">const</span> <span class="keyword">ubyte</span> * begin = <span class="keyword">cast</span>(<span class="keyword">ubyte</span>*)&amp;variable;    <span class="comment">// (1)
</span>
    writefln(<span class="string_literal">"type   : %s"</span>, T.stringof);
    writefln(<span class="string_literal">"value  : %s"</span>, variable);
    writefln(<span class="string_literal">"address: %s"</span>, begin);                 <span class="comment">// (2)
</span>    writef  (<span class="string_literal">"bytes  : "</span>);

    writefln(<span class="string_literal">"%(%02x %)"</span>, begin[0 .. T.sizeof]);    <span class="comment">// (3)
</span>
    writeln();
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<ol><li>Assigning the address of the variable to a  pointer.</li>
<li>Printing the value of the pointer.</li>
<li>Obtaining the size of the type by  and printing the bytes of the variable. (Note how a slice is produced from the  pointer and then that slice is printed directly by .)</li>
</ol>
<br><br>
<p>Another way of printing the bytes would be to apply the  operator individually:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">foreach</span> (bytePointer; begin .. begin + T.sizeof) {
        writef(<span class="string_literal">"%02x "</span>, *bytePointer);
    }
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The value of  would change from  to  to visit all of the bytes of the variable. Note that the value  is outside of the range and is never accessed.
</p>
<br><br>
<p>The following program calls  with various types of variables:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> Struct {
    <span class="keyword">int</span> first;
    <span class="keyword">int</span> second;
}

<span class="keyword">class</span> Class {
    <span class="keyword">int</span> i;
    <span class="keyword">int</span> j;
    <span class="keyword">int</span> k;

    <span class="keyword">this</span>(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k) {
        <span class="keyword">this</span>.i = i;
        <span class="keyword">this</span>.j = j;
        <span class="keyword">this</span>.k = k;
    }
}

<span class="keyword">void</span> main() {
    <span class="keyword">int</span> integerVariable = 0x11223344;
    printBytes(integerVariable);

    <span class="keyword">double</span> doubleVariable = <span class="keyword">double</span>.nan;
    printBytes(doubleVariable);

    string slice = <span class="string_literal">"a bright and charming façade"</span>;
    printBytes(slice);

    <span class="keyword">int</span>[3] array = [ 1, 2, 3 ];
    printBytes(array);

    <span class="keyword">auto</span> structObject = Struct(0xaa, 0xbb);
    printBytes(structObject);

    <span class="keyword">auto</span> classVariable = <span class="keyword">new</span> Class(1, 2, 3);
    printBytes(classVariable);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The output of the program is informative:
</p>
<br><br>

<br><br>
<p><b>Observations:</b>
</p>
<br><br>
<ol><br><br>
<li>Although in reverse order on little-endian systems, the bytes of some of the types are as one would expect: The bytes are laid out in memory side by side for s, fixed-length arrays (), and struct objects.</li>
<br><br>
<li>Considering that the bytes of the special value of  are also in reverse order in memory, we can see that it is represented by the special bit pattern 0x7ff8000000000000.</li>
<br><br>
<li> is reported to be consisting of 16 bytes but it is impossible to fit the letters  into so few bytes. This is due to the fact that behind the scenes  is actually implemented as a struct. Prefixing its name by  to stress the fact that it is an internal type used by the compiler, that struct is similar to the following one:
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> __string {
    size_t length;
    <span class="keyword">char</span> * ptr;    <span class="comment">// the actual characters
</span>}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The evidence of this fact is hidden in the bytes that are printed for  above. Note that because ç is made up of two UTF-8 code units, the 28 letters of the string  consists of a total of 29 bytes. The value 0x000000000000001d, the first 8 of the bytes of the string in the output above, is also 29. This is a strong indicator that strings are indeed laid out in memory as in the struct above.
</p>
<br><br>
</li>
<br><br>
<li>Similarly, it is not possible to fit the three  members of the class object in 8 bytes. The output above hints at the possibility that behind the scenes a class variable is implemented as a single pointer that points at the actual class object:
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> __Class_VariableType {
    __Class_ActualObjecType * object;
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
</li>
<br><br>
</ol>
<br><br>
<p>Let's now consider a more flexible function. Instead of printing the bytes of a variable, let's define a function that prints specified number of bytes at a specified location:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;
<span class="keyword">import</span> std.ascii;

<span class="keyword">void</span> printMemory(T)(T * location, size_t length) {
    <span class="keyword">const</span> <span class="keyword">ubyte</span> * begin = <span class="keyword">cast</span>(<span class="keyword">ubyte</span>*)location;

    <span class="keyword">foreach</span> (address; begin .. begin + length) {
        <span class="keyword">char</span> c = (isPrintable(*address) ? *address : '.');

        writefln(<span class="string_literal">"%s:  %02x  %s"</span>, address, *address, c);
    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Since some of the UTF-8 code units may correspond to control characters of the terminal and disrupt its output, we print only the printable characters by first checking them individually by . The non-printable characters are printed as a dot.
</p>
<br><br>
<p>We can use that function to print the UTF-8 code units of a  through its  property:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;

<span class="keyword">void</span> main() {
    string s = <span class="string_literal">"a bright and charming façade"</span>;
    printMemory(s.ptr, s.length);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>As seen in the output, the letter ç consists of two bytes:
</p>
<br><br>

<br><br>


</section>
      </article>
    </div>
  </body>
</html>
