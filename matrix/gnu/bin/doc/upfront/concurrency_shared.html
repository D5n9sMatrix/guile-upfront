
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>concurrency_shared</title>
    <style type="text/css" media="screen">
      html, body, div, span, object, iframe, h1, h2, h3, h4, h5, h6, p,
      blockquote, pre, a, abbr, address, cite, code, del, dfn, em, figure,
      img, ins, kbd, q, s, samp, small, strong, sub, sup, var, b, u, i, dl,
      dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption,
      tbody, tfoot, thead, tr, th, td {
        background: transparent none repeat scroll 0 0;
        border: 0 none;
        font-size: 100%;
        margin: 0;
        outline: 0 none;
        padding: 0;
        vertical-align: baseline;
      }

      h1 { font-size: 200%; }
      h2 { font-size: 160%; }
      h3 { font-size: 120%; }
      h4 { font-size: 100%; }
      h5 { font-size: 80%; }
      h6 { font-size: 80%; font-weight: normal; }

      ul, ol {
        margin: 1.4em 0;
      }
      ul ul, ol ol, ul ol, ol ul {
        margin-top: 0;
        margin-bottom: 0;
      }
      ul, ol {
        margin-left: 2.8em;
      }

      ol {
        list-style: decimal;
      }
      ol ol {
        list-style: lower-alpha;
      }
      ol ol ol {
        list-style: lower-roman;
      }
      ol ol ol ol {
        list-style: decimal;
      }

      blockquote {
        margin: 0.1em;
        margin-left: 1em;
        border-left: 2px solid #cccccc;
        padding-left: 0.7em;
      }

      .color_red { color: #dc322f; }
      .color_blue { color: #268bd2; }
      .color_green { color: #859901; }
      .color_yellow { color: #b58901; }
      .color_black { color: black; }
      .color_white { color: white; }

      .font_big {
        font-size: 1.2em;
      }

      .ddoc_section_h {
        font-weight: bold;
        font-size: 13px;
        line-height: 19.5px;
        margin-top: 11px;
        display: block;
      }

      body.dlang .dlang {
        display: inline-block;
      }

      body.dlang .declaration .dlang {
          display: block;
      }

      body.dlang .ddoc_header_anchor a.dlang {
        display: block;
        color: rgba(0, 136, 204, 1);
        text-decoration: none;
      }

      body.dlang .ddoc_header_anchor .code {
        color: rgba(0, 136, 204, 1);
      }

      #ddoc_main .module {
          border-color: currentColor rgba(233, 233, 233, 1) rgba(233, 233, 233, 1);
          border-style: none solid solid;
          border-width: 0 1px 1px;
          overflow-x: hidden;
          padding: 15px;
      }

      #ddoc_main .section .section {
        margin-top: 0;
      }

      #ddoc_main .ddoc_module_members_section {
          padding: 1px 0 0;
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .ddoc_member, #ddoc_main .ddoc_module_members section.intro {
          background: #fff none repeat scroll 0 0;
          list-style-type: none;
          width: 100%;
      }

      #ddoc_main .ddoc_header_anchor {
          font-size: 1.4em;
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .ddoc_header_anchor > .code {
          display: inline-block;

      }

      #ddoc_main .ddoc_decl {
        background-color: transparent;
        height: 100%;
        left: 0;
        top: 0;
        padding: 0;
        padding-left: 15px;
      }

      #ddoc_main .ddoc_decl .section, #ddoc_main .section.ddoc_sections {
        background: white none repeat scroll 0 0;
        margin: 0;
        padding: 5px;
        position: relative;
        border-radius: 5px;
      }

      #ddoc_main .ddoc_decl .section h4:first-of-type, #ddoc_main .section.ddoc_sections h4:first-of-type {
        font-size: 13px;
        line-height: 1.5;
        margin-top: 21px;
      }

      #ddoc_main .section .declaration {
          margin-top: 21px;
      }

      #ddoc_main .section .declaration .code {
          color: rgba(0, 0, 0, 1);
          margin-bottom: 15px;
          padding-bottom: 6px;
      }

      #ddoc_main .declaration div .para {
          margin-bottom: 0;
      }

      #ddoc_main .ddoc_params .graybox tr td:first-of-type {
        padding: 7px;
        text-align: right;
        vertical-align: top;
        word-break: normal;
        white-space: nowrap;
      }

      #ddoc_main .ddoc_params .graybox {
        border: 0 none;
      }

      #ddoc_main .ddoc_params .graybox td {
        border-color: rgba(214, 214, 214, 1);
      }

      #ddoc_main .ddoc_params .graybox tr:first-child > td {
        border-top: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr:last-child > td {
        border-bottom: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr > td:first-child {
        border-left: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr > td:last-child {
        border-right: 0 none;
        width: 100%;
      }

      #ddoc_main em.term, #ddoc_main em.term .code {
        color: rgba(65, 65, 65, 1);
        font-size: 12px;
        font-style: italic;
        line-height: 1.5;
      }

      #ddoc_main .see-also {
        cursor: pointer;
        font-family: Menlo,monospace;
      }

      #ddoc_main .ddoc_decl .section > div:last-of-type {
        margin-bottom: 15px;
      }

      #ddoc_main .ddoc_member, #ddoc_main .ddoc_module_members {
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .code_sample {
        background: inherit;
      }

      #ddoc_main .declaration .code-line {
          display: block;
          font: 1em Menlo,monospace;
      }

      #ddoc_main a[name] {
        margin: -112px 0 0;
        padding-top: 112px;
      }

      #ddoc_main .ddoc_decl td {
        max-width: inherit;
      }

      #ddoc_main .declaration a {
        color: inherit;
      }

      #ddoc_main .declaration a:hover {
          color: rgba(0, 136, 204, 1);
          text-decoration: underline;
      }

      body.ddoc {
        background-color: transparent;
        color: rgba(0, 0, 0, 1);
        font-family: Helvetica,Arial,sans-serif;
        font-size: 62.5%;
        margin: 0;
        border: 0;
        left: 0;
        top: 0;
        padding: 0;
      }

      .ddoc a[name] {
        display: block;
        height: 0;
        margin: -85px 0 0;
        padding-top: 85px;
        width: 0;
      }

      .ddoc .module {
          border-color: transparent;
          background-color: rgba(255, 255, 255, 1);
          border-color: currentColor rgba(233, 233, 233, 1) rgba(233, 233, 233, 1);
          border-image: none;
          border-style: none solid solid;
          border-width: 0 1px 1px;
          box-shadow: 0 0 1px rgba(0, 0, 0, 0.07);
          display: block;
          margin-left: 0;
          min-height: calc(100% - 173px);
          overflow: auto;
          padding-bottom: 100px;
      }

      .ddoc .content_wrapper {
          background-color: rgba(242, 242, 242, 1);
          margin: 0 auto;
          max-width: 980px;
      }

      .ddoc .section {
        padding: 15px 25px 30px;
      }

      .ddoc .section .section {
        margin: 30px 0 0;
        padding: 0;
      }

      .ddoc .para {
        color: rgba(65, 65, 65, 1);
        font-size: 1.4em;
        line-height: 145%;
        margin-bottom: 15px;
      }

      .ddoc .ddoc_examples .para {
        margin-bottom: 0;
      }

      .ddoc .module_name {
          color: rgba(0, 0, 0, 1);
          display: block;
          font-family: Helvetica;
          font-size: 2.8em;
          font-weight: 100;
          margin-bottom: 0;
          padding: 15px 0;
      }

      .ddoc .module a {
          color: rgba(0, 136, 204, 1);
          text-decoration: none;
      }

      .ddoc .code {
        color: rgba(128, 128, 128, 1);
        font-family: Menlo,monospace;
        font-size: 0.85em;
        word-wrap: break-word;
      }

      .ddoc .code i {
        font-style: normal;
      }

      .ddoc .code .code {
        font-size: 1em;
      }

      .ddoc .code_sample {
        background-clip: padding-box;
        margin: 1px 0;
        text-align: left;
      }

      .ddoc .code_sample {
        display: block;
        font-size: 1.4em;
        margin-left: 21px;
      }

      .ddoc ol .code_sample {
        font-size: 1em;
      }

      .ddoc .code_lines {
        counter-reset: li;
        line-height: 1.6em;
        list-style: outside none none;
        margin: 0;
        padding: 0;
      }

      .ddoc .code_listing .code_sample div {
        margin-left: 13px;
        width: 93%;
      }

      .ddoc .code_listing .code_sample div .code_lines li {
        list-style-type: none;
        margin: 0;
        padding-right: 10px;
      }

      .ddoc .code_sample div .code_lines li::before {
        margin-left: -33px;
        margin-right: 25px;
      }

      .ddoc .code_sample div .code_lines li:nth-child(n+10)::before {
        margin-left: -39px;
        margin-right: 25px;
      }

      .ddoc .code_sample div .code_lines li:nth-child(n+100)::before {
        margin-left: -46px;
        margin-right: 25px;
      }

      .ddoc .code_sample .code_lines .code {
        color: #000;
      }

      .ddoc div.dlang {
        margin: 10px 0 21px;
        padding: 4px 0 2px 10px;
      }

      .ddoc div.dlang {
          margin: 10px 0 21px;
          padding: 4px 0 2px 10px;
      }

      .ddoc div.dlang {
        border-left: 5px solid rgba(0, 155, 51, 0.2);
      }

      .ddoc .code_lines li::before {
        color: rgba(128, 128, 128, 1);
        content: counter(li, decimal);
        counter-increment: li;
        font-family: Menlo,monospace;
        font-size: 0.9em;
        margin-right: 16px;
      }

      .ddoc .code_lines li {
        padding-left: 0;
        white-space: pre-wrap;
      }

      .ddoc .code_lines li:only-of-type::before {
        color: rgba(255, 255, 255, 1);
        content: " ";
      }

      .ddoc .code_lines li:only-of-type {
        color: rgba(255, 255, 255, 1);
        content: " ";
      }

      .ddoc .code_lines li:nth-child(n+10) {
        text-indent: -17px;
      }

      .ddoc .code_lines li:nth-child(n+10)::before {
        margin-right: 12px;
      }

      .ddoc .graybox {
        border: 1px solid rgba(233, 233, 233, 1);
        border-collapse: collapse;
        border-spacing: 0;
        empty-cells: hide;
        margin: 20px 0 36px;
        text-align: left;
      }

      .ddoc .graybox p {
        margin: 0;
        min-width: 50px;
      }

      .ddoc th {
        margin: 0;
        max-width: 260px;
        padding: 5px 10px 5px 10px;
        vertical-align: bottom;
      }

      .ddoc td {
        border: 1px solid rgba(233, 233, 233, 1);
        margin: 0;
        max-width: 260px;
        padding: 5px 10px 5px 10px;
        vertical-align: middle;
      }

      .punctuation {
        color: rgba(0, 0, 0, 1);
      }

      .comment {
        color: rgba(0, 131, 18, 1);
      }

      .operator {
        color: #000;
      }

      .keyword {
        color: rgba(170, 13, 145, 1);
      }

      .keyword_type {
        color: rgba(170, 51, 145, 1);
      }

      .string_literal {
        color: rgba(196, 26, 22, 1);
      }

      .ddoc_psuper_symbol {
        color: rgba(92, 38, 153, 1);
      }

      .param {
        color: rgba(0, 0, 0, 1);
      }

      .psymbol {
        color: rgba(0, 0, 0, 1);
      }

      .ddoc_member_header .ddoc_header_anchor .code {
        font-size: 1em;
      }
    </style>
  </head>
  <body id="ddoc_main" class="ddoc dlang">
    <div class="content_wrapper">
      <article class="module">
        <h1 class="module_name">concurrency_shared</h1>
        <section id="module_content"><br><br>
<br><br>

<br><br>
<p>The previous chapter was about threads sharing information through message passing. As it has been mentioned in that chapter, message passing is a safe method of concurrency.
</p>
<br><br>
<p>Another method involves more than one thread reading from and writing to the same data. For example, the owner thread can start the worker with the address of a  variable and the worker can determine whether to terminate or not by reading the current value of that variable. Another example would be where the owner starts multiple workers with the address of the same variable so that the variable gets modified by more than one worker.
</p>
<br><br>
<p>One of the reasons why data sharing is not safe is <i>race conditions</i>. A race condition occurs when more than one thread accesses the same mutable data in an uncontrolled order. Since the operating system pauses and starts individual threads in unspecified ways, the behavior of a program that has race conditions is unpredictable.
</p>
<br><br>
<p>The examples in this chapter may look simplistic. However, the issues that they convey appear in real programs at greater scales. Also, although these examples use the  module, the concepts of this chapter apply to the  module as well.
</p>
<br><br>
<h5>Sharing is not automatic</h5>
<br><br>
<p>Unlike most other programming languages, data is not automatically shared in D; data is thread-local by default. Although module-level variables may give the impression of being accessible by all threads, each thread actually gets its own copy:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;
<span class="keyword">import</span> std.concurrency;
<span class="keyword">import</span> core.thread;

<span class="keyword">int</span> ;

<span class="keyword">void</span> printInfo(string message) {
    writefln(<span class="string_literal">"%s: %s (@%s)"</span>, message, variable, &amp;variable);
}

<span class="keyword">void</span> worker() {
    variable = ;
    printInfo(<span class="string_literal">"Before the worker is terminated"</span>);
}

<span class="keyword">void</span> main() {
    spawn(&amp;worker);
    thread_joinAll();
    printInfo(<span class="string_literal">"After the worker is terminated"</span>);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p> that is modified inside  is not the same  that is seen by . This fact can be observed by printing both the values and the addresses of the variables:
</p>
<br><br>

<br><br>
<p>Since each thread gets its own copy of data,  does not allow passing references to thread-local variables. For example, the following program that tries to pass the address of a  variable to another thread cannot be compiled:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.concurrency;

<span class="keyword">void</span> worker() {
    <span class="keyword">while</span> (!(*isDone)) {
        <span class="comment">// ...
</span>    }
}

<span class="keyword">void</span> main() {
    <span class="keyword">bool</span> isDone = <span class="keyword">false</span>;
    spawn(&amp;worker, );      

    <span class="comment">// ...
</span>
    <span class="comment">// Hoping to signal the worker to terminate:
</span>    isDone = <span class="keyword">true</span>;

    <span class="comment">// ...
</span>}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>A  inside the  module prevents accessing <i>mutable</i> data from another thread:
</p>
<br><br>

<br><br>
<p>The address of the mutable variable  cannot be passed between threads.
</p>
<br><br>
<p> An exception to this rule is a variable that is defined as :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">__gshared</span> <span class="keyword">int</span> globallyShared;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>There is only one copy of such a variable in the entire program and all threads can share that variable.  is necessary when interacting with libraries of languages like C and C++ where data sharing is automatic by default.
</p>
<br><br>
<h5>  to share mutable data between threads</h5>
<br><br>
<p>Mutable variables that need to be shared must be defined with the  keyword:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.concurrency;

<span class="keyword">void</span> worker( * isDone) {
    <span class="keyword">while</span> (*isDone) {
        <span class="comment">// ...
</span>    }
}

<span class="keyword">void</span> main() {
     isDone = <span class="keyword">false</span>;
    spawn(&amp;worker, &amp;isDone);

    <span class="comment">// ...
</span>
    <span class="comment">// Signalling the worker to terminate:
</span>    isDone = <span class="keyword">true</span>;

    <span class="comment">// ...
</span>}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p><i><b>Note:</b> Prefer message-passing to signal a thread.</i>
</p>
<br><br>
<p> On the other hand, since  variables cannot be modified, there is no problem with sharing them directly. For that reason,  implies :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;
<span class="keyword">import</span> std.concurrency;
<span class="keyword">import</span> core.thread;

<span class="keyword">void</span> worker( * data) {
    writeln(<span class="string_literal">"data: "</span>, *data);
}

<span class="keyword">void</span> main() {
     i = 42;
    spawn(&amp;worker, &amp;i);         <span class="comment">// ← compiles
</span>
    thread_joinAll();
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The output:
</p>
<br><br>

<br><br>
<p>Note that since the lifetime of  is defined by the scope of , it is important that  does not terminate before the worker thread. The call to  above is to make a thread wait for all of its child threads to terminate.
</p>
<br><br>
<h5>A race condition example</h5>
<br><br>
<p>The correctness of the program requires extra attention when mutable data is shared between threads.
</p>
<br><br>
<p>To see an example of a race condition let's consider multiple threads sharing the same mutable variable. The threads in the following program receive the addresses as two variables and swap their values a large number of times:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;
<span class="keyword">import</span> std.concurrency;
<span class="keyword">import</span> core.thread;

<span class="keyword">void</span> swapper( * first,  * second) {
    <span class="keyword">foreach</span> (i; 0 .. 10_000) {
        <span class="keyword">int</span> temp = *second;
        *second = *first;
        *first = temp;
    }
}

<span class="keyword">void</span> main() {
     i = 1;
     j = 2;

    writefln(<span class="string_literal">"before: %s and %s"</span>, i, j);

    <span class="keyword">foreach</span> (id; 0 .. 10) {
        spawn(&amp;swapper, &amp;i, &amp;j);
    }

    <span class="comment">// Wait for all threads to finish their tasks
</span>    thread_joinAll();

    writefln(<span class="string_literal">"after : %s and %s"</span>, i, j);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Although the program above gets compiled successfully, in most cases it would work incorrectly. Observe that it starts ten threads that all access the same two variables  and . As a result of the <i>race conditions</i> that they are in, they inadvertently spoil the operations of other threads.
</p>
<br><br>
<p>Also observe that total number of swaps is 10 times 10 thousand. Since that amount is an even number, it is natural to expect that the variables end up having values 1 and 2, their initial values:
</p>
<br><br>

<br><br>
<p>Although it is possible that the program can indeed produce that result, most of the time the actual outcome would be one of the following:
</p>
<br><br>

<br><br>

<br><br>
<p>It is possible but highly unlikely that the result may even end up being "2 and 1" as well.
</p>
<br><br>
<p>The reason why the program works incorrectly can be explained by the following scenario between just two threads that are in a race condition. As the operating system pauses and restarts the threads at indeterminate times, the following order of execution of the operations of the two threads is likely as well.
</p>
<br><br>
<p>Let's consider the state where  is 1 and  is 2. Although the two threads execute the same  function, remember that the local variable  is separate for each thread and it is independent from the other  variables of other threads. To identify those separate variables, they are renamed as  and  below.
</p>
<br><br>
<p>The chart below demonstrates how the 3-line code inside the  loop may be executed by each thread over time, from top to bottom, operation 1 being the first operation and operation 6 being the last operation. Whether  or  is modified at each step is indicated by highlighting that variable:
</p>
<br><br>

<br><br>
<p>As can be seen, at the end of the previous scenario both  and  end up having the value 1. It is not possible that they can ever have any other value after that point.
</p>
<br><br>
<p>The scenario above is just one example that is sufficient to explain the incorrect results of the program. Obviously, the race conditions would be much more complicated in the case of the ten threads of this example.
</p>
<br><br>
<h5>  to avoid race conditions</h5>
<br><br>
<p>The incorrect program behavior above is due to more than one thread accessing the same mutable data (and at least one of them modifying it). One way of avoiding these race conditions is to mark the common code with the  keyword. The program would work correctly with the following change:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">foreach</span> (i; 0 .. 10_000) {
        
            <span class="keyword">int</span> temp = *b;
            *b = *a;
            *a = temp;
        
    }
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The output:
</p>
<br><br>

<br><br>
<p> The effect of  is to create a lock behind the scenes and to allow only one thread hold that lock at a given time. Only the thread that holds the lock can be executed and the others wait until the lock becomes available again when the executing thread completes its  block. Since one thread executes the <i>synchronized</i> code at a time, each thread would now swap the values safely before another thread does the same. The state of the variables  and  would always be either "1 and 2" or "2 and 1" at the end of processing the synchronized block.
</p>
<br><br>
<p><i><b>Note:</b> It is a relatively expensive operation for a thread to wait for a lock, which may slow down the execution of the program noticeably. Fortunately, in some cases program correctness can be ensured without the use of a  block, by taking advantage of <i>atomic operations</i> that will be explained below.</i>
</p>
<br><br>
<p>When it is needed to synchronize more than one block of code, it is possible to specify one or more locks with the  keyword.
</p>
<br><br>
<p>Let's see an example of this in the following program that has two separate code blocks that access the same shared variable. The program calls two functions with the address of the same variable, one function incrementing and the other function decrementing it equal number of times:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">void</span> incrementer(<span class="keyword">shared</span>(<span class="keyword">int</span>) * value) {
    <span class="keyword">foreach</span> (i; 0 .. count) {
        *value = *value + 1;
    }
}

<span class="keyword">void</span> decrementer(<span class="keyword">shared</span>(<span class="keyword">int</span>) * value) {
    <span class="keyword">foreach</span> (i; 0 .. count) {
        *value = *value - 1;
    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p><i><b>Note:</b> If the shorter equivalents of the expression above are used (i.e.  and ), then the compiler warns that such read-modify-write operations on  variables are deprecated.</i>
</p>
<br><br>
<p>Unfortunately, marking those blocks individually with  is not sufficient, because the anonymous locks of the two blocks would be independent. So, the two code blocks would still be accessing the same variable concurrently:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;
<span class="keyword">import</span> std.concurrency;
<span class="keyword">import</span> core.thread;

<span class="keyword">enum</span> count = 1000;

<span class="keyword">void</span> incrementer(<span class="keyword">shared</span>(<span class="keyword">int</span>) * value) {
    <span class="keyword">foreach</span> (i; 0 .. count) {
         { <span class="comment">// ← This lock is different from the one below.
</span>            *value = *value + 1;
        }
    }
}

<span class="keyword">void</span> decrementer(<span class="keyword">shared</span>(<span class="keyword">int</span>) * value) {
    <span class="keyword">foreach</span> (i; 0 .. count) {
         { <span class="comment">// ← This lock is different from the one above.
</span>            *value = *value - 1;
        }
    }
}

<span class="keyword">void</span> main() {
    <span class="keyword">shared</span>(<span class="keyword">int</span>) number = 0;

    <span class="keyword">foreach</span> (i; 0 .. 100) {
        spawn(&amp;incrementer, &amp;number);
        spawn(&amp;decrementer, &amp;number);
    }

    thread_joinAll();
    writeln(<span class="string_literal">"Final value: "</span>, number);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Since there are equal number of threads that increment and decrement the same variable equal number of times, one would expect the final value of  to be zero. However, that is almost never the case:
</p>
<br><br>

<br><br>
<p>For more than one block to use the same lock or locks, the lock objects must be specified within the  parentheses:
</p>
<br><br>
<p>
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    
    <span class="keyword">synchronized</span> (<i>lock_object</i>, <i>another_lock_object</i>, ...)
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>There is no need for a special lock type in D because any class object can be used as a  lock. The following program defines an empty class named  to use its objects as locks:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;
<span class="keyword">import</span> std.concurrency;
<span class="keyword">import</span> core.thread;

<span class="keyword">enum</span> count = 1000;



<span class="keyword">void</span> incrementer(<span class="keyword">shared</span>(<span class="keyword">int</span>) * value, ) {
    <span class="keyword">foreach</span> (i; 0 .. count) {
        <span class="keyword">synchronized</span>  {
            *value = *value + 1;
        }
    }
}

<span class="keyword">void</span> decrementer(<span class="keyword">shared</span>(<span class="keyword">int</span>) * value, ) {
    <span class="keyword">foreach</span> (i; 0 .. count) {
        <span class="keyword">synchronized</span>  {
            *value = *value - 1;
        }
    }
}

<span class="keyword">void</span> main() {
    ;
    <span class="keyword">shared</span>(<span class="keyword">int</span>) number = 0;

    <span class="keyword">foreach</span> (i; 0 .. 100) {
        spawn(&amp;incrementer, &amp;number, );
        spawn(&amp;decrementer, &amp;number, );
    }

    thread_joinAll();
    writeln(<span class="string_literal">"Final value: "</span>, number);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Because this time both  blocks are connected by the same lock, only one of them is executed at a given time and the result is zero as expected:
</p>
<br><br>

<br><br>
<p>Class types can be defined as  as well. This means that all of the non-static member functions of that type are synchronized on a given object of that class:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"> <span class="keyword">class</span> Class {
    <span class="keyword">void</span> foo() {
        <span class="comment">// ...
</span>    }

    <span class="keyword">void</span> bar() {
        <span class="comment">// ...
</span>    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The following is the equivalent of the class definition above:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">class</span> Class {
    <span class="keyword">void</span> foo() {
        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {
            <span class="comment">// ...
</span>        }
    }

    <span class="keyword">void</span> bar() {
        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {
            <span class="comment">// ...
</span>        }
    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>When blocks of code need to be synchronized on more than one object, those objects must be specified together. Otherwise, it is possible that more than one thread may have locked objects that other threads are waiting for, in which case the program may be <i>deadlocked</i>.
</p>
<br><br>
<p>A well known example of this problem is a function that tries to transfer money from one bank account to another. For this function to work correctly in a multi-threaded environment, both of the accounts must first be locked. However, the following attempt would be incorrect:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">void</span> transferMoney(<span class="keyword">shared</span> BankAccount from,
                   <span class="keyword">shared</span> BankAccount to) {
    <span class="keyword">synchronized</span> (from) {           
        <span class="keyword">synchronized</span> (to) {
            <span class="comment">// ...
</span>        }
    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p> The error can be explained by an example where one thread attempting to transfer money from account A to account to B while another thread attempting to transfer money in the reverse direction. It is possible that each thread may have just locked its respective  object, hoping next to lock its  object. Since the  objects correspond to A and B in the two threads respectively, the objects would be in locked state in separate threads, making it impossible for the other thread to ever lock its  object. This situation is called a <i>deadlock</i>.
</p>
<br><br>
<p>The solution to this problem is to define an ordering relation between the objects and to lock them in that order, which is handled automatically by the  statement. In D, it is sufficient to specify the objects in the same  statement for the code to avoid such deadlocks:
</p>
<br><br>
<p>
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">void</span> transferMoney(<span class="keyword">shared</span> BankAccount from,
                   <span class="keyword">shared</span> BankAccount to) {
    
    <span class="keyword">synchronized</span> (from, to) {       
        <span class="comment">// ...
</span>    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<h5>        for single initialization and  for single finalization</h5>
<br><br>
<p>We have already seen that  can be used for initializing modules, including their variables. Because data is thread-local by default,  must be executed by every thread so that module-level variables are initialized for all threads:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;
<span class="keyword">import</span> std.concurrency;
<span class="keyword">import</span> core.thread;

<span class="keyword">static</span> <span class="keyword">this</span>() {
    writeln(<span class="string_literal">"executing static this()"</span>);
}

<span class="keyword">void</span> worker() {
}

<span class="keyword">void</span> main() {
    spawn(&amp;worker);

    thread_joinAll();
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The  block above would be executed once for the main thread and once for the worker thread:
</p>
<br><br>

<br><br>
<p>This would cause problems for  module variables because initializing a variable more than once would be wrong especially in concurrency due to race conditions. (That applies to  variables as well because they are implicitly .) The solution is to use  blocks, which are executed only once per program:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">int</span> a;              <span class="comment">// thread-local
</span><span class="keyword">immutable</span> <span class="keyword">int</span> b;    <span class="comment">// shared by all threads
</span>
<span class="keyword">static</span> <span class="keyword">this</span>() {
    writeln(<span class="string_literal">"Initializing per-thread variable at "</span>, &amp;a);
    a = 42;
}

 <span class="keyword">static</span> <span class="keyword">this</span>() {
    writeln(<span class="string_literal">"Initializing per-program variable at "</span>, &amp;b);
    b = 43;
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The output:
</p>
<br><br>

<br><br>
<p>Similarly,  is for final operations that must be executed only once per program.
</p>
<br><br>
<h5> Atomic operations</h5>
<br><br>
<p>Another way of ensuring that only one thread mutates a certain variable is by using atomic operations, functionality of which are provided by the microprocessor, the compiler, or the operating system.
</p>
<br><br>
<p>The atomic operations of D are in the  module. We will see only two of its functions in this chapter:
</p>
<br><br>
<h6> </h6>
<br><br>
<p>This function applies its template parameter to its two function parameters. The template parameter must be a <i>binary operator</i> like , , etc.
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> core.atomic;

<span class="comment">// ...
</span>
        atomicOp!<span class="string_literal">"+="</span>(*value, 1);    <span class="comment">// atomic
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The line above is the equivalent of the following line, with the difference that the  operation would be executed without interruptions by other threads (i.e. it would be executed <i>atomically</i>):
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">        *value += 1;                 <span class="comment">// NOT atomic
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Consequently, when it is only a binary operation that needs to be synchronized, then there is no need for a  block, which is known to be slow because of needing to acquire a lock. The following equivalents of the  and  functions that use  are correct as well. Note that there is no need for the  class anymore either:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> core.atomic;

<span class="comment">//...
</span>
<span class="keyword">void</span> incrementer(<span class="keyword">shared</span>(<span class="keyword">int</span>) * value) {
    <span class="keyword">foreach</span> (i; 0 .. count) {
        ;
    }
}

<span class="keyword">void</span> decrementer(<span class="keyword">shared</span>(<span class="keyword">int</span>) * value) {
    <span class="keyword">foreach</span> (i; 0 .. count) {
        ;
    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p> can be used with other binary operators as well.
</p>
<br><br>
<h6> </h6>
<br><br>
<p>The name of this function is the abbreviation of "compare and swap". Its behavior can be described as <i>mutate the variable if it still has its currently known value</i>. It is used by specifying the current and the desired values of the variable at the same time:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">bool</span> is_mutated = cas(address_of_variable, currentValue, newValue);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The fact that the value of the variable still equals  when  is operating is an indication that no other thread has mutated the variable since it has last been read by this thread. If so,  assigns  to the variable and returns . On the other hand, if the variable's value is different from  then  does not mutate the variable and returns .
</p>
<br><br>
<p>The following functions re-read the current value and call  until the operation succeeds. Again, these calls can be described as <i>if the value of the variable equals this old value, replace with this new value</i>:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">void</span> incrementer(<span class="keyword">shared</span>(<span class="keyword">int</span>) * value) {
    <span class="keyword">foreach</span> (i; 0 .. count) {
        <span class="keyword">int</span> currentValue;

        <span class="keyword">do</span> {
            currentValue = *value;
        } <span class="keyword">while</span> (!);
    }
}

<span class="keyword">void</span> decrementer(<span class="keyword">shared</span>(<span class="keyword">int</span>) * value) {
    <span class="keyword">foreach</span> (i; 0 .. count) {
        <span class="keyword">int</span> currentValue;

        <span class="keyword">do</span> {
            currentValue = *value;
        } <span class="keyword">while</span> (!);
    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The functions above work correctly without the need for  blocks.
</p>
<br><br>
<p>In most cases, the features of the  module can be several times faster than using  blocks. I recommend that you consider this module as long as the operations that need synchronization are less than a block of code.
</p>
<br><br>
<p>Atomic operations enable <i>lock-free data structures</i> as well, which are beyond the scope of this book.
</p>
<br><br>
<p>You may also want to investigate the  package, which contains classic concurrency primitives in the following modules:
</p>
<br><br>
<ul><br><br>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<br><br>
</ul>
<br><br>
<h5>Summary</h5>
<br><br>
<ul><br><br>
<li>When threads do not depend on other threads, prefer <i>parallelism</i>. Consider <i>concurrency</i> only when threads depend on operations of other threads.</li>
<br><br>
<li>Even then, prefer <i>message passing concurrency</i>, which has been the topic of the previous chapter.</li>
<br><br>
<li>Only  data can be shared;  is implicitly .</li>
<br><br>
<li> provides data sharing as in C and C++ languages.</li>
<br><br>
<li> is for preventing other threads from intervening when a thread is executing a certain piece of code.</li>
<br><br>
<li>A class can be defined as  so that only one member function can be executed on a given object at a given time. In other words, a thread can execute a member function only if no other thread is executing a member function on the same object.</li>
<br><br>
<li> is executed once for each thread;  is executed once for the entire program.</li>
<br><br>
<li>The  module enables safe data sharing that can be multiple times faster than .</li>
<br><br>
<li>The  package includes many other concurrency primitives.</li>
<br><br>
</ul>
<br><br>
macros:
        TITLE=Data Sharing Concurrency
<br><br>
        DESCRIPTION=Executing multiple threads that share data.
<br><br>
        KEYWORDS=d programming language tutorial book concurrency thread data sharing
</section>
      </article>
    </div>
  </body>
</html>
