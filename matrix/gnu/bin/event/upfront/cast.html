
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Type Conversions</title>
    <style type="text/css" media="screen">
      html, body, div, span, object, iframe, h1, h2, h3, h4, h5, h6, p,
      blockquote, pre, a, abbr, address, cite, code, del, dfn, em, figure,
      img, ins, kbd, q, s, samp, small, strong, sub, sup, var, b, u, i, dl,
      dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption,
      tbody, tfoot, thead, tr, th, td {
        background: transparent none repeat scroll 0 0;
        border: 0 none;
        font-size: 100%;
        margin: 0;
        outline: 0 none;
        padding: 0;
        vertical-align: baseline;
      }

      h1 { font-size: 200%; }
      h2 { font-size: 160%; }
      h3 { font-size: 120%; }
      h4 { font-size: 100%; }
      h5 { font-size: 80%; }
      h6 { font-size: 80%; font-weight: normal; }

      ul, ol {
        margin: 1.4em 0;
      }
      ul ul, ol ol, ul ol, ol ul {
        margin-top: 0;
        margin-bottom: 0;
      }
      ul, ol {
        margin-left: 2.8em;
      }

      ol {
        list-style: decimal;
      }
      ol ol {
        list-style: lower-alpha;
      }
      ol ol ol {
        list-style: lower-roman;
      }
      ol ol ol ol {
        list-style: decimal;
      }

      blockquote {
        margin: 0.1em;
        margin-left: 1em;
        border-left: 2px solid #cccccc;
        padding-left: 0.7em;
      }

      .color_red { color: #dc322f; }
      .color_blue { color: #268bd2; }
      .color_green { color: #859901; }
      .color_yellow { color: #b58901; }
      .color_black { color: black; }
      .color_white { color: white; }

      .font_big {
        font-size: 1.2em;
      }

      .ddoc_section_h {
        font-weight: bold;
        font-size: 13px;
        line-height: 19.5px;
        margin-top: 11px;
        display: block;
      }

      body.dlang .dlang {
        display: inline-block;
      }

      body.dlang .declaration .dlang {
          display: block;
      }

      body.dlang .ddoc_header_anchor a.dlang {
        display: block;
        color: rgba(0, 136, 204, 1);
        text-decoration: none;
      }

      body.dlang .ddoc_header_anchor .code {
        color: rgba(0, 136, 204, 1);
      }

      #ddoc_main .module {
          border-color: currentColor rgba(233, 233, 233, 1) rgba(233, 233, 233, 1);
          border-style: none solid solid;
          border-width: 0 1px 1px;
          overflow-x: hidden;
          padding: 15px;
      }

      #ddoc_main .section .section {
        margin-top: 0;
      }

      #ddoc_main .ddoc_module_members_section {
          padding: 1px 0 0;
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .ddoc_member, #ddoc_main .ddoc_module_members section.intro {
          background: #fff none repeat scroll 0 0;
          list-style-type: none;
          width: 100%;
      }

      #ddoc_main .ddoc_header_anchor {
          font-size: 1.4em;
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .ddoc_header_anchor > .code {
          display: inline-block;

      }

      #ddoc_main .ddoc_decl {
        background-color: transparent;
        height: 100%;
        left: 0;
        top: 0;
        padding: 0;
        padding-left: 15px;
      }

      #ddoc_main .ddoc_decl .section, #ddoc_main .section.ddoc_sections {
        background: white none repeat scroll 0 0;
        margin: 0;
        padding: 5px;
        position: relative;
        border-radius: 5px;
      }

      #ddoc_main .ddoc_decl .section h4:first-of-type, #ddoc_main .section.ddoc_sections h4:first-of-type {
        font-size: 13px;
        line-height: 1.5;
        margin-top: 21px;
      }

      #ddoc_main .section .declaration {
          margin-top: 21px;
      }

      #ddoc_main .section .declaration .code {
          color: rgba(0, 0, 0, 1);
          margin-bottom: 15px;
          padding-bottom: 6px;
      }

      #ddoc_main .declaration div .para {
          margin-bottom: 0;
      }

      #ddoc_main .ddoc_params .graybox tr td:first-of-type {
        padding: 7px;
        text-align: right;
        vertical-align: top;
        word-break: normal;
        white-space: nowrap;
      }

      #ddoc_main .ddoc_params .graybox {
        border: 0 none;
      }

      #ddoc_main .ddoc_params .graybox td {
        border-color: rgba(214, 214, 214, 1);
      }

      #ddoc_main .ddoc_params .graybox tr:first-child > td {
        border-top: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr:last-child > td {
        border-bottom: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr > td:first-child {
        border-left: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr > td:last-child {
        border-right: 0 none;
        width: 100%;
      }

      #ddoc_main em.term, #ddoc_main em.term .code {
        color: rgba(65, 65, 65, 1);
        font-size: 12px;
        font-style: italic;
        line-height: 1.5;
      }

      #ddoc_main .see-also {
        cursor: pointer;
        font-family: Menlo,monospace;
      }

      #ddoc_main .ddoc_decl .section > div:last-of-type {
        margin-bottom: 15px;
      }

      #ddoc_main .ddoc_member, #ddoc_main .ddoc_module_members {
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .code_sample {
        background: inherit;
      }

      #ddoc_main .declaration .code-line {
          display: block;
          font: 1em Menlo,monospace;
      }

      #ddoc_main a[name] {
        margin: -112px 0 0;
        padding-top: 112px;
      }

      #ddoc_main .ddoc_decl td {
        max-width: inherit;
      }

      #ddoc_main .declaration a {
        color: inherit;
      }

      #ddoc_main .declaration a:hover {
          color: rgba(0, 136, 204, 1);
          text-decoration: underline;
      }

      body.ddoc {
        background-color: transparent;
        color: rgba(0, 0, 0, 1);
        font-family: Helvetica,Arial,sans-serif;
        font-size: 62.5%;
        margin: 0;
        border: 0;
        left: 0;
        top: 0;
        padding: 0;
      }

      .ddoc a[name] {
        display: block;
        height: 0;
        margin: -85px 0 0;
        padding-top: 85px;
        width: 0;
      }

      .ddoc .module {
          border-color: transparent;
          background-color: rgba(255, 255, 255, 1);
          border-color: currentColor rgba(233, 233, 233, 1) rgba(233, 233, 233, 1);
          border-image: none;
          border-style: none solid solid;
          border-width: 0 1px 1px;
          box-shadow: 0 0 1px rgba(0, 0, 0, 0.07);
          display: block;
          margin-left: 0;
          min-height: calc(100% - 173px);
          overflow: auto;
          padding-bottom: 100px;
      }

      .ddoc .content_wrapper {
          background-color: rgba(242, 242, 242, 1);
          margin: 0 auto;
          max-width: 980px;
      }

      .ddoc .section {
        padding: 15px 25px 30px;
      }

      .ddoc .section .section {
        margin: 30px 0 0;
        padding: 0;
      }

      .ddoc .para {
        color: rgba(65, 65, 65, 1);
        font-size: 1.4em;
        line-height: 145%;
        margin-bottom: 15px;
      }

      .ddoc .ddoc_examples .para {
        margin-bottom: 0;
      }

      .ddoc .module_name {
          color: rgba(0, 0, 0, 1);
          display: block;
          font-family: Helvetica;
          font-size: 2.8em;
          font-weight: 100;
          margin-bottom: 0;
          padding: 15px 0;
      }

      .ddoc .module a {
          color: rgba(0, 136, 204, 1);
          text-decoration: none;
      }

      .ddoc .code {
        color: rgba(128, 128, 128, 1);
        font-family: Menlo,monospace;
        font-size: 0.85em;
        word-wrap: break-word;
      }

      .ddoc .code i {
        font-style: normal;
      }

      .ddoc .code .code {
        font-size: 1em;
      }

      .ddoc .code_sample {
        background-clip: padding-box;
        margin: 1px 0;
        text-align: left;
      }

      .ddoc .code_sample {
        display: block;
        font-size: 1.4em;
        margin-left: 21px;
      }

      .ddoc ol .code_sample {
        font-size: 1em;
      }

      .ddoc .code_lines {
        counter-reset: li;
        line-height: 1.6em;
        list-style: outside none none;
        margin: 0;
        padding: 0;
      }

      .ddoc .code_listing .code_sample div {
        margin-left: 13px;
        width: 93%;
      }

      .ddoc .code_listing .code_sample div .code_lines li {
        list-style-type: none;
        margin: 0;
        padding-right: 10px;
      }

      .ddoc .code_sample div .code_lines li::before {
        margin-left: -33px;
        margin-right: 25px;
      }

      .ddoc .code_sample div .code_lines li:nth-child(n+10)::before {
        margin-left: -39px;
        margin-right: 25px;
      }

      .ddoc .code_sample div .code_lines li:nth-child(n+100)::before {
        margin-left: -46px;
        margin-right: 25px;
      }

      .ddoc .code_sample .code_lines .code {
        color: #000;
      }

      .ddoc div.dlang {
        margin: 10px 0 21px;
        padding: 4px 0 2px 10px;
      }

      .ddoc div.dlang {
          margin: 10px 0 21px;
          padding: 4px 0 2px 10px;
      }

      .ddoc div.dlang {
        border-left: 5px solid rgba(0, 155, 51, 0.2);
      }

      .ddoc .code_lines li::before {
        color: rgba(128, 128, 128, 1);
        content: counter(li, decimal);
        counter-increment: li;
        font-family: Menlo,monospace;
        font-size: 0.9em;
        margin-right: 16px;
      }

      .ddoc .code_lines li {
        padding-left: 0;
        white-space: pre-wrap;
      }

      .ddoc .code_lines li:only-of-type::before {
        color: rgba(255, 255, 255, 1);
        content: " ";
      }

      .ddoc .code_lines li:only-of-type {
        color: rgba(255, 255, 255, 1);
        content: " ";
      }

      .ddoc .code_lines li:nth-child(n+10) {
        text-indent: -17px;
      }

      .ddoc .code_lines li:nth-child(n+10)::before {
        margin-right: 12px;
      }

      .ddoc .graybox {
        border: 1px solid rgba(233, 233, 233, 1);
        border-collapse: collapse;
        border-spacing: 0;
        empty-cells: hide;
        margin: 20px 0 36px;
        text-align: left;
      }

      .ddoc .graybox p {
        margin: 0;
        min-width: 50px;
      }

      .ddoc th {
        margin: 0;
        max-width: 260px;
        padding: 5px 10px 5px 10px;
        vertical-align: bottom;
      }

      .ddoc td {
        border: 1px solid rgba(233, 233, 233, 1);
        margin: 0;
        max-width: 260px;
        padding: 5px 10px 5px 10px;
        vertical-align: middle;
      }

      .punctuation {
        color: rgba(0, 0, 0, 1);
      }

      .comment {
        color: rgba(0, 131, 18, 1);
      }

      .operator {
        color: #000;
      }

      .keyword {
        color: rgba(170, 13, 145, 1);
      }

      .keyword_type {
        color: rgba(170, 51, 145, 1);
      }

      .string_literal {
        color: rgba(196, 26, 22, 1);
      }

      .ddoc_psuper_symbol {
        color: rgba(92, 38, 153, 1);
      }

      .param {
        color: rgba(0, 0, 0, 1);
      }

      .psymbol {
        color: rgba(0, 0, 0, 1);
      }

      .ddoc_member_header .ddoc_header_anchor .code {
        font-size: 1em;
      }
    </style>
  </head>
  <body id="ddoc_main" class="ddoc dlang">
    <div class="content_wrapper">
      <article class="module">
        <h1 class="module_name">Type Conversions</h1>
        <section id="module_content"><br><br>
<br><br>

<br><br>
<p>Variables must be compatible with the expressions that they take part in. As it has probably been obvious from the programs that we have seen so far, D is a <i>statically typed language</i>, meaning that the compatibility of types is validated at compile time.
</p>
<br><br>
<p>All of the expressions that we have written so far always had compatible types because otherwise the code would be rejected by the compiler. The following is an example of code that has incompatible types:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">char</span>[] slice;
    writeln(slice + 5);    
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The compiler rejects the code due to the incompatible types  and  for the addition operation:
</p>
<br><br>

<br><br>
<p>Type incompatibility does not mean that the types are different; different types can indeed be used in expressions safely. For example, an  variable can safely be used in place of a  value:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">double</span> sum = 1.25;
    <span class="keyword">int</span> increment = 3;
    sum += increment;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Even though  and  are of different types, the code above is valid because incrementing a  variable by an  value is legal.
</p>
<br><br>
<h5>  Automatic type conversions</h5>
<br><br>
<p>Automatic type conversions are also called <i>implicit type conversions</i>.
</p>
<br><br>
<p>Although  and  are compatible types in the expression above, the addition operation must still be evaluated as a specific type at the microprocessor level.  As you would remember from the <a href="floating_point.html">Floating Point Types chapter</a>, the 64-bit type  is <i>wider</i> (or <i>larger</i>) than the 32-bit type . Additionally, any value that fits in an  also fits in a .
</p>
<br><br>
<p>When the compiler encounters an expression that involves mismatched types, it first converts the parts of the expressions to a common type and then evaluates the overall expression. The automatic conversions that are performed by the compiler are in the direction that avoids data loss. For example,  can hold any value that  can hold but the opposite is not true. The  operation above can work because any  value can safely be converted to .
</p>
<br><br>
<p>The value that has been generated automatically as a result of a conversion is always an anonymous (and often temporary) variable. The original value does not change. For example, the automatic conversion during  above does not change the type of ; it is always an . Rather, a temporary value of type  is constructed with the value of . The conversion that takes place in the background is equivalent to the following code:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    {
        <span class="keyword">double</span> <i>an_anonymous_double_value</i> = increment;
        sum += <i>an_anonymous_double_value</i>;
    }
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The compiler converts the  value to a temporary  value and uses that value in the operation. In this example, the temporary variable lives only during the  operation.
</p>
<br><br>
<p>Automatic conversions are not limited to arithmetic operations. There are other cases where types are converted to other types automatically. As long as the conversions are valid, the compiler takes advantage of type conversions to be able to use values in expressions. For example, a  value can be passed for an  parameter:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">void</span> func(<span class="keyword">int</span> number) {
    <span class="comment">// ...
</span>}

<span class="keyword">void</span> main() {
    <span class="keyword">byte</span> smallValue = 7;
    func(smallValue);    <span class="comment">// automatic type conversion
</span>}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>In the code above, first a temporary  value is constructed and the function is called with that value.
</p>
<br><br>
<h6>  Integer promotions</h6>
<br><br>
<p>Values of types that are on the left-hand side of the following table never take part in arithmetic expressions as their actual types. Each type is first promoted to the type that is on the right-hand side of the table.
</p>
<br><br>
<table class="narrow" border="1" cellpadding="4" cellspacing="0">
<tr><th scope="col">From</th> <th scope="col">To</th>
</tr>
<br><br>
        <tr align="center">
	<td>bool</td>
	<td>int</td>
	</tr>
<br><br>
        <tr align="center">
	<td>byte</td>
	<td>int</td>
	</tr>
<br><br>
	<tr align="center">
	<td>ubyte</td>
	<td>int</td>
	</tr>
<br><br>
        <tr align="center">
	<td>short</td>
	<td>int</td>
	</tr>
<br><br>
	<tr align="center">
	<td>ushort</td>
	<td>int</td>
	</tr>
<br><br>
	<tr align="center">
	<td>char</td>
	<td>int</td>
	</tr>
<br><br>
        <tr align="center">
	<td>wchar</td>
	<td>int</td>
	</tr>
<br><br>
        <tr align="center">
	<td>dchar</td>
	<td>uint</td>
	</tr>
</table>
<br><br>
<p>Integer promotions are applied to  values as well.
</p>
<br><br>
<p>The reasons for integer promotions are both historical (where the rules come from C) and the fact that the natural arithmetic type for the microprocessor is . For example, although the following two variables are both , the addition operation is performed only after both of the values are individually promoted to :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">ubyte</span> a = 1;
    <span class="keyword">ubyte</span> b = 2;
    writeln(<span class="keyword">typeof</span>(a + b).stringof);  <span class="comment">// the addition is not in ubyte
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The output:
</p>
<br><br>

<br><br>
<p>Note that the types of the variables  and  do not change; only their values are temporarily promoted to  for the duration of the addition operation.
</p>
<br><br>
<h6> Arithmetic conversions</h6>
<br><br>
<p>There are other conversion rules that are applied for arithmetic operations. In general, automatic arithmetic conversions are applied in the safe direction: from the <i>narrower</i> type to the <i>wider</i> type. Although this rule is easy to remember and is correct in most cases, automatic conversion rules are very complicated and in the case of signed-to-unsigned conversions, carry some risk of bugs.
</p>
<br><br>
<p>The arithmetic conversion rules are the following:
</p>
<br><br>
<ol><br><br>
<li>If one of the values is , then the other value is converted to </li>
<br><br>
<li>Else, if one of the values is , then the other value is converted to </li>
<br><br>
<li>Else, if one of the values is , then the other value is converted to </li>
<br><br>
<li>Else, first <i>integer promotions</i> are applied according to the table above, and then the following rules are followed:
<br><br>
<ol><li>If both types are the same, then no more steps needed</li>
<li>If both types are signed or both types are unsigned, then the narrower value is converted to the wider type</li>
<li>If the signed type is wider than the unsigned type, then the unsigned value is converted to the signed type</li>
<li>Otherwise the signed type is converted to the unsigned type</li>
</ol>
</li>
</ol>
<br><br>
<p>Unfortunately, the last rule above can cause subtle bugs:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span>    a = 0;
    <span class="keyword">int</span>    b = 1;
    size_t c = 0;
    writeln(a - b + c);  <span class="comment">// Surprising result!
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Surprisingly, the output is not -1, but :
</p>
<br><br>

<br><br>
<p>Although one would expect  to be calculated as -1, according to the rules above, the type of the entire expression is , not ; and since  cannot hold negative values, the result overflows and becomes .
</p>
<br><br>
<h6>Slice conversions</h6>
<br><br>
<p>  As a convenience, fixed-length arrays can automatically be converted to slices when calling a function:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;

<span class="keyword">void</span> foo() {
     array = [ 1, 2 ];
    bar(array);    <span class="comment">// Passes fixed-length array as a slice
</span>}

<span class="keyword">void</span> bar( slice) {
    writeln(slice);
}

<span class="keyword">void</span> main() {
    foo();
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p> receives a slice to all elements of the fixed-length array and prints it:
</p>
<br><br>

<br><br>
<p><b>Warning:</b> A <i>local</i> fixed-length array must not be passed as a slice if the function stores the slice for later use. For example, the following program has a bug because the slice that  stores would not be valid after  exits:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;

<span class="keyword">void</span> foo() {
    <span class="keyword">int</span>[2] array = [ 1, 2 ];
    bar(array);    <span class="comment">// Passes fixed-length array as a slice
</span>
}  <span class="comment">// ← NOTE: 'array' is not valid beyond this point
</span>
<span class="keyword">int</span>[] sliceForLaterUse;

<span class="keyword">void</span> bar(<span class="keyword">int</span>[] slice) {
    <span class="comment">// Saves a slice that is about to become invalid
</span>    sliceForLaterUse = slice;
    writefln(<span class="string_literal">"Inside bar : %s"</span>, sliceForLaterUse);
}

<span class="keyword">void</span> main() {
    foo();

    <span class="comment">/* BUG: Accesses memory that is not array elements anymore */</span>
    writefln(<span class="string_literal">"Inside main: %s"</span>, sliceForLaterUse);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The result of such a bug is undefined behavior. A sample execution can prove that the memory that used to be the elements of  has already been reused for other purposes:
</p>
<br><br>

<br><br>
<h6> conversions</h6>
<br><br>
<p>As we have seen earlier in the <a href="function_parameters.html">Function Parameters chapter</a>, reference types can automatically be converted to the  of the same type. Conversion to  is safe because the width of the type does not change and  is a promise to not modify the variable:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">char</span>[] parenthesized( text) {
    <span class="keyword">return</span> <span class="string_literal">"{"</span> ~ text ~ <span class="string_literal">"}"</span>;
}

<span class="keyword">void</span> main() {
     greeting;
    greeting ~= <span class="string_literal">"hello world"</span>;
    parenthesized(greeting);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The mutable  above is automatically converted to a  as it is passed to .
</p>
<br><br>
<p>As we have also seen earlier, the opposite conversion is not automatic. A  reference is not automatically converted to a mutable reference:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">char</span>[] parenthesized(<span class="keyword">const</span> <span class="keyword">char</span>[] text) {
    <span class="keyword">char</span>[] argument = text;  
<span class="comment">// ...
</span>}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Note that this topic is only about references; since variables of value types are copied, it is not possible to affect the original through the copy anyway:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">const</span> <span class="keyword">int</span> totalCorners = 4;
    <span class="keyword">int</span> theCopy = totalCorners;      <span class="comment">// compiles (value type)
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The conversion from  to mutable above is legal because the copy is not a reference to the original.
</p>
<br><br>
<h6> conversions</h6>
<br><br>
<p>Because  specifies that a variable can never change, neither conversion from  nor to  are automatic:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    string a = <span class="string_literal">"hello"</span>;    <span class="comment">// immutable characters
</span>    <span class="keyword">char</span>[] b = a;          
    string c = b;          
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>As with  conversions above, this topic is also only about reference types. Since variables of value types are copied anyway, conversions to and from  are valid:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">immutable</span> a = 10;
    <span class="keyword">int</span> b = a;           <span class="comment">// compiles (value type)
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<h6> conversions</h6>
<br><br>
<p>As we have seen in the <a href="enum.html"> chapter</a>,  is for defining <i>named constants</i>:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">enum</span> Suit { spades, hearts, diamonds, clubs }
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Remember that since no values are specified explicitly above, the values of the  members start with zero and are automatically incremented by one. Accordingly, the value of  is 3.
</p>
<br><br>
<p> values are atomatically converted to integral types. For example, the value of  is taken to be 1 in the following calculation and the result becomes 11:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span> result = 10 + Suit.hearts;
    <span class="keyword">assert</span>(result == 11);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The opposite conversion is not automatic: Integer values are not automatically converted to corresponding  values. For example, the  variable below might be expected to become , but the code cannot be compiled:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    Suit suit = 2;    
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>As we will see below, conversions from integers to  values are still possible but they must be explicit.
</p>
<br><br>
<h6>  conversions</h6>
<br><br>
<p>   Although  is the natural type of logical expressions, as it has only two values, it can be seen as a 1-bit integer and does behave like one in some cases.  and  are automatically converted to 0 and 1, respectively:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span> a = <span class="keyword">false</span>;
    <span class="keyword">assert</span>(a == 0);

    <span class="keyword">int</span> b = <span class="keyword">true</span>;
    <span class="keyword">assert</span>(b == 1);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Regarding <i>literal values</i>, the opposite conversion is automatic only for two special literal values: 0 and 1 are converted automatically to  and , respectively:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">bool</span> a = 0;
    <span class="keyword">assert</span>(!a);     <span class="comment">// false
</span>
    <span class="keyword">bool</span> b = 1;
    <span class="keyword">assert</span>(b);      <span class="comment">// true
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Other literal values cannot be converted to  automatically:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">bool</span> b = 2;    
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Some statements make use of logical expressions: , , etc. For the logical expressions of such statements, not only  but most other types can be used as well. The value zero is automatically converted to  and the nonzero values are automatically converted to .
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span> i;
    <span class="comment">// ...
</span>
    <span class="keyword">if</span> (i) {    <span class="comment">// ← int value is being used as a logical expression
</span>        <span class="comment">// ... 'i' is not zero
</span>
    } <span class="keyword">else</span> {
        <span class="comment">// ... 'i' is zero
</span>    }
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Similarly,  references are automatically converted to  and non- references are automatically converted to . This makes it easy to ensure that a reference is non- before actually using it:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span>[] a;
    <span class="comment">// ...
</span>
    <span class="keyword">if</span> (a) {    <span class="comment">// ← automatic bool conversion
</span>        <span class="comment">// ... not null; 'a' can be used ...
</span>
    } <span class="keyword">else</span> {
        <span class="comment">// ... null; 'a' cannot be used ...
</span>    }
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<h5>  Explicit type conversions</h5>
<br><br>
<p>As we have seen above, there are cases where automatic conversions are not available:
</p>
<br><br>
<ul><li>Conversions from wider types to narrower types</li>
<li>Conversions from  to mutable</li>
<li> conversions</li>
<li>Conversions from integers to  values</li>
<li>etc.</li>
</ul>
<br><br>
<p>If such a conversion is known to be safe, the programmer can explicitly ask for a type conversion by one of the following methods:
</p>
<br><br>
<ul><li>Construction syntax</li>
<li> function</li>
<li> function</li>
<li> operator</li>
</ul>
<br><br>
<h6> Construction syntax</h6>
<br><br>
<p>The  and  construction syntax is available for other types as well:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <i>DestinationType</i>(value)
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>For example, the following <i>conversion</i> makes a  value from an  value, presumably to preserve the fractional part of the division operation:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span> i;
    <span class="comment">// ...
</span>    <span class="keyword">const</span> result =  / 2;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<h6>  for most conversions</h6>
<br><br>
<p>The  function, which we have already used mostly to convert values to , can actually be used for many other types. Its complete syntax is the following:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    to!(<i>DestinationType</i>)(value)
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Being a template,  can take advantage of the shortcut template parameter notation: When the destination type consists only of a single token (generally, <i>a single word</i>), it can be called without the first pair of parentheses:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    to!<i>DestinationType</i>(value)
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The following program is trying to convert a  value to  and a  value to :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">void</span> main() {
    <span class="keyword">double</span> d = -1.75;

    <span class="keyword">short</span> s = d;     
    <span class="keyword">int</span> i = <span class="string_literal">"42"</span>;    
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Since not every  value can be represented as a  and not every  can be represented as an , those conversions are not automatic. When it is known by the programmer that the conversions are in fact safe or that the potential consequences are acceptable, then the types can be converted by :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.conv;

<span class="keyword">void</span> main() {
    <span class="keyword">double</span> d = -1.75;

    <span class="keyword">short</span> s = to!<span class="keyword">short</span>(d);
    <span class="keyword">assert</span>(s == -1);

    <span class="keyword">int</span> i = to!<span class="keyword">int</span>(<span class="string_literal">"42"</span>);
    <span class="keyword">assert</span>(i == 42);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Note that because  cannot carry fractional values, the converted value is -1.
</p>
<br><br>
<p> is safe: It throws an exception when a conversion is not possible.
</p>
<br><br>
<h6>  for fast  conversions</h6>
<br><br>
<p> can perform  conversions as well:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span>[] slice = [ 10, 20, 30 ];
    <span class="keyword">auto</span> immutableSlice = to!()(slice);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>In order to guarantee that the elements of  will never change, it cannot share the same elements with . For that reason,  creates an additional slice with  elements above. Otherwise, modifications to the elements of  would cause the elements of  change as well. This behavior is the same with the  property of arrays.
</p>
<br><br>
<p>We can see that the elements of  are indeed copies of the elements of  by looking at the addresses of their first elements:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">assert</span>(&amp;(slice[0])  &amp;(immutableSlice[0]));
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Sometimes this copy is unnecessary and may slow the speed of the program noticeably in certain cases. As an example of this, let's look at the following function that takes an  slice:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">void</span> calculate(<span class="keyword">immutable</span> <span class="keyword">int</span>[] coordinates) {
    <span class="comment">// ...
</span>}

<span class="keyword">void</span> main() {
    <span class="keyword">int</span>[] numbers;
    numbers ~= 10;
    <span class="comment">// ... various other modifications ...
</span>    numbers[0] = 42;

    calculate(numbers);    
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The program above cannot be compiled because the caller is not passing an  argument to . As we have seen above, an  slice can be created by :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.conv;
<span class="comment">// ...
</span>    <span class="keyword">auto</span> immutableNumbers = to!(<span class="keyword">immutable</span> <span class="keyword">int</span>[])(numbers);
    calculate(immutableNumbers);    <span class="comment">// ← now compiles
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>However, if  is needed only to produce this argument and will never be used after the function is called, copying its elements to  would be unnecessary.  makes the elements of a slice  without copying:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.exception;
<span class="comment">// ...
</span>    <span class="keyword">auto</span> immutableNumbers = assumeUnique(numbers);
    calculate(immutableNumbers);
    <span class="keyword">assert</span>(numbers <span class="keyword">is</span> <span class="keyword">null</span>);    <span class="comment">// the original slice becomes null
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p> returns a new slice that provides  access to the existing elements. It also makes the original slice  to prevent the elements from accidentally being modified through it.
</p>
<br><br>
<h6> The  operator</h6>
<br><br>
<p>Both  and  make use of the conversion operator , which is available to the programmer as well.
</p>
<br><br>
<p>The  operator takes the destination type in parentheses:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">cast</span>(<i>DestinationType</i>)value
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p> is powerful even for conversions that  cannot safely perform. For example,  fails for the following conversions at runtime:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    Suit suit = to!Suit(7);    
    <span class="keyword">bool</span> b = to!<span class="keyword">bool</span>(2);       
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>

<br><br>
<p>Sometimes only the programmer can know whether an integer value corresponds to a valid  value or that it makes sense to treat an integer value as a . The  operator can be used when the conversion is known to be correct according the program's logic:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="comment">// Probably incorrect but possible:
</span>    Suit suit = <span class="keyword">cast</span>(Suit)7;

    <span class="keyword">bool</span> b = <span class="keyword">cast</span>(<span class="keyword">bool</span>)2;
    <span class="keyword">assert</span>(b);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p> is the only option when converting to and from pointer types:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">     v;
    <span class="comment">// ...
</span>    <span class="keyword">int</span> * p = <span class="keyword">cast</span>()v;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Although rare, some C library interfaces make it necessary to store a pointer value as a non-pointer type. If it is guaranteed that the conversion will preserve the actual value,  can convert between pointer and non-pointer types as well:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    size_t savedPointerValue = <span class="keyword">cast</span>()p;
    <span class="comment">// ...
</span>    <span class="keyword">int</span> * p2 = <span class="keyword">cast</span>()savedPointerValue;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<h5>Summary</h5>
<br><br>
<ul><br><br>
<li>Automatic type conversions are mostly in the safe direction: From the narrower type to the wider type and from mutable to .</li>
<br><br>
<li>However, conversions to unsigned types may have surprising effects because unsigned types cannot have negative values.</li>
<br><br>
<li> types can automatically be converted to integer values but the opposite conversion is not automatic.</li>
<br><br>
<li> and  are automatically converted to 0 and 1 respectively. Similarly, zero values are automatically converted to  and nonzero values are automatically converted to .</li>
<br><br>
<li> references are automatically converted to  and non- references are automatically converted to .</li>
<br><br>
<li>The construction syntax can be used for explicit conversions.</li>
<br><br>
<li> covers most of the explicit conversions.</li>
<br><br>
<li> converts to  without copying.</li>
<br><br>
<li>The  operator is the most powerful conversion tool.</li>
<br><br>
</ul>

</section>
      </article>
    </div>
  </body>
</html>
