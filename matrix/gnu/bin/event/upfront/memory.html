
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>memory</title>
    <style type="text/css" media="screen">
      html, body, div, span, object, iframe, h1, h2, h3, h4, h5, h6, p,
      blockquote, pre, a, abbr, address, cite, code, del, dfn, em, figure,
      img, ins, kbd, q, s, samp, small, strong, sub, sup, var, b, u, i, dl,
      dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption,
      tbody, tfoot, thead, tr, th, td {
        background: transparent none repeat scroll 0 0;
        border: 0 none;
        font-size: 100%;
        margin: 0;
        outline: 0 none;
        padding: 0;
        vertical-align: baseline;
      }

      h1 { font-size: 200%; }
      h2 { font-size: 160%; }
      h3 { font-size: 120%; }
      h4 { font-size: 100%; }
      h5 { font-size: 80%; }
      h6 { font-size: 80%; font-weight: normal; }

      ul, ol {
        margin: 1.4em 0;
      }
      ul ul, ol ol, ul ol, ol ul {
        margin-top: 0;
        margin-bottom: 0;
      }
      ul, ol {
        margin-left: 2.8em;
      }

      ol {
        list-style: decimal;
      }
      ol ol {
        list-style: lower-alpha;
      }
      ol ol ol {
        list-style: lower-roman;
      }
      ol ol ol ol {
        list-style: decimal;
      }

      blockquote {
        margin: 0.1em;
        margin-left: 1em;
        border-left: 2px solid #cccccc;
        padding-left: 0.7em;
      }

      .color_red { color: #dc322f; }
      .color_blue { color: #268bd2; }
      .color_green { color: #859901; }
      .color_yellow { color: #b58901; }
      .color_black { color: black; }
      .color_white { color: white; }

      .font_big {
        font-size: 1.2em;
      }

      .ddoc_section_h {
        font-weight: bold;
        font-size: 13px;
        line-height: 19.5px;
        margin-top: 11px;
        display: block;
      }

      body.dlang .dlang {
        display: inline-block;
      }

      body.dlang .declaration .dlang {
          display: block;
      }

      body.dlang .ddoc_header_anchor a.dlang {
        display: block;
        color: rgba(0, 136, 204, 1);
        text-decoration: none;
      }

      body.dlang .ddoc_header_anchor .code {
        color: rgba(0, 136, 204, 1);
      }

      #ddoc_main .module {
          border-color: currentColor rgba(233, 233, 233, 1) rgba(233, 233, 233, 1);
          border-style: none solid solid;
          border-width: 0 1px 1px;
          overflow-x: hidden;
          padding: 15px;
      }

      #ddoc_main .section .section {
        margin-top: 0;
      }

      #ddoc_main .ddoc_module_members_section {
          padding: 1px 0 0;
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .ddoc_member, #ddoc_main .ddoc_module_members section.intro {
          background: #fff none repeat scroll 0 0;
          list-style-type: none;
          width: 100%;
      }

      #ddoc_main .ddoc_header_anchor {
          font-size: 1.4em;
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .ddoc_header_anchor > .code {
          display: inline-block;

      }

      #ddoc_main .ddoc_decl {
        background-color: transparent;
        height: 100%;
        left: 0;
        top: 0;
        padding: 0;
        padding-left: 15px;
      }

      #ddoc_main .ddoc_decl .section, #ddoc_main .section.ddoc_sections {
        background: white none repeat scroll 0 0;
        margin: 0;
        padding: 5px;
        position: relative;
        border-radius: 5px;
      }

      #ddoc_main .ddoc_decl .section h4:first-of-type, #ddoc_main .section.ddoc_sections h4:first-of-type {
        font-size: 13px;
        line-height: 1.5;
        margin-top: 21px;
      }

      #ddoc_main .section .declaration {
          margin-top: 21px;
      }

      #ddoc_main .section .declaration .code {
          color: rgba(0, 0, 0, 1);
          margin-bottom: 15px;
          padding-bottom: 6px;
      }

      #ddoc_main .declaration div .para {
          margin-bottom: 0;
      }

      #ddoc_main .ddoc_params .graybox tr td:first-of-type {
        padding: 7px;
        text-align: right;
        vertical-align: top;
        word-break: normal;
        white-space: nowrap;
      }

      #ddoc_main .ddoc_params .graybox {
        border: 0 none;
      }

      #ddoc_main .ddoc_params .graybox td {
        border-color: rgba(214, 214, 214, 1);
      }

      #ddoc_main .ddoc_params .graybox tr:first-child > td {
        border-top: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr:last-child > td {
        border-bottom: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr > td:first-child {
        border-left: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr > td:last-child {
        border-right: 0 none;
        width: 100%;
      }

      #ddoc_main em.term, #ddoc_main em.term .code {
        color: rgba(65, 65, 65, 1);
        font-size: 12px;
        font-style: italic;
        line-height: 1.5;
      }

      #ddoc_main .see-also {
        cursor: pointer;
        font-family: Menlo,monospace;
      }

      #ddoc_main .ddoc_decl .section > div:last-of-type {
        margin-bottom: 15px;
      }

      #ddoc_main .ddoc_member, #ddoc_main .ddoc_module_members {
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .code_sample {
        background: inherit;
      }

      #ddoc_main .declaration .code-line {
          display: block;
          font: 1em Menlo,monospace;
      }

      #ddoc_main a[name] {
        margin: -112px 0 0;
        padding-top: 112px;
      }

      #ddoc_main .ddoc_decl td {
        max-width: inherit;
      }

      #ddoc_main .declaration a {
        color: inherit;
      }

      #ddoc_main .declaration a:hover {
          color: rgba(0, 136, 204, 1);
          text-decoration: underline;
      }

      body.ddoc {
        background-color: transparent;
        color: rgba(0, 0, 0, 1);
        font-family: Helvetica,Arial,sans-serif;
        font-size: 62.5%;
        margin: 0;
        border: 0;
        left: 0;
        top: 0;
        padding: 0;
      }

      .ddoc a[name] {
        display: block;
        height: 0;
        margin: -85px 0 0;
        padding-top: 85px;
        width: 0;
      }

      .ddoc .module {
          border-color: transparent;
          background-color: rgba(255, 255, 255, 1);
          border-color: currentColor rgba(233, 233, 233, 1) rgba(233, 233, 233, 1);
          border-image: none;
          border-style: none solid solid;
          border-width: 0 1px 1px;
          box-shadow: 0 0 1px rgba(0, 0, 0, 0.07);
          display: block;
          margin-left: 0;
          min-height: calc(100% - 173px);
          overflow: auto;
          padding-bottom: 100px;
      }

      .ddoc .content_wrapper {
          background-color: rgba(242, 242, 242, 1);
          margin: 0 auto;
          max-width: 980px;
      }

      .ddoc .section {
        padding: 15px 25px 30px;
      }

      .ddoc .section .section {
        margin: 30px 0 0;
        padding: 0;
      }

      .ddoc .para {
        color: rgba(65, 65, 65, 1);
        font-size: 1.4em;
        line-height: 145%;
        margin-bottom: 15px;
      }

      .ddoc .ddoc_examples .para {
        margin-bottom: 0;
      }

      .ddoc .module_name {
          color: rgba(0, 0, 0, 1);
          display: block;
          font-family: Helvetica;
          font-size: 2.8em;
          font-weight: 100;
          margin-bottom: 0;
          padding: 15px 0;
      }

      .ddoc .module a {
          color: rgba(0, 136, 204, 1);
          text-decoration: none;
      }

      .ddoc .code {
        color: rgba(128, 128, 128, 1);
        font-family: Menlo,monospace;
        font-size: 0.85em;
        word-wrap: break-word;
      }

      .ddoc .code i {
        font-style: normal;
      }

      .ddoc .code .code {
        font-size: 1em;
      }

      .ddoc .code_sample {
        background-clip: padding-box;
        margin: 1px 0;
        text-align: left;
      }

      .ddoc .code_sample {
        display: block;
        font-size: 1.4em;
        margin-left: 21px;
      }

      .ddoc ol .code_sample {
        font-size: 1em;
      }

      .ddoc .code_lines {
        counter-reset: li;
        line-height: 1.6em;
        list-style: outside none none;
        margin: 0;
        padding: 0;
      }

      .ddoc .code_listing .code_sample div {
        margin-left: 13px;
        width: 93%;
      }

      .ddoc .code_listing .code_sample div .code_lines li {
        list-style-type: none;
        margin: 0;
        padding-right: 10px;
      }

      .ddoc .code_sample div .code_lines li::before {
        margin-left: -33px;
        margin-right: 25px;
      }

      .ddoc .code_sample div .code_lines li:nth-child(n+10)::before {
        margin-left: -39px;
        margin-right: 25px;
      }

      .ddoc .code_sample div .code_lines li:nth-child(n+100)::before {
        margin-left: -46px;
        margin-right: 25px;
      }

      .ddoc .code_sample .code_lines .code {
        color: #000;
      }

      .ddoc div.dlang {
        margin: 10px 0 21px;
        padding: 4px 0 2px 10px;
      }

      .ddoc div.dlang {
          margin: 10px 0 21px;
          padding: 4px 0 2px 10px;
      }

      .ddoc div.dlang {
        border-left: 5px solid rgba(0, 155, 51, 0.2);
      }

      .ddoc .code_lines li::before {
        color: rgba(128, 128, 128, 1);
        content: counter(li, decimal);
        counter-increment: li;
        font-family: Menlo,monospace;
        font-size: 0.9em;
        margin-right: 16px;
      }

      .ddoc .code_lines li {
        padding-left: 0;
        white-space: pre-wrap;
      }

      .ddoc .code_lines li:only-of-type::before {
        color: rgba(255, 255, 255, 1);
        content: " ";
      }

      .ddoc .code_lines li:only-of-type {
        color: rgba(255, 255, 255, 1);
        content: " ";
      }

      .ddoc .code_lines li:nth-child(n+10) {
        text-indent: -17px;
      }

      .ddoc .code_lines li:nth-child(n+10)::before {
        margin-right: 12px;
      }

      .ddoc .graybox {
        border: 1px solid rgba(233, 233, 233, 1);
        border-collapse: collapse;
        border-spacing: 0;
        empty-cells: hide;
        margin: 20px 0 36px;
        text-align: left;
      }

      .ddoc .graybox p {
        margin: 0;
        min-width: 50px;
      }

      .ddoc th {
        margin: 0;
        max-width: 260px;
        padding: 5px 10px 5px 10px;
        vertical-align: bottom;
      }

      .ddoc td {
        border: 1px solid rgba(233, 233, 233, 1);
        margin: 0;
        max-width: 260px;
        padding: 5px 10px 5px 10px;
        vertical-align: middle;
      }

      .punctuation {
        color: rgba(0, 0, 0, 1);
      }

      .comment {
        color: rgba(0, 131, 18, 1);
      }

      .operator {
        color: #000;
      }

      .keyword {
        color: rgba(170, 13, 145, 1);
      }

      .keyword_type {
        color: rgba(170, 51, 145, 1);
      }

      .string_literal {
        color: rgba(196, 26, 22, 1);
      }

      .ddoc_psuper_symbol {
        color: rgba(92, 38, 153, 1);
      }

      .param {
        color: rgba(0, 0, 0, 1);
      }

      .psymbol {
        color: rgba(0, 0, 0, 1);
      }

      .ddoc_member_header .ddoc_header_anchor .code {
        font-size: 1em;
      }
    </style>
  </head>
  <body id="ddoc_main" class="ddoc dlang">
    <div class="content_wrapper">
      <article class="module">
        <h1 class="module_name">memory</h1>
        <section id="module_content"><br><br>
<br><br>

<br><br>
<p>D is a language that does not require explicit memory management. However, it is important for a system programmer to know how to manage memory when needed for special cases.
</p>
<br><br>
<p>Memory management is a very broad topic. This chapter will introduce only the garbage collector (GC), allocating memory from it, and constructing objects at specific memory locations. I encourage you to research various memory management methods as well as the  module, which was still at experimental stage at the time of writing this book.
</p>
<br><br>
<p>As in some of the previous chapters, when I write <i>variable</i> below, I mean any type of variable including  and  objects.
</p>
<br><br>
<h5> Memory</h5>
<br><br>
<p>Memory is a more significant resource than other system resources because both the running program and its data are located in the memory. The memory belongs ultimately to the operating system, which makes it available to programs to satisfy their needs. The amount of memory that a program uses may increase or decrease according to the immediate needs of a program. When a program terminates, the memory areas that it has been using are automatically returned back to the operating system.
</p>
<br><br>
<p>The memory can be imagined like a large sheet of paper where the values of variables are noted down. Each variable is kept at a specific location where its value is written to and read from as needed. Once the lifetime of a variable ends, its place is used for another variable.
</p>
<br><br>
<p> The  (address-of) operator is useful when experimenting with memory. For example, the following program prints the addresses of two variables that are defined next to each other:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;

<span class="keyword">void</span> main() {
    <span class="keyword">int</span> i;
    <span class="keyword">int</span> j;

    writeln(<span class="string_literal">"i: "</span>, i);
    writeln(<span class="string_literal">"j: "</span>, j);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p><i> <b>Note:</b> The addresses would likely be different every time the program is executed. Additionally, the mere act of taking the address of a variable disables the optimization that would otherwise make the variable live on a CPU register.</i>
</p>
<br><br>
<p>As can be seen from the output, the locations of the variables are four bytes apart:
</p>
<br><br>

<br><br>
<p>The last digits of the two addresses indicate that  lives in a memory location that is right before the location of : 8 plus 4 (size of ) makes 12 (C in hexadecimal notation).
</p>
<br><br>
<h5>  The garbage collector</h5>
<br><br>
<p>The dynamic variables that are used in D programs live on memory blocks that are owned by the garbage collector (GC). When the lifetime of a variable ends (i.e. it's no longer being used), that variable is subject to being finalized according to an algorithm that is executed by the GC. If nothing else needs the memory location containing the variable, the memory may be reclaimed to be used for other variables. This algorithm is called <i>garbage collection</i> and an execution of the algorithm is called a <i>garbage collection cycle</i>.
</p>
<br><br>
<p>The algorithm that the GC executes can roughly be described as the following. All of the memory blocks that can be reached directly or indirectly by pointers (including references) that are in the program roots are scanned. Any memory block that can be reached is tagged as being still in use and all the others are tagged as not being used anymore. The finalizers of objects and structs that live on inaccessible blocks are executed and those memory blocks are reclaimed to be used for future variables. The roots are defined as all of the program stack for every thread, all global and thread-local variables, and any additional data added via  or .
</p>
<br><br>
<p>Some GC algorithms can move objects around to keep them together in one place in memory. To preserve program correctness, all of the pointers (and references) that point to such objects are automatically modified to point to the new locations. D's current GC does not do this.
</p>
<br><br>
<p>A GC is said to be "precise" if it knows exactly which memory contains pointers and which doesn't. A GC is conservative if it scans all memory as if it were pointers. D's GC is partially conservative, scanning only blocks that contain pointers, but it will scan all data in those blocks. For this reason, in some cases blocks are not ever collected, thereby "leaking" that memory. Large blocks are more likely to be targeted by "false pointers". In some cases it may be recommended to manually free large blocks you are no longer using to avoid this problem.
</p>
<br><br>
<p>The order of executing the finalizers is unspecified. For example, a reference member of an object may be finalized before the object that contains that member. For that reason, no class member that refers to a dynamic variable should be accessed inside the destructor. Note that this is very different from the deterministic destruction order of languages like C++.
</p>
<br><br>
<p>A garbage collection cycle can be started for various reasons like needing to find space for more data. Depending on the GC implementation, because allocating new objects during a garbage collection cycle can interfere with the collection process itself, all of the running threads may have to be halted during collection cycles. Sometimes this can be observed as a hesitation in the execution of the program.
</p>
<br><br>
<p>In most cases the programmer does not need to interfere with the garbage collection process. However, it is possible to delay or dispatch garbage collection cycles as needed by the functions defined in the  module.
</p>
<br><br>
<h6>   Starting and delaying garbage collection cycles</h6>
<br><br>
<p>It may be desired to delay the execution of garbage collection cycles during a part of the program where it is important for the program to be responsive.  disables garbage collection cycles and  enables them again:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    GC.disable();

<span class="comment">// ... a part of the program where responsiveness is important ...
</span>
    GC.enable();
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>However,  is not guaranteed to prevent a garbage collection cycle from executing: If the GC needs to obtain more memory from the OS, but it cannot, it still goes ahead and runs a garbage collection cycle as a last-ditch effort to gain some available memory.
</p>
<br><br>
<p>Instead of relying on garbage collections happening automatically at unspecified times, a garbage collection cycle can be started explicitly using :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> core.memory;

<span class="comment">// ...
</span>
    GC.collect();    <span class="comment">// starts a garbage collection cycle
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Normally, the GC does not return memory blocks back to the operating system; it holds on to those memory pages for future needs of the program. If desired, the GC can be asked to give unused memory back to the operating system using :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    GC.minimize();
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<h5>Allocating memory</h5>
<br><br>
<p>System languages allow programmers to specify the memory areas where objects should live. Such memory areas are commonly called <i>buffers</i>.
</p>
<br><br>
<p>There are several methods of allocating memory. The simplest method would be using a fixed-length array:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">ubyte</span>[100] buffer;    <span class="comment">// A memory area of 100 bytes
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>    is ready to be used as a 100-byte memory area. Instead of , it is also possible to define such buffers as arrays of , without any association to any type. Since  cannot be assigned any value, it cannot have the  value either. Such arrays must be initialized by the special syntax :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">void</span>[100] buffer = <span class="keyword">void</span>;    <span class="comment">// A memory area of 100 bytes
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p> We will use only  from the  module to reserve memory in this chapter. That module has many other features that are useful in various situations. Additionally, the memory allocation functions of the C standard library are avaliable in the  module.
</p>
<br><br>
<p> allocates a memory area of the specified size pre-filled with all 0 values, and returns the beginning address of the allocated area:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> core.memory;
<span class="comment">// ...
</span>    <span class="keyword">void</span> * buffer = GC.calloc(100);
                            <span class="comment">// A memory area of 100 zero bytes
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p> Normally, the returned  value is cast to a pointer of the proper type:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span> * intBuffer = <span class="keyword">cast</span>(<span class="keyword">int</span>*)buffer;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>However, that intermediate step is usually skipped and the return value is cast directly:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span> * intBuffer = GC.calloc(100);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Instead of arbitrary values like 100, the size of the memory area is usually calculated by multiplying the number of elements needed with the size of each element:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="comment">// Allocate room for 25 ints
</span>    <span class="keyword">int</span> * intBuffer = <span class="keyword">cast</span>(<span class="keyword">int</span>*)GC.calloc();
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>  There is an important difference for classes: The size of a class variable and the size of a class object are not the same.  is the size of a class variable and is always the same value: 8 on 64-bit systems and 4 on 32-bit systems. The size of a class object must be obtained by :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="comment">// Allocate room for 10 MyClass objects
</span>    MyClass * buffer =
        <span class="keyword">cast</span>(MyClass*)GC.calloc(
             * 10);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p> When there is not enough memory in the system for the requested size, then a  exception is thrown:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">void</span> * buffer = GC.calloc(10_000_000_000);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The output on a system that does not have that much free space:
</p>
<br><br>

<br><br>
<p> The memory areas that are allocated from the GC can be returned back to it using :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    GC.free(buffer);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>However, calling  does not necessarily execute the destructors of the variables that live on that memory block. The destructors may be executed explicitly by calling  for each variable. Note that various internal mechanisms are used to call finalizers on  and  variables during GC collection or freeing. The best way to ensure these are called is to use the  operator when allocating variables. In that case,  will call the destructors.
</p>
<br><br>
<p> Sometimes the program may determine that a previously allocated memory area is all used up and does not have room for more data. It is possible to <i>extend</i> a previously allocated memory area by .  takes the previously allocated memory pointer and the newly requested size, and returns a new area:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">void</span> * oldBuffer = GC.calloc(100);
<span class="comment">// ...
</span>    <span class="keyword">void</span> * newBuffer = GC.realloc(oldBuffer, 200);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p> tries to be efficient by not actually allocating new memory unless it is really necessary:
</p>
<br><br>
<ul><br><br>
<li>If the memory area following the old area is not in use for any other purpose and is large enough to satisfy the new request,  adds that part of the memory to the old area, extending the buffer <i>in-place</i>.</li>
<br><br>
<li>If the memory area following the old area is already in use or is not large enough, then  allocates a new larger memory area and copies the contents of the old area to the new one.</li>
<br><br>
<li>It is possible to pass  as , in which case  simply allocates new memory.</li>
<br><br>
<li>It is possible to pass a size less than the previous one, in which case the remaining part of the old memory is returned back to the GC.</li>
<br><br>
<li>It is possible to pass 0 as the new size, in which case  simply frees the memory.</li>
<br><br>
</ul>
<br><br>
<p> is adapted from the C standard library function . For having such a complicated behavior,  is considered to have a badly designed function interface. A potentially surprising aspect of  is that even if the original memory has been allocated with , the extended part is never cleared. For that reason, when it is important that the memory is zero-initialized, a function like  below would be useful. We will see the meaning of  later below:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> core.memory;

<span class="comment">/* Works like GC.realloc but clears the extra bytes if memory
 * is extended. */</span>
<span class="keyword">void</span> * reallocCleared(
    <span class="keyword">void</span> * buffer,
    size_t oldLength,
    size_t newLength,
    GC.BlkAttr blockAttributes = GC.BlkAttr.NONE,
    <span class="keyword">const</span> TypeInfo typeInfo = <span class="keyword">null</span>) {
    <span class="comment">/* Dispatch the actual work to GC.realloc. */</span>
    buffer = GC.realloc(buffer, newLength,
                        blockAttributes, typeInfo);

    <span class="comment">/* Clear the extra bytes if extended. */</span>
    <span class="keyword">if</span> (newLength &gt; oldLength) {
        <span class="keyword">import</span> core.stdc.string;

        <span class="keyword">auto</span> extendedPart = buffer + oldLength;
        <span class="keyword">const</span> extendedLength = newLength - oldLength;

        memset(extendedPart, 0, extendedLength);
    }

    <span class="keyword">return</span> buffer;
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p> The function above uses  from the  module to clear the newly extended bytes.  assigns the specified value to the bytes of a memory area specified by a pointer and a length. In the example, it assigns  to  number of bytes at .
</p>
<br><br>
<p>We will use  in an example below.
</p>
<br><br>
<p> The behavior of the similar function  is not complicated like ; it applies only the first item above: If the memory area cannot be extended in-place,  does not do anything and returns 0.
</p>
<br><br>
<h6>  Memory block attributes</h6>
<br><br>
<p>The concepts and the steps of a GC algorithm can be configured to some degree for each memory block by .  is an optional parameter of  and other allocation functions. It consists of the following values:
</p>
<br><br>
<ul><br><br>
<li>: The value zero; specifies <i>no attribute</i>.</li>
<br><br>
<li>: Specifies that the objects that live in the memory block should be finalized.
<br><br>
<p>Normally, the GC assumes that the lifetimes of objects that live on explicitly-allocated memory locations are under the control of the programmer; it does not finalize objects on such memory areas.  is for requesting the GC to execute the destructors of objects:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    Class * buffer =
        <span class="keyword">cast</span>(Class*)GC.calloc(
            <span class="keyword">__traits</span>(classInstanceSize, Class) * 10,
            GC.BlkAttr.FINALIZE);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Note that  depends on implementation details properly set up on the block. It is highly recommended to let the GC take care of setting up these details using the  operator.
</p>
<br><br>
</li>
<br><br>
<li>: Specifies that the memory area should not be scanned by the GC.
<br><br>
<p>The byte values in a memory area may accidentally look like pointers to unrelated objects in other parts of the memory. When that happens, the GC would assume that those objects are still in use even after their actual lifetimes have ended.
</p>
<br><br>
<p>A memory block that is known to not contain any object pointers should be marked as :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">int</span> * intBuffer =
        <span class="keyword">cast</span>(<span class="keyword">int</span>*)GC.calloc(100, GC.BlkAttr.NO_SCAN);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The  variables placed in that memory block can have any value without concern of being mistaken for object pointers.
</p>
<br><br>
</li>
<br><br>
<li>: Specifies that objects in the memory block should not be moved to other places.</li>
<br><br>
<li>: This is an internal flag used by the D runtime to aid in fast appending. You should not use this flag when allocating memory.</li>
<br><br>
<li>: Specifies that only pointers to the block's first address exist. This allows one to cut down on "false pointers" because a pointer to the middle of the block does not count when tracing where a pointer goes.</li>
<br><br>
</ul>
<br><br>
<p> The values of  are suitable to be used as bit flags that we saw in <a href="bit_operations.html">the Bit Operations chapter</a>. The following is how two attributes can be merged by the  operator:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">const</span> attributes =
        GC.BlkAttr.NO_SCAN  GC.BlkAttr.NO_INTERIOR;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Naturally, the GC would be aware only of memory blocks that are reserved by its own functions and scans only those memory blocks. For example, it would not know about a memory block allocated by .
</p>
<br><br>
<p>    is for introducing unrelated memory blocks to the GC. The complement function  should be called before freeing a memory block by other means e.g. by .
</p>
<br><br>
<p>In some cases, there may be no reference in the program to a memory block even if that memory block has been reserved by the GC. For example, if the only reference to a memory block lives inside a C library, the GC would normally not know about that reference and assume that the memory block is not in use anymore.
</p>
<br><br>
<p> introduces a memory block to the GC as a <i>root</i>, to be scanned during collection cycles. All of the variables that can be reached directly or indirectly through that memory block would be marked as alive. The complement function  should be called when a memory block is not in use anymore.
</p>
<br><br>
<h6>Example of extending a memory area</h6>
<br><br>
<p>Let's design a simple  template that works like an array. To keep the example short, let's provide only the functionality of adding and accessing elements. Similar to arrays, let's increase the capacity as needed. The following program uses , which has been defined above:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> Array(T) {
    T * buffer;         <span class="comment">// Memory area that holds the elements
</span>    size_t capacity;    <span class="comment">// The element capacity of the buffer
</span>    size_t length;      <span class="comment">// The number of actual elements
</span>
    <span class="comment">/* Returns the specified element */</span>
    T element(size_t index) {
        <span class="keyword">import</span> std.string;
        enforce(index &lt; length,
                format(<span class="string_literal">"Invalid index %s"</span>, index));

        <span class="keyword">return</span> *(buffer + index);
    }

    <span class="comment">/* Appends the element to the end */</span>
    <span class="keyword">void</span> append(T element) {
        writefln(<span class="string_literal">"Appending element %s"</span>, length);

        <span class="keyword">if</span> (length == capacity) {
            <span class="comment">/* There is no room for the new element; must
             * increase capacity. */</span>
            size_t newCapacity = capacity + (capacity / 2) + 1;
            increaseCapacity(newCapacity);
        }

        <span class="comment">/* Place the element at the end */</span>
        *(buffer + length) = element;
        ++length;
    }

    <span class="keyword">void</span> increaseCapacity(size_t newCapacity) {
        writefln(<span class="string_literal">"Increasing capacity from %s to %s"</span>,
                 capacity, newCapacity);

        size_t oldBufferSize = capacity * T.sizeof;
        size_t newBufferSize = newCapacity * T.sizeof;

        <span class="comment">/* Also specify that this memory block should not be
         * scanned for pointers. */</span>
        buffer = <span class="keyword">cast</span>(T*)(
            buffer, oldBufferSize, newBufferSize,
            GC.BlkAttr.NO_SCAN);

        capacity = newCapacity;
    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The capacity of the array grows by about 50%. For example, after the capacity for 100 elements is consumed, the new capacity would become 151. (<i>The extra 1 is for the case of 0 length, where adding 50% would not grow the array.</i>)
</p>
<br><br>
<p>The following program uses that template with the  type:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;
<span class="keyword">import</span> core.memory;
<span class="keyword">import</span> std.exception;

<span class="comment">// ...
</span>
<span class="keyword">void</span> main() {
    <span class="keyword">auto</span> array = Array!<span class="keyword">double</span>();

    <span class="keyword">const</span> count = 10;

    <span class="keyword">foreach</span> (i; 0 .. count) {
        <span class="keyword">double</span> elementValue = i * 1.1;
        array.append(elementValue);
    }

    writeln(<span class="string_literal">"The elements:"</span>);

    <span class="keyword">foreach</span> (i; 0 .. count) {
        write(array.element(i), ' ');
    }

    writeln();
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The output:
</p>
<br><br>

<br><br>
<h5> Alignment</h5>
<br><br>
<p>By default, every object is placed at memory locations that are multiples of an amount specific to the type of that object. That amount is called the <i>alignment</i> of that type. For example, the alignment of  is 4 because  variables are placed at memory locations that are multiples of 4 (4, 8, 12, etc.).
</p>
<br><br>
<p>Alignment is needed for CPU performance or requirements, because accessing misaligned memory addresses can be slower or cause a bus error. In addition, certain types of variables only work properly at aligned addresses.
</p>
<br><br>
<h6> The  property</h6>
<br><br>
<p> The  property of a type is its default alignment value. For classes,  is the alignment of the class variable, not the class object. The alignment of a class object is obtained by .
</p>
<br><br>
<p>The following program prints the alignments of various types:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;
<span class="keyword">import</span> std.meta;
<span class="keyword">import</span> std.traits;

<span class="keyword">struct</span> EmptyStruct {
}

<span class="keyword">struct</span> Struct {
    <span class="keyword">char</span> c;
    <span class="keyword">double</span> d;
}

<span class="keyword">class</span> EmptyClass {
}

<span class="keyword">class</span> Class {
    <span class="keyword">char</span> c;
}

<span class="keyword">void</span> main() {
    <span class="keyword">alias</span> Types = AliasSeq!(<span class="keyword">char</span>, <span class="keyword">short</span>, <span class="keyword">int</span>, <span class="keyword">long</span>,
                            <span class="keyword">double</span>, <span class="keyword">real</span>,
                            string, <span class="keyword">int</span>[<span class="keyword">int</span>], <span class="keyword">int</span>*,
                            EmptyStruct, Struct,
                            EmptyClass, Class);

    writeln(<span class="string_literal">" Size  Alignment  Type\n"</span>,
            <span class="string_literal">"========================="</span>);

    <span class="keyword">foreach</span> (Type; Types) {
        <span class="keyword">static</span> <span class="keyword">if</span> (<span class="keyword">is</span> (Type == <span class="keyword">class</span>)) {
            size_t size = <span class="keyword">__traits</span>(classInstanceSize, Type);
            size_t alignment = ;

        } <span class="keyword">else</span> {
            size_t size = Type.sizeof;
            size_t alignment = ;
        }

        writefln(<span class="string_literal">"%4s%8s      %s"</span>,
                 size, alignment, Type.stringof);
    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The output of the program may be different in different environments. The following is a sample output:
</p>
<br><br>

<br><br>
<p>We will see later below how variables can be constructed (emplaced) at specific memory locations. For correctness and efficiency, objects must be constructed at addresses that match their alignments.
</p>
<br><br>
<p>Let's consider two <i>consecutive</i> objects of  type above, which are 17 bytes each. Although 0 is not a legal address for a variable on most platforms, to simplify the example let's assume that the first object is at address 0. The 17 bytes of this object would be at adresses from 0 to 16:
</p>
<br><br>

<br><br>
<p> Although the next available address is 17, that location cannot be used for a  object because 17 is not a multiple of the alignment value 8 of that type. The nearest possible address for the second object is 24 because 24 is the next smallest multiple of 8. When the second object is placed at that address, there would be unused bytes between the two objects. Those bytes are called <i>padding bytes</i>:
</p>
<br><br>
<p></p>
<br><br>

<br><br>
<p>The following formula can determine the nearest address value that an object can be placed at:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    (candidateAddress + alignmentValue - 1)
    / alignmentValue
    * alignmentValue
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>For that formula to work, the fractional part of the result of the division must be truncated. Since truncation is automatic for integral types, all of the variables above are assumed to be integral types.
</p>
<br><br>
<p>We will use the following function in the examples later below:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">T * nextAlignedAddress(T)(T * candidateAddr) {
    <span class="keyword">import</span> std.traits;

    <span class="keyword">static</span> <span class="keyword">if</span> (<span class="keyword">is</span> (T == <span class="keyword">class</span>)) {
        <span class="keyword">const</span> alignment = <span class="keyword">__traits</span>(classInstanceAlignment, T);
    } <span class="keyword">else</span> {
        <span class="keyword">const</span> alignment = T.alignof;
    }

    <span class="keyword">const</span> result = (<span class="keyword">cast</span>(size_t)candidateAddr + alignment - 1)
                   / alignment * alignment;
    <span class="keyword">return</span> <span class="keyword">cast</span>(T*)result;
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>That function template deduces the type of the object from its template parameter. Since that is not possible when the type is , the type must be provided as an explicit template argument for the  overload. That overload can trivially forward the call to the function template above:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">void</span> * nextAlignedAddress(T)(<span class="keyword">void</span> * candidateAddr) {
    <span class="keyword">return</span> nextAlignedAddress(<span class="keyword">cast</span>(T*)candidateAddr);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The function template above will be useful below when constructing <i>class</i> objects by .
</p>
<br><br>
<p>Let's define one more function template to calculate the total size of an object including the padding bytes that must be placed between two objects of that type:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">size_t sizeWithPadding(T)() {
    <span class="keyword">static</span> <span class="keyword">if</span> (<span class="keyword">is</span> (T == <span class="keyword">class</span>)) {
        <span class="keyword">const</span> candidateAddr = <span class="keyword">__traits</span>(classInstanceSize, T);

    } <span class="keyword">else</span> {
        <span class="keyword">const</span> candidateAddr = T.sizeof;
    }

    <span class="keyword">return</span> <span class="keyword">cast</span>(size_t)nextAlignedAddress(<span class="keyword">cast</span>(T*)candidateAddr);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<h6> The  property</h6>
<br><br>
<p>Alignment is observed for members of user-defined types as well. There may be padding bytes <i>between</i> members so that the members are aligned according to their respective types. For that reason, the size of the following  is not 6 bytes as one might expect, but 12:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> A {
    <span class="keyword">byte</span> b;     <span class="comment">// 1 byte
</span>    <span class="keyword">int</span> i;      <span class="comment">// 4 bytes
</span>    <span class="keyword">ubyte</span> u;    <span class="comment">// 1 byte
</span>}

<span class="keyword">static</span> <span class="keyword">assert</span>();    <span class="comment">// More than 1 + 4 + 1
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>This is due to padding bytes before the  member so that it is aligned at an address that is a multiple of 4, as well as padding bytes at the end for the alignment of the entire  object itself.
</p>
<br><br>
<p>The  property gives the number of bytes a member variable is from the beginning of the object that it is a part of. The following function prints the layout of a type by determining the padding bytes by :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">void</span> printObjectLayout(T)()
        <span class="keyword">if</span> (<span class="keyword">is</span> (T == <span class="keyword">struct</span>) || <span class="keyword">is</span> (T == <span class="keyword">union</span>)) {
    <span class="keyword">import</span> std.stdio;
    <span class="keyword">import</span> std.string;

    writefln(<span class="string_literal">"=== Memory layout of '%s'"</span> ~
             <span class="string_literal">" (.sizeof: %s, .alignof: %s) ==="</span>,
             T.stringof, T.sizeof, T.alignof);

    <span class="comment">/* Prints a single line of layout information. */</span>
    <span class="keyword">void</span> printLine(size_t offset, string info) {
        writefln(<span class="string_literal">"%4s: %s"</span>, offset, info);
    }

    <span class="comment">/* Prints padding information if padding is actually
     * observed. */</span>
    <span class="keyword">void</span> maybePrintPaddingInfo(size_t expectedOffset,
                               size_t actualOffset) {
        <span class="keyword">if</span> (expectedOffset &lt; actualOffset) {
            <span class="comment">/* There is some padding because the actual offset
             * is beyond the expected one. */</span>

            <span class="keyword">const</span> paddingSize = actualOffset - expectedOffset;

            printLine(expectedOffset,
                      format(<span class="string_literal">"... %s-byte PADDING"</span>,
                             paddingSize));
        }
    }

    <span class="comment">/* This is the expected offset of the next member if there
     * were no padding bytes before that member. */</span>
    size_t noPaddingOffset = 0;

    <span class="comment">/* Note: __traits(allMembers) is a 'string' collection of
     * names of the members of a type. */</span>
    <span class="keyword">foreach</span> (memberName; <span class="keyword">__traits</span>(allMembers, T)) {
        <span class="keyword">mixin</span> (format(<span class="string_literal">"alias member = %s.%s;"</span>,
                      T.stringof, memberName));

        <span class="keyword">const</span> offset = member;
        maybePrintPaddingInfo(noPaddingOffset, offset);

        <span class="keyword">const</span> typeName = <span class="keyword">typeof</span>(member).stringof;
        printLine(offset,
                  format(<span class="string_literal">"%s %s"</span>, typeName, memberName));

        noPaddingOffset = offset + member.sizeof;
    }

    maybePrintPaddingInfo(noPaddingOffset, T.sizeof);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The following program prints the layout of the 12-byte  that was defined above:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> A {
    <span class="keyword">byte</span> b;
    <span class="keyword">int</span> i;
    <span class="keyword">ubyte</span> u;
}

<span class="keyword">void</span> main() {
    printObjectLayout!A();
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The output of the program showns where the total of 6 padding bytes are located inside the object. The first column of the output is the offset from the beginning of the object:
</p>
<br><br>

<br><br>
<p>One technique of minimizing padding is ordering the members by their sizes from the largest to the smallest. For example, when the  member is moved to the beginning of the previous  then the size of the object would be less:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">struct</span> B {
        <span class="comment">// Moved up inside the struct definition
</span>    <span class="keyword">byte</span> b;
    <span class="keyword">ubyte</span> u;
}

<span class="keyword">void</span> main() {
    printObjectLayout!B();
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>This time, the size of the object is down to 8 due to just 2 bytes of padding at the end:
</p>
<br><br>

<br><br>
<h6> The  attribute</h6>
<br><br>
<p>The  attribute is for specifying alignments of variables, user-defined types, and members of user-defined types. The value provided in parentheses specifies the alignment value. Every definition can be specified separately. For example, the following definition would align  objects at 2-byte boundaries and its  member at 1-byte boundaries (1-byte alignment always results in no padding at all):
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">               <span class="comment">// The alignment of 'S' objects
</span><span class="keyword">struct</span> S {
    <span class="keyword">byte</span> b;
     <span class="keyword">int</span> i;    <span class="comment">// The alignment of member 'i'
</span>    <span class="keyword">ubyte</span> u;
}

<span class="keyword">void</span> main() {
    printObjectLayout!S();
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>When the  member is aligned at a 1-byte boundary, there is no padding before it and this time the size of the object ends up being exactly 6:
</p>
<br><br>

<br><br>
<p>Although  can reduce sizes of user-defined types, there can be <i>significant performance penalties</i> when default alignments of types are not observed (and on some CPUs, using misaligned data can actually crash the program).
</p>
<br><br>
<p> can specify the alignment of variables as well:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">     <span class="keyword">double</span> d;    <span class="comment">// The alignment of a variable
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>However, objects that are allocated by  must always be aligned at multiples of the size of the  type because that is what the GC assumes. Doing otherwise is undefined behavior. For example, if  is 8 bytes long, than the alignments of variables allocated by  must be a multiple of 8.
</p>
<br><br>
<h5>  Constructing variables at specific memory locations</h5>
<br><br>
<p> The  expression achieves three tasks:
</p>
<br><br>
<ol><br><br>
<li>Allocates memory large enough for the object. The newly allocated memory area is considered to be <i>raw</i>, not associated with any type or any object.
</li>
<br><br>
<li>Copies the  value of that type on that memory area and executes the constructor of the object on that area. Only after this step the object becomes <i>placed</i> on that memory area.
</li>
<br><br>
<li>Configures the memory block so it has all the necessary flags and infrastructure to properly destroy the object when freed.
</li>
<br><br>
</ol>
<br><br>
<p>We have already seen that the first of these tasks can explicitly be achieved by memory allocation functions like . Being a system language, D allows the programmer manage the second step as well.
</p>
<br><br>
<p>Variables can be constructed at specific locations with .
</p>
<br><br>
<h6> Constructing a struct object at a specific location</h6>
<br><br>
<p> takes the address of a memory location as its first parameter and constructs an object at that location. If provided, it uses the remaining parameters as the object's constructor arguments:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.conv;
<span class="comment">// ...
</span>    emplace(<i>address</i>, <span class="comment">/* ... constructor arguments ... */</span>);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>It is not necessary to specify the type of the object explicitly when constructing a  object because  deduces the type of the object from the type of the pointer. For example, since the type of the following pointer is ,  constructs a  object at that address:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">        Student * objectAddr = nextAlignedAddress(candidateAddr);
<span class="comment">// ...
</span>        emplace(objectAddr, name, id);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The following program allocates a memory area large enough for three objects and constructs them one by one at aligned addresses inside that memory area:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;
<span class="keyword">import</span> std.string;
<span class="keyword">import</span> core.memory;
<span class="keyword">import</span> std.conv;

<span class="comment">// ...
</span>
<span class="keyword">struct</span> Student {
    string name;
    <span class="keyword">int</span> id;

    string toString() {
        <span class="keyword">return</span> format(<span class="string_literal">"%s(%s)"</span>, name, id);
    }
}

<span class="keyword">void</span> main() {
    <span class="comment">/* Some information about this type. */</span>
    writefln(<span class="string_literal">"Student.sizeof: %#x (%s) bytes"</span>,
             Student.sizeof, Student.sizeof);
    writefln(<span class="string_literal">"Student.alignof: %#x (%s) bytes"</span>,
             Student.alignof, Student.alignof);

    string[] names = [ <span class="string_literal">"Amy"</span>, <span class="string_literal">"Tim"</span>, <span class="string_literal">"Joe"</span> ];
    <span class="keyword">const</span> totalSize = sizeWithPadding!Student() * names.length;

    <span class="comment">/* Reserve room for all Student objects.
     *
     * Warning! The objects that are accessible through this
     * slice are not constructed yet; they should not be
     * accessed until after they are properly constructed. */</span>
    Student[] students =
        (<span class="keyword">cast</span>(Student*)GC.calloc(totalSize))[0 .. names.length];

    <span class="keyword">foreach</span> (i, name; names) {
        Student * candidateAddr = students.ptr + i;
        Student * objectAddr =
            nextAlignedAddress(candidateAddr);
        writefln(<span class="string_literal">"address of object %s: %s"</span>, i, objectAddr);

        <span class="keyword">const</span> id = 100 + i.to!<span class="keyword">int</span>;
        (objectAddr, name, id);
    }

    <span class="comment">/* All of the objects are constructed and can be used. */</span>
    writeln(students);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The output of the program:
</p>
<br><br>

<br><br>
<h6> Constructing a class object at a specific location</h6>
<br><br>
<p>Class variables need not be of the exact type of class objects. For example, a class variable of type  can refer to a  object. For that reason,  does not determine the type of the object from the type of the memory pointer. Instead, the actual type of the object must be explicitly specified as a template argument of . (<i><b>Note:</b> Additionally, a class pointer is a pointer to a class variable, not to a class object. For that reason, specifying the actual type allows the programmer to specify whether to emplace a class object or a class variable.</i>)
</p>
<br><br>
<p> The memory location for a class object must be specified as a  slice with the following syntax:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    Type variable =
        emplace!<i>Type</i>(<i>voidSlice</i>,
                         <span class="comment">/* ... constructor arguments ... */</span>);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p> constructs a class <i>object</i> at the location specified by the slice and returns a class <i>variable</i> for that object.
</p>
<br><br>
<p>Let's use  on objects of an  hierarchy. The objects of this hierarchy will be placed <i>side-by-side</i> on a piece of memory that is allocated by . To make the example more interesting, we will ensure that the subclasses have different sizes. This will be useful to demonstrate how the address of a subsequent object can be determined depending on the size of the previous one.
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">interface</span> Animal {
    string sing();
}

<span class="keyword">class</span> Cat : Animal {
    string sing() {
        <span class="keyword">return</span> <span class="string_literal">"meow"</span>;
    }
}

<span class="keyword">class</span> Parrot : Animal {
    string[] lyrics;

    <span class="keyword">this</span>(string[] lyrics) {
        <span class="keyword">this</span>.lyrics = lyrics;
    }

    string sing() {
        <span class="comment">/* std.algorithm.joiner joins elements of a range with
         * the specified separator. */</span>
        <span class="keyword">return</span> lyrics.joiner(<span class="string_literal">", "</span>).to!string;
    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The buffer that holds the objects will be allocated with :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">const</span> capacity = 10_000;
    <span class="keyword">void</span> * buffer = GC.calloc(capacity);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Normally, it must be ensured that there is always available capacity for objects. We will ignore that check here to keep the example simple and assume that the objects in the example will fit in ten thousand bytes.
</p>
<br><br>
<p>The buffer will be used for constructing a  and a  object:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    Cat cat = emplace!Cat(catPlace);
<span class="comment">// ...
</span>    Parrot parrot =
        emplace!Parrot(parrotPlace, [ <span class="string_literal">"squawk"</span>, <span class="string_literal">"arrgh"</span> ]);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Note that the constructor argument of  is specified after the address of the object.
</p>
<br><br>
<p>The variables that  returns will be stored in an  slice later to be used in a  loop:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    Animal[] animals;
<span class="comment">// ...
</span>    animals ~= cat;
<span class="comment">// ...
</span>    animals ~= parrot;

    <span class="keyword">foreach</span> (animal; animals) {
        writeln(animal.sing());
    }
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>More explanations are inside the code comments:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;
<span class="keyword">import</span> std.algorithm;
<span class="keyword">import</span> std.conv;
<span class="keyword">import</span> core.memory;

<span class="comment">// ...
</span>
<span class="keyword">void</span> main() {
    <span class="comment">/* A slice of Animal variables (not Animal objects). */</span>
    Animal[] animals;

    <span class="comment">/* Allocating a buffer with an arbitrary capacity and
     * assuming that the two objects in this example will fit
     * in that area. Normally, this condition must be
     * validated. */</span>
    <span class="keyword">const</span> capacity = 10_000;
    <span class="keyword">void</span> * buffer = GC.calloc(capacity);

    <span class="comment">/* Let's first place a Cat object. */</span>
    <span class="keyword">void</span> * catCandidateAddr = buffer;
    <span class="keyword">void</span> * catAddr = nextAlignedAddress!Cat(catCandidateAddr);
    writeln(<span class="string_literal">"Cat address   : "</span>, catAddr);

    <span class="comment">/* Since emplace() requires a void[] for a class object,
     * we must first produce a slice from the pointer. */</span>
    size_t catSize = <span class="keyword">__traits</span>(classInstanceSize, Cat);
    <span class="keyword">void</span>[] catPlace = catAddr[0..catSize];

    <span class="comment">/* Construct a Cat object inside that memory slice and
     * store the returned class variable for later use. */</span>
    Cat cat = (catPlace);
    animals ~= cat;

    <span class="comment">/* Now construct a Parrot object at the next available
     * address that satisfies the alignment requirement. */</span>
    <span class="keyword">void</span> * parrotCandidateAddr = catAddr + catSize;
    <span class="keyword">void</span> * parrotAddr =
        nextAlignedAddress!Parrot(parrotCandidateAddr);
    writeln(<span class="string_literal">"Parrot address: "</span>, parrotAddr);

    size_t parrotSize = <span class="keyword">__traits</span>(classInstanceSize, Parrot);
    <span class="keyword">void</span>[] parrotPlace = parrotAddr[0..parrotSize];

    Parrot parrot =
        (parrotPlace, [ <span class="string_literal">"squawk"</span>, <span class="string_literal">"arrgh"</span> ]);
    animals ~= parrot;

    <span class="comment">/* Use the objects. */</span>
    <span class="keyword">foreach</span> (animal; animals) {
        writeln(animal.sing());
    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The output:
</p>
<br><br>

<br><br>
<p>Instead of repeating the steps inside  for each object, a function template like  would be more useful.
</p>
<br><br>
<h5>Destroying objects explicitly</h5>
<br><br>
<p>The reverse operations of the  operator are destroying an object and returning the object's memory back to the GC. Normally, these operations are executed automatically at unspecified times.
</p>
<br><br>
<p>However, sometimes it is necessary to execute destructors at specific points in the program. For example, an object may be closing a  member in its destructor and the destructor may have to be executed immediately when the lifetime of the object ends.
</p>
<br><br>
<p>  calls the destructor of an object:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    destroy(variable);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p> After executing the destructor,  sets the variable to its  state. Note that the  state of a class variable is ; so, a class variable cannot be used once destroyed.  merely executes the destructor. It is still up to the GC when to reuse the piece of memory that used to be occupied by the destroyed object.
</p>
<br><br>
<p><b>Warning:</b> When used with a <i>struct</i> pointer,  must receive the pointee, not the pointer. Otherwise, the pointer would be set to  but the object would not be destroyed:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;

<span class="keyword">struct</span> S {
    <span class="keyword">int</span> i;

    <span class="keyword">this</span>(<span class="keyword">int</span> i) {
        <span class="keyword">this</span>.i = i;
        writefln(<span class="string_literal">"Constructing object with value %s"</span>, i);
    }

    ~<span class="keyword">this</span>() {
        writefln(<span class="string_literal">"Destroying object with value %s"</span>, i);
    }
}

<span class="keyword">void</span> main() {
    <span class="keyword">auto</span> p = <span class="keyword">new</span> S(42);

    writeln(<span class="string_literal">"Before destroy()"</span>);
    destroy();                        <span class="comment">//  WRONG USAGE
</span>    writeln(<span class="string_literal">"After destroy()"</span>);

    writefln(<span class="string_literal">"p: %s"</span>, p);

    writeln(<span class="string_literal">"Leaving main"</span>);
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>When  receives a pointer, it is the pointer that gets destroyed (i.e. the pointer becomes ):
</p>
<br><br>

<br><br>
<p>For that reason, when used with a struct pointer,  must receive the pointee:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    destroy();                       <span class="comment">//  Correct usage
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>This time the destructor is executed at the right spot and the pointer is not set to :
</p>
<br><br>

<br><br>
<p>The last line is due to executing the destructor one more time for the same object, which now has the value .
</p>
<br><br>
<h5> Constructing objects at run time by name</h5>
<br><br>
<p>  The  member function of  takes the fully qualified name of a class type as parameter, constructs an object of that type, and returns a class variable for that object:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">;

<span class="keyword">import</span> std.stdio;

<span class="keyword">interface</span> Animal {
    string sing();
}

<span class="keyword">class</span> Cat : Animal {
    string sing() {
        <span class="keyword">return</span> <span class="string_literal">"meow"</span>;
    }
}

<span class="keyword">class</span> Dog : Animal {
    string sing() {
        <span class="keyword">return</span> <span class="string_literal">"woof"</span>;
    }
}

<span class="keyword">void</span> main() {
    string[] toConstruct = [ <span class="string_literal">"Cat"</span>, <span class="string_literal">"Dog"</span>, <span class="string_literal">"Cat"</span> ];

    Animal[] animals;

    <span class="keyword">foreach</span> (typeName; toConstruct) {
        <span class="comment">/* The pseudo variable __MODULE__ is always the name
         * of the current module, which can be used as a
         * string literal at compile time. */</span>
        <span class="keyword">const</span> fullName = <span class="keyword">__MODULE__</span> ~ '.' ~ typeName;
        writefln(<span class="string_literal">"Constructing %s"</span>, fullName);
        animals ~= <span class="keyword">cast</span>(Animal)(fullName);
    }

    <span class="keyword">foreach</span> (animal; animals) {
        writeln(animal.sing());
    }
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Although there is no explicit  expression in that program, three class objects are created and added to the  slice:
</p>
<br><br>

<br><br>
<p>Note that  takes the fully qualified name of the type of the object. Also, the return type of  is ; so, it must be cast to the actual type of the object before being used in the program.
</p>
<br><br>
<h5>Summary</h5>
<br><br>
<ul><li>The garbage collector scans the memory at unspecified times, determines the objects that cannot possibly be reached anymore by the program, destroys them, and reclaims their memory locations.</li>
<br><br>
<li>The operations of the GC may be controlled by the programmer to some extent by , , , , etc.</li>
<br><br>
<li> and other functions reserve memory,  extends a previously allocated memory area, and  returns it back to the GC.</li>
<br><br>
<li>It is possible to mark the allocated memory by attributes like , , etc.</li>
<br><br>
<li>The  property is the default memory alignment of a type. Alignment must be obtained by  for class <i>objects</i>.</li>
<br><br>
<li>The  property is the number of bytes a member is from the beginning of the object that it is a part of.</li>
<br><br>
<li>The  attribute specifies the alignment of a variable, a user-defined type, or a member.</li>
<br><br>
<li> takes a pointer when constructing a  object, a  slice when constructing a  object.</li>
<br><br>
<li> executes the destructor of objects. (One must destroy the struct pointee, not the struct pointer.)</li>
<br><br>
<li> constructs objects with their fully qualified type names.</li>
<br><br>
</ul>
<br><br>
macros:
        TITLE=Memory Management
<br><br>
        DESCRIPTION=The memory, the garbage collector, and managing memory explicitly.
<br><br>
        KEYWORDS=d programming language tutorial book integer gc memory
</section>
      </article>
    </div>
  </body>
</html>
