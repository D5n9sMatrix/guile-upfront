
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Object</title>
    <style type="text/css" media="screen">
      html, body, div, span, object, iframe, h1, h2, h3, h4, h5, h6, p,
      blockquote, pre, a, abbr, address, cite, code, del, dfn, em, figure,
      img, ins, kbd, q, s, samp, small, strong, sub, sup, var, b, u, i, dl,
      dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption,
      tbody, tfoot, thead, tr, th, td {
        background: transparent none repeat scroll 0 0;
        border: 0 none;
        font-size: 100%;
        margin: 0;
        outline: 0 none;
        padding: 0;
        vertical-align: baseline;
      }

      h1 { font-size: 200%; }
      h2 { font-size: 160%; }
      h3 { font-size: 120%; }
      h4 { font-size: 100%; }
      h5 { font-size: 80%; }
      h6 { font-size: 80%; font-weight: normal; }

      ul, ol {
        margin: 1.4em 0;
      }
      ul ul, ol ol, ul ol, ol ul {
        margin-top: 0;
        margin-bottom: 0;
      }
      ul, ol {
        margin-left: 2.8em;
      }

      ol {
        list-style: decimal;
      }
      ol ol {
        list-style: lower-alpha;
      }
      ol ol ol {
        list-style: lower-roman;
      }
      ol ol ol ol {
        list-style: decimal;
      }

      blockquote {
        margin: 0.1em;
        margin-left: 1em;
        border-left: 2px solid #cccccc;
        padding-left: 0.7em;
      }

      .color_red { color: #dc322f; }
      .color_blue { color: #268bd2; }
      .color_green { color: #859901; }
      .color_yellow { color: #b58901; }
      .color_black { color: black; }
      .color_white { color: white; }

      .font_big {
        font-size: 1.2em;
      }

      .ddoc_section_h {
        font-weight: bold;
        font-size: 13px;
        line-height: 19.5px;
        margin-top: 11px;
        display: block;
      }

      body.dlang .dlang {
        display: inline-block;
      }

      body.dlang .declaration .dlang {
          display: block;
      }

      body.dlang .ddoc_header_anchor a.dlang {
        display: block;
        color: rgba(0, 136, 204, 1);
        text-decoration: none;
      }

      body.dlang .ddoc_header_anchor .code {
        color: rgba(0, 136, 204, 1);
      }

      #ddoc_main .module {
          border-color: currentColor rgba(233, 233, 233, 1) rgba(233, 233, 233, 1);
          border-style: none solid solid;
          border-width: 0 1px 1px;
          overflow-x: hidden;
          padding: 15px;
      }

      #ddoc_main .section .section {
        margin-top: 0;
      }

      #ddoc_main .ddoc_module_members_section {
          padding: 1px 0 0;
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .ddoc_member, #ddoc_main .ddoc_module_members section.intro {
          background: #fff none repeat scroll 0 0;
          list-style-type: none;
          width: 100%;
      }

      #ddoc_main .ddoc_header_anchor {
          font-size: 1.4em;
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .ddoc_header_anchor > .code {
          display: inline-block;

      }

      #ddoc_main .ddoc_decl {
        background-color: transparent;
        height: 100%;
        left: 0;
        top: 0;
        padding: 0;
        padding-left: 15px;
      }

      #ddoc_main .ddoc_decl .section, #ddoc_main .section.ddoc_sections {
        background: white none repeat scroll 0 0;
        margin: 0;
        padding: 5px;
        position: relative;
        border-radius: 5px;
      }

      #ddoc_main .ddoc_decl .section h4:first-of-type, #ddoc_main .section.ddoc_sections h4:first-of-type {
        font-size: 13px;
        line-height: 1.5;
        margin-top: 21px;
      }

      #ddoc_main .section .declaration {
          margin-top: 21px;
      }

      #ddoc_main .section .declaration .code {
          color: rgba(0, 0, 0, 1);
          margin-bottom: 15px;
          padding-bottom: 6px;
      }

      #ddoc_main .declaration div .para {
          margin-bottom: 0;
      }

      #ddoc_main .ddoc_params .graybox tr td:first-of-type {
        padding: 7px;
        text-align: right;
        vertical-align: top;
        word-break: normal;
        white-space: nowrap;
      }

      #ddoc_main .ddoc_params .graybox {
        border: 0 none;
      }

      #ddoc_main .ddoc_params .graybox td {
        border-color: rgba(214, 214, 214, 1);
      }

      #ddoc_main .ddoc_params .graybox tr:first-child > td {
        border-top: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr:last-child > td {
        border-bottom: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr > td:first-child {
        border-left: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr > td:last-child {
        border-right: 0 none;
        width: 100%;
      }

      #ddoc_main em.term, #ddoc_main em.term .code {
        color: rgba(65, 65, 65, 1);
        font-size: 12px;
        font-style: italic;
        line-height: 1.5;
      }

      #ddoc_main .see-also {
        cursor: pointer;
        font-family: Menlo,monospace;
      }

      #ddoc_main .ddoc_decl .section > div:last-of-type {
        margin-bottom: 15px;
      }

      #ddoc_main .ddoc_member, #ddoc_main .ddoc_module_members {
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .code_sample {
        background: inherit;
      }

      #ddoc_main .declaration .code-line {
          display: block;
          font: 1em Menlo,monospace;
      }

      #ddoc_main a[name] {
        margin: -112px 0 0;
        padding-top: 112px;
      }

      #ddoc_main .ddoc_decl td {
        max-width: inherit;
      }

      #ddoc_main .declaration a {
        color: inherit;
      }

      #ddoc_main .declaration a:hover {
          color: rgba(0, 136, 204, 1);
          text-decoration: underline;
      }

      body.ddoc {
        background-color: transparent;
        color: rgba(0, 0, 0, 1);
        font-family: Helvetica,Arial,sans-serif;
        font-size: 62.5%;
        margin: 0;
        border: 0;
        left: 0;
        top: 0;
        padding: 0;
      }

      .ddoc a[name] {
        display: block;
        height: 0;
        margin: -85px 0 0;
        padding-top: 85px;
        width: 0;
      }

      .ddoc .module {
          border-color: transparent;
          background-color: rgba(255, 255, 255, 1);
          border-color: currentColor rgba(233, 233, 233, 1) rgba(233, 233, 233, 1);
          border-image: none;
          border-style: none solid solid;
          border-width: 0 1px 1px;
          box-shadow: 0 0 1px rgba(0, 0, 0, 0.07);
          display: block;
          margin-left: 0;
          min-height: calc(100% - 173px);
          overflow: auto;
          padding-bottom: 100px;
      }

      .ddoc .content_wrapper {
          background-color: rgba(242, 242, 242, 1);
          margin: 0 auto;
          max-width: 980px;
      }

      .ddoc .section {
        padding: 15px 25px 30px;
      }

      .ddoc .section .section {
        margin: 30px 0 0;
        padding: 0;
      }

      .ddoc .para {
        color: rgba(65, 65, 65, 1);
        font-size: 1.4em;
        line-height: 145%;
        margin-bottom: 15px;
      }

      .ddoc .ddoc_examples .para {
        margin-bottom: 0;
      }

      .ddoc .module_name {
          color: rgba(0, 0, 0, 1);
          display: block;
          font-family: Helvetica;
          font-size: 2.8em;
          font-weight: 100;
          margin-bottom: 0;
          padding: 15px 0;
      }

      .ddoc .module a {
          color: rgba(0, 136, 204, 1);
          text-decoration: none;
      }

      .ddoc .code {
        color: rgba(128, 128, 128, 1);
        font-family: Menlo,monospace;
        font-size: 0.85em;
        word-wrap: break-word;
      }

      .ddoc .code i {
        font-style: normal;
      }

      .ddoc .code .code {
        font-size: 1em;
      }

      .ddoc .code_sample {
        background-clip: padding-box;
        margin: 1px 0;
        text-align: left;
      }

      .ddoc .code_sample {
        display: block;
        font-size: 1.4em;
        margin-left: 21px;
      }

      .ddoc ol .code_sample {
        font-size: 1em;
      }

      .ddoc .code_lines {
        counter-reset: li;
        line-height: 1.6em;
        list-style: outside none none;
        margin: 0;
        padding: 0;
      }

      .ddoc .code_listing .code_sample div {
        margin-left: 13px;
        width: 93%;
      }

      .ddoc .code_listing .code_sample div .code_lines li {
        list-style-type: none;
        margin: 0;
        padding-right: 10px;
      }

      .ddoc .code_sample div .code_lines li::before {
        margin-left: -33px;
        margin-right: 25px;
      }

      .ddoc .code_sample div .code_lines li:nth-child(n+10)::before {
        margin-left: -39px;
        margin-right: 25px;
      }

      .ddoc .code_sample div .code_lines li:nth-child(n+100)::before {
        margin-left: -46px;
        margin-right: 25px;
      }

      .ddoc .code_sample .code_lines .code {
        color: #000;
      }

      .ddoc div.dlang {
        margin: 10px 0 21px;
        padding: 4px 0 2px 10px;
      }

      .ddoc div.dlang {
          margin: 10px 0 21px;
          padding: 4px 0 2px 10px;
      }

      .ddoc div.dlang {
        border-left: 5px solid rgba(0, 155, 51, 0.2);
      }

      .ddoc .code_lines li::before {
        color: rgba(128, 128, 128, 1);
        content: counter(li, decimal);
        counter-increment: li;
        font-family: Menlo,monospace;
        font-size: 0.9em;
        margin-right: 16px;
      }

      .ddoc .code_lines li {
        padding-left: 0;
        white-space: pre-wrap;
      }

      .ddoc .code_lines li:only-of-type::before {
        color: rgba(255, 255, 255, 1);
        content: " ";
      }

      .ddoc .code_lines li:only-of-type {
        color: rgba(255, 255, 255, 1);
        content: " ";
      }

      .ddoc .code_lines li:nth-child(n+10) {
        text-indent: -17px;
      }

      .ddoc .code_lines li:nth-child(n+10)::before {
        margin-right: 12px;
      }

      .ddoc .graybox {
        border: 1px solid rgba(233, 233, 233, 1);
        border-collapse: collapse;
        border-spacing: 0;
        empty-cells: hide;
        margin: 20px 0 36px;
        text-align: left;
      }

      .ddoc .graybox p {
        margin: 0;
        min-width: 50px;
      }

      .ddoc th {
        margin: 0;
        max-width: 260px;
        padding: 5px 10px 5px 10px;
        vertical-align: bottom;
      }

      .ddoc td {
        border: 1px solid rgba(233, 233, 233, 1);
        margin: 0;
        max-width: 260px;
        padding: 5px 10px 5px 10px;
        vertical-align: middle;
      }

      .punctuation {
        color: rgba(0, 0, 0, 1);
      }

      .comment {
        color: rgba(0, 131, 18, 1);
      }

      .operator {
        color: #000;
      }

      .keyword {
        color: rgba(170, 13, 145, 1);
      }

      .keyword_type {
        color: rgba(170, 51, 145, 1);
      }

      .string_literal {
        color: rgba(196, 26, 22, 1);
      }

      .ddoc_psuper_symbol {
        color: rgba(92, 38, 153, 1);
      }

      .param {
        color: rgba(0, 0, 0, 1);
      }

      .psymbol {
        color: rgba(0, 0, 0, 1);
      }

      .ddoc_member_header .ddoc_header_anchor .code {
        font-size: 1em;
      }
    </style>
  </head>
  <body id="ddoc_main" class="ddoc dlang">
    <div class="content_wrapper">
      <article class="module">
        <h1 class="module_name">Object</h1>
        <section id="module_content"><br><br>
<br><br>

<br><br>
<p>Classes that do not explicitly inherit any class, automatically inherit the  class.
</p>
<br><br>
<p>By that definition, the topmost class in any class hierarchy inherits :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="comment">// ": Object" is not written; it is automatic
</span><span class="keyword">class</span> MusicalInstrument  {
    <span class="comment">// ...
</span>}

<span class="comment">// Inherits Object indirectly
</span><span class="keyword">class</span> StringInstrument : MusicalInstrument {
    <span class="comment">// ...
</span>}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Since the topmost class inherits , every class indirectly inherits  as well. In that sense, every class "is an" .
</p>
<br><br>
<p>Every class inherits the following member functions of :
</p>
<br><br>
<ul><li>: The  representation of the object.</li>
<li>: Equality comparison with another object.</li>
<li>: Sort order comparison with another object.</li>
<li>: Associative array hash value.</li>
</ul>
<br><br>
<p>The last three of these functions emphasize the values of objects. They also make a class eligible for being the key type of associative arrays.
</p>
<br><br>
<p>Because these functions are inherited, their redefinitions for the subclasses require the  keyword.
</p>
<br><br>
<p><i><b>Note:</b>  defines other members as well. This chapter will include only those four member functions of it.</i>
</p>
<br><br>
<h5>   and </h5>
<br><br>
<p> is defined in the <a href="http://dlang.org/phobos/object.html"> module</a> (which is not a part of the  package). The  module defines  as well, a class that provides information about types. Every type has a distinct  object. The  <i>expression</i> provides access to the  object that is associated with a particular type. As we will see later below, the  class can be used for determining whether two types are the same, as well as for accessing special functions of a type (, , etc., most of which are not covered in this book).
</p>
<br><br>
<p> is always about the actual run-time type. For example, although both  and  below inherit  directly and  indirectly, the  instances of  and  are different. They are exactly for  and  types, respectively:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">class</span> MusicalInstrument {
}

<span class="keyword">class</span> StringInstrument : MusicalInstrument {
}

<span class="keyword">class</span> Violin : StringInstrument {
}

<span class="keyword">class</span> Guitar : StringInstrument {
}

<span class="keyword">void</span> main() {
    TypeInfo v = (Violin);
    TypeInfo g = (Guitar);
    <span class="keyword">assert</span>(v != g);    
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The  expressions above are being used with <i>types</i> like  itself.  can take an <i>expression</i> as well, in which case it returns the  object for the run-time type of that expression. For example, the following function takes two parameters of different but related types:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;

<span class="comment">// ...
</span>
<span class="keyword">void</span> foo( m,  s) {
    <span class="keyword">const</span> isSame = (<span class="keyword">typeid</span>(m) == <span class="keyword">typeid</span>(s));

    writefln(<span class="string_literal">"The types of the arguments are %s."</span>,
             isSame ? <span class="string_literal">"the same"</span> : <span class="string_literal">"different"</span>);
}

<span class="comment">// ...
</span>
    <span class="keyword">auto</span> a = <span class="keyword">new</span> ();
    <span class="keyword">auto</span> b = <span class="keyword">new</span> ();
    foo(a, b);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Since both arguments to  are two  objects for that particular call,  determines that their types are the same:
</p>
<br><br>

<br><br>
<p>Unlike  and , which never execute their expressions,  always executes the expression that it receives:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.stdio;

<span class="keyword">int</span> foo(string when) {
    writefln(<span class="string_literal">"Called during '%s'."</span>, when);
    <span class="keyword">return</span> 0;
}

<span class="keyword">void</span> main() {
    <span class="keyword">const</span> s = foo(<span class="string_literal">"sizeof"</span>);     <span class="comment">// foo() is not called
</span>    <span class="keyword">alias</span> T = (foo(<span class="string_literal">"typeof"</span>));    <span class="comment">// foo() is not called
</span>    <span class="keyword">auto</span> ti = (foo(<span class="string_literal">"typeid"</span>));    <span class="comment">// foo() is called
</span>}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The output indicates that only the expression of  is executed:
</p>
<br><br>

<br><br>
<p>The reason for this difference is because actual run-time types of expressions may not be known until those expressions are executed. For example, the exact return type of the following function would be either  or  depending on the value of function argument :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">MusicalInstrument foo(<span class="keyword">int</span> i) {
    <span class="keyword">return</span> ( % 2) ? <span class="keyword">new</span> Violin() : <span class="keyword">new</span> Guitar();
}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>  There are various subclasses of  for various kinds of types like arrays, structs, classes, etc. Of these,  can be particularly useful. For example, the name of the run-time type of an object can be obtained through its  property as a . You can access the  instance of an object by its  property:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    TypeInfo_Class info = a;
    string runtimeTypeName = info;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<h5> </h5>
<br><br>
<p>Same with structs,  enables using class objects as strings:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">auto</span> clock = <span class="keyword">new</span> Clock(20, 30, 0);
    writeln(clock);         <span class="comment">// Calls clock.toString()
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The inherited  is usually not useful; it produces just the name of the type:
</p>
<br><br>

<br><br>
<p>The part before the name of the type is the name of the module. The output above indicates that  has been defined in the  module.
</p>
<br><br>
<p>As we have seen in the previous chapter, this function is almost always overridden to produce a more meaningful  representation:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.string;

<span class="keyword">class</span> Clock {
    <span class="keyword">override</span> string toString() <span class="keyword">const</span> {
        <span class="keyword">return</span> format(<span class="string_literal">"%02s:%02s:%02s"</span>, hour, minute, second);
    }

    <span class="comment">// ...
</span>}

<span class="keyword">class</span> AlarmClock : Clock {
    <span class="keyword">override</span> string toString() <span class="keyword">const</span> {
        <span class="keyword">return</span> format(<span class="string_literal">"%s â™«%02s:%02s"</span>, <span class="keyword">super</span>.toString(),
                      alarmHour, alarmMinute);
    }

    <span class="comment">// ...
</span>}

<span class="comment">// ...
</span>
    <span class="keyword">auto</span> bedSideClock = <span class="keyword">new</span> AlarmClock(20, 30, 0, 7, 0);
    writeln(bedSideClock);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The output:
</p>
<br><br>

<br><br>
<h5> </h5>
<br><br>
<p>As we have seen in the <a href="operator_overloading.html">Operator Overloading chapter</a>, this member function is about the behavior of the  operator (and the  operator indirectly). The return value of the operator must be  if the objects are considered to be equal and  otherwise.
</p>
<br><br>
<p><b>Warning:</b> The definition of this function must be consistent with ; for two objects that  returns ,  must return zero.
</p>
<br><br>
<p>Contrary to structs, the compiler does not call  right away when it sees the expression . When two class objects are compared by the  operator, a four-step algorithm is executed:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">bool</span> opEquals(Object a, Object b) {
    <span class="keyword">if</span> (a <span class="keyword">is</span> b) <span class="keyword">return</span> <span class="keyword">true</span>;                          <span class="comment">// (1)
</span>    <span class="keyword">if</span> (a <span class="keyword">is</span> <span class="keyword">null</span> || b <span class="keyword">is</span> <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;         <span class="comment">// (2)
</span>    <span class="keyword">if</span> (<span class="keyword">typeid</span>(a) == <span class="keyword">typeid</span>(b)) <span class="keyword">return</span> a.opEquals(b); <span class="comment">// (3)
</span>    <span class="keyword">return</span> a.opEquals(b) &amp;&amp; b.opEquals(a);            <span class="comment">// (4)
</span>}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<ol><br><br>
<li>If the two variables provide access to the same object (or they are both ), then they are equal.</li>
<br><br>
<li>Following from the previous check, if only one is  then they are not equal.</li>
<br><br>
<li>If both of the objects are of the same type, then  is called to determine the equality.</li>
<br><br>
<li>Otherwise, for the two objects to be considered equal,  must have been defined for both of their types and  and  must agree that the objects are equal.</li>
<br><br>
</ol>
<br><br>
<p>Accordingly, if  is not provided for a class type, then the values of the objects are not considered; rather, equality is determined by checking whether the two class variables provide access to the same object:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">auto</span> variable0 = <span class="keyword">new</span> Clock(6, 7, 8);
    <span class="keyword">auto</span> variable1 = <span class="keyword">new</span> Clock(6, 7, 8);

    <span class="keyword">assert</span>(variable0 != variable1); <span class="comment">// They are not equal
</span>                                    <span class="comment">// because the objects are
</span>                                    <span class="comment">// different
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Even though the two objects are constructed by the same arguments above, the variables are not equal because they are not associated with the same object.
</p>
<br><br>
<p>On the other hand, because the following two variables provide access to the same object, they are <i>equal</i>:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">auto</span> partner0 = <span class="keyword">new</span> Clock(9, 10, 11);
    <span class="keyword">auto</span> partner1 = partner0;

    <span class="keyword">assert</span>(partner0 == partner1);   <span class="comment">// They are equal because
</span>                                    <span class="comment">// the object is the same
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Sometimes it makes more sense to compare objects by their values instead of their identities. For example, it is conceivable that  and  above compare equal because their values are the same.
</p>
<br><br>
<p>Different from structs, the type of the parameter of  for classes is :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">class</span> Clock {
    <span class="keyword">override</span> <span class="keyword">bool</span> opEquals() <span class="keyword">const</span> {
        <span class="comment">// ...
</span>    }

    <span class="comment">// ...
</span>}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>As you will see below, the parameter is almost never used directly. For that reason, it should be acceptable to name it simply as . Most of the time the first thing to do with that parameter is to use it in a type conversion.
</p>
<br><br>
<p>The parameter of  is the object that appears on the right-hand side of the  operator:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    variable0 == variable1;    <span class="comment">// o represents variable1
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Since the purpose of  is to compare two objects of this class type, the first thing to do is to convert  to a variable of the same type of this class. Since it would not be appropriate to modify the right-hand side object in an equality comparison, it is also proper to convert the type as :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">override</span> <span class="keyword">bool</span> opEquals(Object o) <span class="keyword">const</span> {
        <span class="keyword">auto</span> rhs = <span class="keyword">cast</span>(<span class="keyword">const</span> Clock)o;

        <span class="comment">// ...
</span>    }
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>As you would remember,  is a common abbreviation for <i>right-hand side</i>. Also,  can be used for the conversion as well:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.conv;
<span class="comment">// ...
</span>        <span class="keyword">auto</span> rhs = to!(<span class="keyword">const</span> Clock)(o);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>If the original object on the right-hand side can be converted to , then  becomes a non- class variable. Otherwise,  is set to , indicating that the objects are not of the same type.
</p>
<br><br>
<p>According to the design of a program, it may make sense to compare objects of two incompatible types. I will assume here that for the comparison to be valid,  must not be ; so, the first logical expression in the following  statement checks that it is not . Otherwise, it would be an error to try to access the members of :
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">class</span> Clock {
    <span class="keyword">int</span> hour;
    <span class="keyword">int</span> minute;
    <span class="keyword">int</span> second;

    <span class="keyword">override</span> <span class="keyword">bool</span> opEquals(Object o) <span class="keyword">const</span> {
        <span class="keyword">auto</span> rhs = <span class="keyword">cast</span>(<span class="keyword">const</span> Clock)o;

        <span class="keyword">return</span> ( &amp;&amp;
                (hour == rhs.hour) &amp;&amp;
                (minute == rhs.minute) &amp;&amp;
                (second == rhs.second));
    }

    <span class="comment">// ...
</span>}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>With that definition,  objects can now be compared by their values:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">auto</span> variable0 = <span class="keyword">new</span> Clock(6, 7, 8);
    <span class="keyword">auto</span> variable1 = <span class="keyword">new</span> Clock(6, 7, 8);

    <span class="keyword">assert</span>(variable0 == variable1); <span class="comment">// Now they are equal
</span>                                    <span class="comment">// because their values
</span>                                    <span class="comment">// are equal
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>When defining  it is important to remember the members of the superclass. For example, when comparing objects of  it would make sense to also consider the inherited members:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">class</span> AlarmClock : Clock {
    <span class="keyword">int</span> alarmHour;
    <span class="keyword">int</span> alarmMinute;

    <span class="keyword">override</span> <span class="keyword">bool</span> opEquals(Object o) <span class="keyword">const</span> {
        <span class="keyword">auto</span> rhs = <span class="keyword">cast</span>(<span class="keyword">const</span> AlarmClock)o;

        <span class="keyword">return</span> (rhs &amp;&amp;
                (alarmHour == rhs.alarmHour) &amp;&amp;
                (alarmMinute == rhs.alarmMinute) &amp;&amp;
                );
    }

    <span class="comment">// ...
</span>}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>That expression could be written as  as well. However, that would initiate the four-step algorithm again and as a result, the code might be a little slower.
</p>
<br><br>
<h5> </h5>
<br><br>
<p>This operator is used when sorting class objects.  is the function that gets called behind the scenes for the , , , and .
</p>
<br><br>
<p>This operator must return a negative value when the left-hand object is before, a positive value when the left-hand object is after, and zero when both objects have the same sorting order.
</p>
<br><br>
<p><b>Warning:</b> The definition of this function must be consistent with ; for two objects that  returns ,  must return zero.
</p>
<br><br>
<p>Unlike  and , there is no default implementation of this function in . If the implementation is not available, comparing objects for sort order causes an exception to be thrown:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">auto</span> variable0 = <span class="keyword">new</span> Clock(6, 7, 8);
    <span class="keyword">auto</span> variable1 = <span class="keyword">new</span> Clock(6, 7, 8);

    <span class="keyword">assert</span>(variable0 &lt;= variable1);    
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>

<br><br>
<p>It is up to the design of the program what happens when the left-hand and right-hand objects are of different types. One way is to take advantage of the order of types that is maintained by the compiler automatically. This is achieved by calling the  function on the  values of the two types:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">class</span> Clock {
    <span class="keyword">int</span> hour;
    <span class="keyword">int</span> minute;
    <span class="keyword">int</span> second;

    <span class="keyword">override</span> <span class="keyword">int</span> opCmp(Object o) <span class="keyword">const</span> {
        <span class="comment">/* Taking advantage of the automatically-maintained
         * order of the types. */</span>
        <span class="keyword">if</span> (<span class="keyword">typeid</span>(<span class="keyword">this</span>) != <span class="keyword">typeid</span>(o)) {
            <span class="keyword">return</span> <span class="keyword">typeid</span>(<span class="keyword">this</span>).opCmp(<span class="keyword">typeid</span>(o));
        }

        <span class="keyword">auto</span> rhs = <span class="keyword">cast</span>(<span class="keyword">const</span> Clock)o;
        <span class="comment">/* No need to check whether rhs is null, because it is
         * known at this line that it has the same type as o. */</span>

        <span class="keyword">if</span> (hour != rhs.hour) {
            <span class="keyword">return</span> hour - rhs.hour;

        } <span class="keyword">else</span> <span class="keyword">if</span> (minute != rhs.minute) {
            <span class="keyword">return</span> minute - rhs.minute;

        } <span class="keyword">else</span> {
            <span class="keyword">return</span> second - rhs.second;
        }
    }

    <span class="comment">// ...
</span>}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The definition above first checks whether the types of the two objects are the same. If not, it uses the ordering of the types themselves. Otherwise, it compares the objects by the values of their , , and  members.
</p>
<br><br>
<p>A chain of ternary operators may also be used:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">override</span> <span class="keyword">int</span> opCmp(Object o) <span class="keyword">const</span> {
        <span class="keyword">if</span> (<span class="keyword">typeid</span>(<span class="keyword">this</span>) != <span class="keyword">typeid</span>(o)) {
            <span class="keyword">return</span> <span class="keyword">typeid</span>(<span class="keyword">this</span>).opCmp(<span class="keyword">typeid</span>(o));
        }

        <span class="keyword">auto</span> rhs = <span class="keyword">cast</span>(<span class="keyword">const</span> Clock)o;

        <span class="keyword">return</span> (hour != rhs.hour
                ? hour - rhs.hour
                : (minute != rhs.minute
                   ? minute - rhs.minute
                   : second - rhs.second));
    }
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>If important, the comparison of the members of the superclass must also be considered. The following  is calling  first:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">class</span> AlarmClock : Clock {
    <span class="keyword">override</span> <span class="keyword">int</span> opCmp(Object o) <span class="keyword">const</span> {
        <span class="keyword">auto</span> rhs = <span class="keyword">cast</span>(<span class="keyword">const</span> AlarmClock)o;

        <span class="keyword">const</span> <span class="keyword">int</span> superResult = ;

        <span class="keyword">if</span> (superResult != 0) {
            <span class="keyword">return</span> superResult;

        } <span class="keyword">else</span> <span class="keyword">if</span> (alarmHour != rhs.alarmHour) {
            <span class="keyword">return</span> alarmHour - rhs.alarmHour;

        } <span class="keyword">else</span> {
            <span class="keyword">return</span> alarmMinute - rhs.alarmMinute;
        }
    }

    <span class="comment">// ...
</span>}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Above, if the superclass comparison returns a nonzero value then that result is used because the sort order of the objects is already determined by that value.
</p>
<br><br>
<p> objects can now be compared for their sort orders:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">auto</span> ac0 = <span class="keyword">new</span> AlarmClock(8, 0, 0, 6, 30);
    <span class="keyword">auto</span> ac1 = <span class="keyword">new</span> AlarmClock(8, 0, 0, 6, 31);

    <span class="keyword">assert</span>(ac0 &lt; ac1);
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p> is used by other language features and libraries as well. For example, the  function takes advantage of  when sorting elements.
</p>
<br><br>
<h6> for string members</h6>
<br><br>
<p>When some of the members are strings, they can be compared explicitly to return a negative, positive, or zero value:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.exception;

<span class="keyword">class</span> Student {
    string name;

    <span class="keyword">override</span> <span class="keyword">int</span> opCmp(Object o) <span class="keyword">const</span> {
        <span class="keyword">auto</span> rhs = <span class="keyword">cast</span>(Student)o;
        enforce(rhs);

        <span class="keyword">if</span> (name &lt; rhs.name) {
            <span class="keyword">return</span> -1;

        } <span class="keyword">else</span> <span class="keyword">if</span> (name &gt; rhs.name) {
            <span class="keyword">return</span> 1;

        } <span class="keyword">else</span> {
            <span class="keyword">return</span> 0;
        }
    }

    <span class="comment">// ...
</span>}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Instead, the existing  function can be used, which happens to be faster as well:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> std.algorithm;

<span class="keyword">class</span> Student {
    string name;

    <span class="keyword">override</span> <span class="keyword">int</span> opCmp(Object o) <span class="keyword">const</span> {
        <span class="keyword">auto</span> rhs = <span class="keyword">cast</span>(Student)o;
        enforce(rhs);

        <span class="keyword">return</span> cmp(name, rhs.name);
    }

    <span class="comment">// ...
</span>}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Also note that  does not support comparing incompatible types by enforcing that the conversion from  to  is possible.
</p>
<br><br>
<h5> </h5>
<br><br>
<p>This function allows objects of a class type to be used as associative array <i>keys</i>. It does not affect the cases where the type is used as associative array <i>values</i>. If this function is defined,  must be defined as well.
</p>
<br><br>
<h6> Hash table indexes</h6>
<br><br>
<p>Associative arrays are a hash table implementation. Hash table is a very fast data structure when it comes to searching elements in the table. (<i>Note: Like most other things in software, this speed comes at a cost: Hash tables must keep elements in an unordered way, and they may be taking up space that is more than exactly necessary.</i>)
</p>
<br><br>
<p>The high speed of hash tables comes from the fact that they first produce integer values for keys. These integers are called <i>hash values</i>. The hash values are then used for indexing into an internal array that is maintained by the table.
</p>
<br><br>
<p>A benefit of this method is that any type that can produce unique integer values for its objects can be used as the key type of associative arrays.  is the function that returns the hash value for an object.
</p>
<br><br>
<p>Even  objects can be used as associative array key values:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    string[] timeTags;
    timeTags[<span class="keyword">new</span> Clock(12, 0, 0)] = <span class="string_literal">"Noon"</span>;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>The default definition of  that is inherited from  produces different hash values for different objects without regard to their values. This is similar to how the default behavior of  considers different objects as being not equal.
</p>
<br><br>
<p>The code above compiles and runs even when there is no special definition of  for . However, its default behavior is almost never what is desired. To see that default behavior, let's try to access an element by an object that is different from the one that has been used when inserting the element. Although the new  object below has the same value as the  object that has been used when inserting into the associative array above, the value cannot be found:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">    <span class="keyword">if</span> (<span class="keyword">new</span> Clock(12, 0, 0) <span class="keyword">in</span> timeTags) {
        writeln(<span class="string_literal">"Exists"</span>);

    } <span class="keyword">else</span> {
        writeln(<span class="string_literal">"Missing"</span>);
    }
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>According to the  operator, there is no element in the table that corresponds to the value :
</p>
<br><br>

<br><br>
<p>The reason for this surprising behavior is that the key object that has been used when inserting the element is not the same as the key object that has been used when accessing the element.
</p>
<br><br>
<h6>Selecting members for </h6>
<br><br>
<p>Although the hash value is calculated from the members of an object, not every member is suitable for this task.
</p>
<br><br>
<p>The candidates are the members that distinguish objects from each other. For example, the members  and  of a  class would be suitable if those members can be used for identifying objects of that type.
</p>
<br><br>
<p>On the other hand, a  array of a  class would not be suitable both because many objects may have the same array and also it is likely that the  array may change over time.
</p>
<br><br>
<h6>Calculating hash values</h6>
<br><br>
<p>The choice of hash values has a direct effect on the performance of associative arrays. Furthermore, a hash calculation that is effective on one type of data may not be as effective on another type of data. As <i>hash algorithms</i> are beyond the scope of this book, I will give just one guideline here: In general, it is better to produce different hash values for objects that are considered to have different values. However, it is not an error if two objects with different values produce the same index value; it is merely undesirable for performance reasons.
</p>
<br><br>
<p>It is conceivable that all of the members of  are significant to distinguish its objects from each other. For that reason, the hash values can be calculated from the values of its three members. <i>The number of seconds since midnight</i> would be effective hash values for objects that represent different points in time:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">class</span> Clock {
    <span class="keyword">int</span> hour;
    <span class="keyword">int</span> minute;
    <span class="keyword">int</span> second;

    <span class="keyword">override</span> size_t toHash() <span class="keyword">const</span> {
        <span class="comment">/* Because there are 3600 seconds in an hour and 60
         * seconds in a minute: */</span>
        <span class="keyword">return</span> (3600 * hour) + (60 * minute) + second;
    }

    <span class="comment">// ...
</span>}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p>Whenever  is used as the key type of associative arrays, that special definition of  would be used. As a result, even though the two key objects of  above are distinct, they would now produce the same hash value.
</p>
<br><br>
<p>The new output:
</p>
<br><br>

<br><br>
<p>Similar to the other member functions, the superclass may need to be considered as well. For example,  can take advantage of  during its index calculation:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">class</span> AlarmClock : Clock {
    <span class="keyword">int</span> alarmHour;
    <span class="keyword">int</span> alarmMinute;

    <span class="keyword">override</span> size_t toHash() <span class="keyword">const</span> {
        <span class="keyword">return</span>  + alarmHour + alarmMinute;
    }

    <span class="comment">// ...
</span>}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<p><i><b>Note:</b> Take the calculation above just as an example. In general, adding integer values is not an effective way of generating hash values.</i>
</p>
<br><br>
<p>There are existing efficient algorithms for calculating hash values for variables of floating point, array, and struct types. These algorithms are available to the programmer as well.
</p>
<br><br>
<p> What needs to be done is to call  on the  of each member. The syntax of this method is the same for floating point, array, and struct types.
</p>
<br><br>
<p>For example, hash values of a  type can be calculated from its  member as in the following code:
</p>
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">class</span> Student {
    string name;

    <span class="keyword">override</span> size_t toHash() <span class="keyword">const</span> {
        <span class="keyword">return</span> <span class="keyword">typeid</span>(name).getHash(&amp;name);
    }

    <span class="comment">// ...
</span>}
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
<h6>Hash values for structs</h6>
<br><br>
<p>Since structs are value types, hash values for their objects are calculated automatically by an efficient algorithm. That algorithm takes all of the members of the object into consideration.
</p>
<br><br>
<p>When there is a specific reason like needing to exclude certain members from the hash calculation,  can be overridden for structs as well.
</p>
<br><br>


</section>
      </article>
    </div>
  </body>
</html>
